import{_ as t,r,o as p,c as n,b as i,d as a,e as g,a as e}from"./app-382cdfb3.js";const c="/jixiang/assets/image-20240720225507978-59992e68.png",d="/jixiang/assets/image-20240720225658719-33ee088f.png",m="/jixiang/assets/image-20240720230421442-4890e248.png",h="/jixiang/assets/image-20240720230741061-b04294ec.png",o="/jixiang/assets/image-20240720232556780-49d0e6d5.png",_="/jixiang/assets/image-20240721072937404-a3e3a37e.png",l="/jixiang/assets/image-20240721075649661-c191fd21.png",x="/jixiang/assets/image-20240721072904442-f57713cd.png",b="/jixiang/assets/image-20240721073236152-a3f96bd0.png",f="/jixiang/assets/image-20240721075311631-ec401ccb.png",j="/jixiang/assets/image-20240721075449077-97d39a97.png",u="/jixiang/assets/image-20240721101402097-6158af8a.png",S="/jixiang/assets/image-20240721101511166-3a488e49.png",w="/jixiang/assets/image-20240721102324896-a00b7965.png",v="/jixiang/assets/image-20240721103304864-82ebf96e.png",B="/jixiang/assets/image-20240721103700632-8ba9447c.png",J="/jixiang/assets/image-20240721104118221-64243e68.png",A="/jixiang/assets/image-20240721104504030-ffdebcdb.png",N="/jixiang/assets/image-20240721104826619-b8e23395.png",D="/jixiang/assets/image-20240721105232148-4306307e.png",C="/jixiang/assets/image-20240721105526162-a2d0dccd.png",I="/jixiang/assets/image-20240721110047614-7577200c.png",E="/jixiang/assets/image-20240721110229303-d1ac7dd7.png",V="/jixiang/assets/image-20240721110624894-74f5f761.png",k="/jixiang/assets/image-20240721110906096-15d6a904.png",q="/jixiang/assets/image-20240721111125026-e6074724.png",M="/jixiang/assets/image-20240721121918689-b61c0787.png",O="/jixiang/assets/image-20240721121951185-fe692760.png",y="/jixiang/assets/image-20240721122017581-1a9991c6.png",z="/jixiang/assets/image-20240721122613390-2a9d26ee.png",F="/jixiang/assets/image-20240721130825811-fb1e83e1.png",L="/jixiang/assets/image-20240721131346307-35bc4e6c.png",P="/jixiang/assets/image-20240721134319024-55e2b583.png",T="/jixiang/assets/image-20240721133916963-7fbff9a3.png",G="/jixiang/assets/image-20240721135837692-59e0a18a.png",H="/jixiang/assets/image-20240721150101961-8256715d.png",R="/jixiang/assets/image-20240721150138599-4ea837f3.png",U="/jixiang/assets/image-20240721150910019-341d1176.png",W="/jixiang/assets/image-20240721152552910-ea3621fd.png",K="/jixiang/assets/image-20240721152849469-1f411f3c.png",Q="/jixiang/assets/image-20240721155516391-dda45274.png",X="/jixiang/assets/image-20240721161939519-2151af3c.png",Y="/jixiang/assets/image-20240721162620569-58f1b9aa.png",Z="/jixiang/assets/image-20240721163401745-97785077.png",$="/jixiang/assets/image-20240721170235038-7e637e27.png",aa="/jixiang/assets/image-20240721174511977-e9dea1fb.png",ia="/jixiang/assets/image-20240721174543248-d3e09e71.png",ea="/jixiang/assets/image-20240721170929103-09ea06ca.png",sa="/jixiang/assets/image-20240721175607545-fa467976.png",ta="/jixiang/assets/image-20240721174658934-08ff4d8d.png",ra="/jixiang/assets/image-20240721231145750-d33fe55d.png",pa="/jixiang/assets/image-20240721231021503-2f7d97c3.png",na="/jixiang/assets/image-20240721231940079-4006ba02.png",ga="/jixiang/assets/image-20240721233830489-20c98728.png",ca="/jixiang/assets/image-20240721234123458-ad907307.png",da="/jixiang/assets/image-20240722080748628-a192305f.png",ma="/jixiang/assets/image-20240722084343419-d9179217.png",ha="/jixiang/assets/image-20240722084711534-3d06738b.png",oa="/jixiang/assets/image-20240722100522746-99cddad1.png",_a="/jixiang/assets/image-20240722100631632-5567149f.png",la="/jixiang/assets/image-20240722101024002-a4de9d44.png",xa="/jixiang/assets/image-20240722101528894-f3afe083.png",ba="/jixiang/assets/image-20240722104422156-98bd753d.png",fa="/jixiang/assets/image-20240722104525778-61e1536c.png",ja="/jixiang/assets/JavaScript内存分配-e777f999.png",ua="/jixiang/assets/image-20240722104601487-88acff31.png",Sa="/jixiang/assets/image-20240722123659310-74fa0b4c.png",wa="/jixiang/assets/两个对象比较的内存图-ad44fe13.png",va="/jixiang/assets/对象的引用赋值内存图-1721624484151-daf4d72d.png",Ba="/jixiang/assets/函数传递-值传递-cc85359f.png",Ja="/jixiang/assets/函数传递-引用传递-创建新对象-1638bb95.png",Aa="/jixiang/assets/函数传递-引用传递-修改引用属性-8b53b1ed.png",Na="/jixiang/assets/image-20240722131319433-36a68085.png",Da="/jixiang/assets/image-20240722131340565-3de2897e.png",Ca="/jixiang/assets/image-20240722132048239-8676dab4.png",Ia="/jixiang/assets/image-20240722134044802-20fbcc74.png",Ea="/jixiang/assets/image-20240722134451558-4203e688.png",Va="/jixiang/assets/image-20240722132348985-aa512629.png",ka="/jixiang/assets/image-20240722135301969-f5cad7d0.png",qa="/jixiang/assets/image-20240722153324666-0021b36d.png",Ma="/jixiang/assets/image-20240722153448455-09a06202.png",Oa="/jixiang/assets/image-20240722153533231-0f612930.png",ya="/jixiang/assets/image-20240722153622826-9efd64c7.png",za="/jixiang/assets/image-20240722153649694-add3fc91.png",Fa="/jixiang/assets/image-20240722153911707-a19e06db.png",La="/jixiang/assets/image-20240722155701724-387d0d24.png",Pa="/jixiang/assets/image-20240722161843676-3cb02156.png",Ta="/jixiang/assets/image-20240722163610852-60cb4404.png",Ga="/jixiang/assets/image-20240722163640996-879de3e2.png",Ha="/jixiang/assets/image-20240722175638201-6e3324bd.png",Ra="/jixiang/assets/image-20240722163702985-e0dffa96.png",Ua="/jixiang/assets/image-20240722182104481-0b23bc1a.png",Wa="/jixiang/assets/image-20240722182526035-c9f379c5.png",Ka="/jixiang/assets/image-20240722183159951-4f33d472.png",Qa="/jixiang/assets/image-20240722183544432-9e82adf6.png",Xa="/jixiang/assets/image-20240722183813721-af077001.png",Ya="/jixiang/assets/image-20240722163729953-3c5a94fa.png",Za="/jixiang/assets/image-20240722185234978-b369aa1a.png",$a="/jixiang/assets/image-20240722163754871-5dca11dd.png",a2="/jixiang/assets/image-20240722163823375-162878f0.png",i2="/jixiang/assets/image-20240722163854166-3b023178.png",e2="/jixiang/assets/image-20240722213530340-0cbd38b6.png",s2="/jixiang/assets/image-20240722213916882-6d392ef8.png",t2="/jixiang/assets/image-20240722214559170-3081308c.png",r2="/jixiang/assets/image-20240722223001051-bf538f27.png",p2="/jixiang/assets/image-20240722163950702-6bdd748a.png",n2="/jixiang/assets/image-20240722164122372-894ba210.png",g2="/jixiang/assets/image-20240722223700674-654ae7c8.png",c2="/jixiang/assets/image-20240722224322166-e9c5ff45.png",d2="/jixiang/assets/image-20240722224752248-6a3395e2.png",m2="/jixiang/assets/image-20240722164149920-611b081c.png",h2="/jixiang/assets/image-20240722232835235-4c1c9cc9.png",o2="/jixiang/assets/image-20240722233105626-e9376392.png",_2="/jixiang/assets/image-20240722233745266-90dae70b.png",l2="/jixiang/assets/image-20240722164212436-74190293.png",x2="/jixiang/assets/image-20240722164239633-376a0798.png",b2="/jixiang/assets/image-20240722234413725-39853411.png",f2="/jixiang/assets/image-20240722164310986-1fccb8bd.png",j2="/jixiang/assets/image-20240722234923381-a7037a4b.png",u2="/jixiang/assets/image-20240722164338753-4f9122c1.png",S2="/jixiang/assets/image-20240723001140688-aad999e3.png",w2="/jixiang/assets/image-20240723002045201-b63290d7.png",v2="/jixiang/assets/image-20240723002540597-cab33c89.png",B2="/jixiang/assets/image-20240723002916988-8a82c46e.png",J2="/jixiang/assets/image-20240723103828577-7fa253f6.png",A2="/jixiang/assets/image-20240723103745802-71a44b82.png",N2="/jixiang/assets/image-20240723104414208-c279f751.png",D2="/jixiang/assets/image-20240723104725508-905ad718.png",C2="/jixiang/assets/image-20240723104921878-4051a233.png",I2="/jixiang/assets/image-20240723105653802-375dccb4.png",E2="/jixiang/assets/image-20240723121921413-62b71203.png",V2="/jixiang/assets/image-20240723122334287-a3b2359d.png",k2="/jixiang/assets/image-20240723110842521-8ccb045e.png",q2="/jixiang/assets/image-20240723114450238-cb7541b7.png",M2="/jixiang/assets/image-20240723121527854-af66b7d8.png",O2="/jixiang/assets/image-20240723122707243-80dfa0dd.png",y2="/jixiang/assets/image-20240723165723576-568bac45.png",z2="/jixiang/assets/image-20240723170122932-461fc0d8.png",F2="/jixiang/assets/image-20240723145801090-e6edf176.png",L2="/jixiang/assets/image-20240723170926997-6d992aae.png",P2="/jixiang/assets/image-20240723172026833-bdf27c3e.png",T2="/jixiang/assets/image-20240723170906024-2bbd68c1.png",G2="/jixiang/assets/image-20240723173003501-442cbde9.png",H2="/jixiang/assets/image-20240723172255620-69e521df.png",R2="/jixiang/assets/image-20240723173919668-9a602742.png",U2="/jixiang/assets/image-20240723174026889-f1250195.png",W2="/jixiang/assets/image-20240723180642535-733f0803.png",K2="/jixiang/assets/image-20240723181418133-a848dd81.png",Q2="/jixiang/assets/image-20240723181607244-09246e5f.png",X2="/jixiang/assets/image-20240723182001601-c0814b89.png",Y2="/jixiang/assets/image-20240723184526286-62963981.png",Z2="/jixiang/assets/image-20240723184711223-0c471f05.png",$2="/jixiang/assets/image-20240723193841754-2e3e8a74.png",ai="/jixiang/assets/image-20240723194127890-f73a64c5.png",ii="/jixiang/assets/image-20240723195906545-533a129a.png",ei="/jixiang/assets/image-20240723200056813-3501ed96.png",si={},ti=e('<h2 id="一-javascript基础语法" tabindex="-1"><a class="header-anchor" href="#一-javascript基础语法" aria-hidden="true">#</a> 一，Javascript基础语法</h2><h3 id="_1-chrome的调试工具" tabindex="-1"><a class="header-anchor" href="#_1-chrome的调试工具" aria-hidden="true">#</a> 1，Chrome的调试工具</h3><p><img src="'+c+'" alt="image-20240720225507978"></p><p>一般在控制台中不会书写多行代码，如果要书写，摁住shift+enter。效果如下：</p><p><img src="'+d+'" alt="image-20240720225658719"></p><h3 id="_2-js语句和分号" tabindex="-1"><a class="header-anchor" href="#_2-js语句和分号" aria-hidden="true">#</a> 2，JS语句和分号</h3><p><img src="'+m+'" alt="image-20240720230421442"></p><h3 id="_3-js注释方式" tabindex="-1"><a class="header-anchor" href="#_3-js注释方式" aria-hidden="true">#</a> 3，JS注释方式</h3><p><img src="'+h+'" alt="image-20240720230741061"></p><p>除了常见的单行注释和多行注释外，还有一种文档注释。只能写在js文件中，可以对函数和类进行说明，代码和效果如下：</p><p><img src="'+o+'" alt="image-20240720232556780"></p><h3 id="_4-vscode配置" tabindex="-1"><a class="header-anchor" href="#_4-vscode配置" aria-hidden="true">#</a> 4，VsCode配置</h3><p><img src="'+_+'" alt="image-20240721072937404"></p><h4 id="a-代码片段提示" tabindex="-1"><a class="header-anchor" href="#a-代码片段提示" aria-hidden="true">#</a> A）代码片段提示</h4><p><img src="'+l+'" alt="image-20240721075649661"></p><h4 id="b-括号高亮" tabindex="-1"><a class="header-anchor" href="#b-括号高亮" aria-hidden="true">#</a> B）括号高亮</h4><p>第一步：打开设置，如下：</p><p><img src="'+x+'" alt="image-20240721072904442"></p><p>第二步：打开相关插件，复制代码。如下：</p><p><img src="'+b+'" alt="image-20240721073236152"></p><p>第三步：打开设置的json文件，操作如下：</p><p><img src="'+f+'" alt="image-20240721075311631"></p><p>第四步：将拷贝的代码放入json文件中，操作如下：</p><p><img src="'+j+'" alt="image-20240721075449077"></p><h2 id="二-js数据类型转换" tabindex="-1"><a class="header-anchor" href="#二-js数据类型转换" aria-hidden="true">#</a> 二，JS数据类型转换</h2><h3 id="_1-数据类型和typeof操作符" tabindex="-1"><a class="header-anchor" href="#_1-数据类型和typeof操作符" aria-hidden="true">#</a> 1，数据类型和typeof操作符</h3><p><img src="'+u+'" alt="image-20240721101402097"></p><h3 id="_2-常见的数据类型" tabindex="-1"><a class="header-anchor" href="#_2-常见的数据类型" aria-hidden="true">#</a> 2，常见的数据类型</h3><p><img src="'+S+'" alt="image-20240721101511166"></p><p>因为一些字符具有特殊意义，因此我们想让其真实显示，应该在前面加上\\进行转义。代码和效果如下：</p><p><img src="'+w+'" alt="image-20240721102324896"></p><h3 id="_3-字符串string的转换" tabindex="-1"><a class="header-anchor" href="#_3-字符串string的转换" aria-hidden="true">#</a> 3，字符串String的转换</h3><p><img src="'+v+'" alt="image-20240721103304864"></p><p><img src="'+B+'" alt="image-20240721103700632"></p><h4 id="a-隐式转换" tabindex="-1"><a class="header-anchor" href="#a-隐式转换" aria-hidden="true">#</a> A）隐式转换</h4><p>方式一：如果+运算符左右两边有一个是字符串，那么另一边会自动转换成字符串类型进行拼接。代码和效果如下：</p><p><img src="'+J+'" alt="image-20240721104118221"></p><p>方式二：某些函数的执行也会自动将参数转为字符串类型，比如console.log函数。</p><h4 id="b-显式转换" tabindex="-1"><a class="header-anchor" href="#b-显式转换" aria-hidden="true">#</a> B）显式转换</h4><p>我们可以使用String()函数，将参数转换为string类型。代码和效果如下：</p><p><img src="'+A+'" alt="image-20240721104504030"></p><h3 id="_4-数字类型number的转换" tabindex="-1"><a class="header-anchor" href="#_4-数字类型number的转换" aria-hidden="true">#</a> 4，数字类型Number的转换</h3><p><img src="'+N+'" alt="image-20240721104826619"></p><h4 id="a-隐式转换-1" tabindex="-1"><a class="header-anchor" href="#a-隐式转换-1" aria-hidden="true">#</a> A）隐式转换</h4><p>在算数运算(+操作符除外)中，通常会将其他类型转换成数字类型来进行运算，实际开发中很少使用。代码和效果如下：</p><p><img src="'+D+'" alt="image-20240721105232148"></p><h4 id="b-显式转换-1" tabindex="-1"><a class="header-anchor" href="#b-显式转换-1" aria-hidden="true">#</a> B）显式转换</h4><p>我们也可以使用Number()函数来进行显式的转换，代码和效果如下：</p><p><img src="'+C+'" alt="image-20240721105526162"></p><p>注意使用Number函数对其他类型转换时需要特别注意字符串类型。代码和效果如下：</p><p><img src="'+I+'" alt="image-20240721110047614"></p><h3 id="_5-布尔类型boolean的转换" tabindex="-1"><a class="header-anchor" href="#_5-布尔类型boolean的转换" aria-hidden="true">#</a> 5，布尔类型Boolean的转换</h3><p><img src="'+E+'" alt="image-20240721110229303"></p><h4 id="a-隐式转换-2" tabindex="-1"><a class="header-anchor" href="#a-隐式转换-2" aria-hidden="true">#</a> A）隐式转换</h4><p>在分支语句中，直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false，其他值变成 true。</p><p><img src="'+V+'" alt="image-20240721110624894"></p><h3 id="b-显式转换-2" tabindex="-1"><a class="header-anchor" href="#b-显式转换-2" aria-hidden="true">#</a> B）显式转换</h3><p>不管显式还是隐式都符合同样的规则。代码和结果如下</p><p><img src="'+k+'" alt="image-20240721110906096"></p><p>注意：包含 0 的字符串 &quot;0&quot; 是 true 一些编程语言（比如 PHP）视 &quot;0&quot; 为 false。但在 JavaScript 中，非空的字符串总是 true。代码如下：</p><p><img src="'+q+'" alt="image-20240721111125026"></p><h2 id="三-js基础运算符" tabindex="-1"><a class="header-anchor" href="#三-js基础运算符" aria-hidden="true">#</a> 三，JS基础运算符</h2><h3 id="_1-赋值运算符" tabindex="-1"><a class="header-anchor" href="#_1-赋值运算符" aria-hidden="true">#</a> 1，赋值运算符</h3><p><img src="'+M+'" alt="image-20240721121918689"></p><h3 id="_2-自增、自减运算符" tabindex="-1"><a class="header-anchor" href="#_2-自增、自减运算符" aria-hidden="true">#</a> 2，自增、自减运算符</h3><p><img src="'+O+'" alt="image-20240721121951185"></p><p><img src="'+y+'" alt="image-20240721122017581"></p><h3 id="_3-比较运算符" tabindex="-1"><a class="header-anchor" href="#_3-比较运算符" aria-hidden="true">#</a> 3，比较运算符</h3><p><img src="'+z+'" alt="image-20240721122613390"></p><h2 id="四-js分支语句" tabindex="-1"><a class="header-anchor" href="#四-js分支语句" aria-hidden="true">#</a> 四，JS分支语句</h2><h3 id="_1-三元运算符" tabindex="-1"><a class="header-anchor" href="#_1-三元运算符" aria-hidden="true">#</a> 1，三元运算符</h3><p><img src="'+F+'" alt="image-20240721130825811"></p><h3 id="_2-逻辑运算符" tabindex="-1"><a class="header-anchor" href="#_2-逻辑运算符" aria-hidden="true">#</a> 2，逻辑运算符</h3><h4 id="a-逻辑与的本质" tabindex="-1"><a class="header-anchor" href="#a-逻辑与的本质" aria-hidden="true">#</a> A）逻辑与的本质</h4><p><img src="'+L+'" alt="image-20240721131346307"></p><p>逻辑或：第一个运算元转换成Boolean类型，如果为true，则返回以初始值的形式返回该运算元。如果为false，以此类推。如果都为false，则返回最后一个运算元。代码如下：</p><p><img src="'+P+'" alt="image-20240721134319024"></p><h4 id="b-逻辑与的本质" tabindex="-1"><a class="header-anchor" href="#b-逻辑与的本质" aria-hidden="true">#</a> B）逻辑与的本质</h4><p><img src="'+T+'" alt="image-20240721133916963"></p><p>逻辑与：如果第一个运算元为true，则判断下一个运算元。如果第一个运算元为false，则以初始值的形式返回该运算元。依次类推，代码如下：</p><p><img src="'+G+'" alt="image-20240721135837692"></p><h3 id="_3-switch语句" tabindex="-1"><a class="header-anchor" href="#_3-switch语句" aria-hidden="true">#</a> 3，switch语句</h3><p><img src="'+H+'" alt="image-20240721150101961"></p><p><img src="'+R+'" alt="image-20240721150138599"></p><p>注意事项：这里的相等是严格相等，被比较的值必须是相同的类型才能进行匹配。代码如下：</p><p><img src="'+U+'" alt="image-20240721150910019"></p><h2 id="五-js函数" tabindex="-1"><a class="header-anchor" href="#五-js函数" aria-hidden="true">#</a> 五，JS函数</h2><h3 id="_1-函数的头等公民" tabindex="-1"><a class="header-anchor" href="#_1-函数的头等公民" aria-hidden="true">#</a> 1，函数的头等公民</h3><p><img src="'+W+'" alt="image-20240721152552910"></p><p>特性一：函数可以被赋值给变量，也可以在变量之间来回传递。代码和效果如下：</p><p><img src="'+K+'" alt="image-20240721152849469"></p><p>特性二：函数可以作为另一个函数的参数，代码和效果如下：</p><p><img src="'+Q+'" alt="image-20240721155516391"></p><p>特性三：函数作为另一个函数的返回值</p><p><img src="'+X+'" alt="image-20240721161939519"></p><p>特性四：可以将函数存储在另一个数据结构中，代码和效果如下：</p><p><img src="'+Y+'" alt="image-20240721162620569"></p><p>综上所述，我们可以说JavaScript支持函数式编程，其他语言不支持上述用法。</p><h3 id="_2-函数回调、匿名函数" tabindex="-1"><a class="header-anchor" href="#_2-函数回调、匿名函数" aria-hidden="true">#</a> 2，函数回调、匿名函数</h3><p>函数回调是指，一个函数在其他地方(一般为另一个函数的内容)被调用。一个函数执行，进而调用另一个函数，这个过程称为函数的回调。</p><p><img src="'+Z+'" alt="image-20240721163401745"></p><p>通常匿名函数会作为回调函数传入，代码和效果如下：</p><p><img src="'+$+'" alt="image-20240721170235038"></p><p>高阶函数必须至少满足两个条件之一：</p><ul><li>接受一个或多个函数作为输入。</li><li>输出一个函数。</li></ul><h3 id="_3-立即执行函数" tabindex="-1"><a class="header-anchor" href="#_3-立即执行函数" aria-hidden="true">#</a> 3，立即执行函数</h3><p><img src="'+aa+'" alt="image-20240721174511977"></p><p><img src="'+ia+'" alt="image-20240721174543248"></p><h3 id="_4-代码风格" tabindex="-1"><a class="header-anchor" href="#_4-代码风格" aria-hidden="true">#</a> 4，代码风格</h3><p><img src="'+ea+'" alt="image-20240721170929103"></p><p>在书写代码时，我们应该遵循一些代码格式。如下：</p><p><img src="'+sa+'" alt="image-20240721175607545"></p><h3 id="_5-chrome的debug调试技巧" tabindex="-1"><a class="header-anchor" href="#_5-chrome的debug调试技巧" aria-hidden="true">#</a> 5，Chrome的debug调试技巧</h3><p><img src="'+ta+'" alt="image-20240721174658934"></p><h4 id="a-技巧一" tabindex="-1"><a class="header-anchor" href="#a-技巧一" aria-hidden="true">#</a> A）技巧一</h4><p>我们编写的js代码，浏览器会全部执行。但是如果我们需要调试，让浏览器执行代码在某一行停住，我们就需要打断点，代码如下：</p><p><img src="'+ra+'" alt="image-20240721231145750"></p><p>调试操作如下：</p><p><img src="'+pa+'" alt="image-20240721231021503"></p><p>但是如果代码比较多，我们不方便在chrome中的源代码选项中点击对应的行数进行调试。我们应该在代码中使用debugger关键字，来打断点。操作如下：</p><p><img src="'+na+'" alt="image-20240721231940079"></p><p>我们再单步调试代码时，还可以监测到某个变量当前的值，操作如下：</p><p><img src="'+ga+'" alt="image-20240721233830489"></p><p>我们还可以打上多个断点，并且可以在调试栏中控制是否生效，操作如下：</p><p><img src="'+ca+'" alt="image-20240721234123458"></p><p>代码执行到某一行时，我们还可以查看当前有那些作用域，以及对应的局部变量。操作如下：</p><p><img src="'+da+'" alt="image-20240722080748628"></p><h4 id="b-技巧二" tabindex="-1"><a class="header-anchor" href="#b-技巧二" aria-hidden="true">#</a> B）技巧二</h4><p>进入下一个函数调用按钮和单步调试按钮的区别，是否跳过异步函数的执行。操作如下：</p><p><img src="'+ma+'" alt="image-20240722084343419"></p><p>遇到异步函数时，点击下一个函数调用按钮。在异步函数开始执行时，会进入到异步回调函数的内部，如下：</p><p><img src="'+ha+'" alt="image-20240722084711534"></p><h2 id="六-js面向对象" tabindex="-1"><a class="header-anchor" href="#六-js面向对象" aria-hidden="true">#</a> 六，JS面向对象</h2><h3 id="_1-对象类型的使用" tabindex="-1"><a class="header-anchor" href="#_1-对象类型的使用" aria-hidden="true">#</a> 1，对象类型的使用</h3><h4 id="a-方括号和引用的使用" tabindex="-1"><a class="header-anchor" href="#a-方括号和引用的使用" aria-hidden="true">#</a> A）方括号和引用的使用</h4><p><img src="'+oa+'" alt="image-20240722100522746"></p><p>如果对象属性是多个单词，那么我们在使用时，就应该以方括号进行包裹。如果对象数字是一个变量，我们也应该用方括号进行包裹，代码如下：</p><p><img src="'+_a+'" alt="image-20240722100631632"></p><h4 id="b-对象的遍历" tabindex="-1"><a class="header-anchor" href="#b-对象的遍历" aria-hidden="true">#</a> B）对象的遍历</h4><p><img src="'+la+'" alt="image-20240722101024002"></p><p>我们想挨个拿到对象中的所有属性和属性值，因此我们可以通过for...in进行遍历。代码和效果如下：</p><p><img src="'+xa+'" alt="image-20240722101528894"></p><p>注意：for...of可以遍历数组，但是不能遍历对象，因为{}不是一个可迭代对象。代码如下：</p><p><img src="'+ba+'" alt="image-20240722104422156"></p><h3 id="_2-值类型和引用类型" tabindex="-1"><a class="header-anchor" href="#_2-值类型和引用类型" aria-hidden="true">#</a> 2，值类型和引用类型</h3><h4 id="a-栈和堆" tabindex="-1"><a class="header-anchor" href="#a-栈和堆" aria-hidden="true">#</a> A）栈和堆</h4><p><img src="'+fa+'" alt="image-20240722104525778"></p><p>在JS中，基本数据类型会直接存储到栈中，而复杂数据类型会在栈中存放地址，值存储在堆中。如下：</p><p><img src="'+ja+'" alt="JavaScript内存分配"></p><h4 id="b-值类型和引用类型" tabindex="-1"><a class="header-anchor" href="#b-值类型和引用类型" aria-hidden="true">#</a> B）值类型和引用类型</h4><p><img src="'+ua+'" alt="image-20240722104601487"></p><p>值类型直接保存在栈中，而引用类型只是将地址保存在栈中，本身保存在堆中。</p><h4 id="c-js中的一些现象" tabindex="-1"><a class="header-anchor" href="#c-js中的一些现象" aria-hidden="true">#</a> C）JS中的一些现象</h4><p><img src="'+Sa+'" alt="image-20240722123659310"></p><p>现象一：对象比较，即使都为空，没有任何属性，也不相等，因为内存地址不一样。如下：</p><p><img src="'+wa+'" alt="两个对象比较的内存图"></p><p>现象二：对象的引用赋值，如下：</p><p><img src="'+va+'" alt="对象的引用赋值内存图"></p><p>现象三：函数传递，如下：</p><p>值传递：将一个值类型传递给函数的参数，即使给参数重新赋值，也不会改变原有值类型的值。如下：</p><p><img src="'+Ba+'" alt="函数传递-值传递"></p><p>引用传递，如下：</p><p><img src="'+Ja+'" alt="函数传递-引用传递-创建新对象"></p><p>现象四：引用传递，但是对传入的对象进行修改。如下：</p><p><img src="'+Aa+'" alt="函数传递-引用传递-修改引用属性"></p><h3 id="_3-函数的this指向" tabindex="-1"><a class="header-anchor" href="#_3-函数的this指向" aria-hidden="true">#</a> 3，函数的this指向</h3><h4 id="a-为什么要this" tabindex="-1"><a class="header-anchor" href="#a-为什么要this" aria-hidden="true">#</a> A）为什么要this</h4><p><img src="'+Na+'" alt="image-20240722131319433"></p><p>函数中默认除了有arguments，还有this。this变量在大多数情况下会指向一个对象。箭头函数中没有this.</p><h4 id="b-this指向什么" tabindex="-1"><a class="header-anchor" href="#b-this指向什么" aria-hidden="true">#</a> B）this指向什么</h4><p><img src="'+Da+'" alt="image-20240722131340565"></p><p>情况一：如果普通函数被默认调用，那么this默认指向的就是window(严格模式下，指向undefined)。如下：</p><p><img src="'+Ca+'" alt="image-20240722132048239"></p><p>如果我们将对象中的方法保存在某个变量中，再对其进行调用，那么this还是指向window。因为还是独立函数调用，如下：</p><p><img src="'+Ia+'" alt="image-20240722134044802"></p><p>案例练习：</p><p><img src="'+Ea+'" alt="image-20240722134451558"></p><p>情况二：如果函数它是被某一个对象来引用，并且调用它，那么this指向该对象。如下：</p><p><img src="'+Va+'" alt="image-20240722132348985"></p><h4 id="c-this开发中的使用" tabindex="-1"><a class="header-anchor" href="#c-this开发中的使用" aria-hidden="true">#</a> C）this开发中的使用</h4><p>this在我们对一些工具类函数封装时，非常有用。</p><p><img src="'+ka+'" alt="image-20240722135301969"></p><h3 id="_4-工厂方法创建对象" tabindex="-1"><a class="header-anchor" href="#_4-工厂方法创建对象" aria-hidden="true">#</a> 4，工厂方法创建对象</h3><p><img src="'+qa+'" alt="image-20240722153324666"></p><p><img src="'+Ma+'" alt="image-20240722153448455"></p><h3 id="_5-构造函数和类" tabindex="-1"><a class="header-anchor" href="#_5-构造函数和类" aria-hidden="true">#</a> 5，构造函数和类</h3><h4 id="a-构造函数" tabindex="-1"><a class="header-anchor" href="#a-构造函数" aria-hidden="true">#</a> A）构造函数</h4><p><img src="'+Oa+'" alt="image-20240722153533231"></p><h4 id="b-类" tabindex="-1"><a class="header-anchor" href="#b-类" aria-hidden="true">#</a> B）类</h4><p><img src="'+ya+'" alt="image-20240722153622826"></p><p><img src="'+za+'" alt="image-20240722153649694"></p><h3 id="_6-new创建对象" tabindex="-1"><a class="header-anchor" href="#_6-new创建对象" aria-hidden="true">#</a> 6，new创建对象</h3><p><img src="'+Fa+'" alt="image-20240722153911707"></p><h3 id="_7-全局对象window" tabindex="-1"><a class="header-anchor" href="#_7-全局对象window" aria-hidden="true">#</a> 7，全局对象window</h3><p>浏览器中存在一个全局对象object -&gt; window。</p><ul><li><p>作用一：查找变量时，最终会找到window头上。</p></li><li><p>作用二：将一些浏览器全局提供给我们的变量/函数，放在window对象上面。</p></li><li><p>作用三(了解)：使用var定义的变量会被默认添加到window上。</p></li></ul><p><img src="'+La+'" alt="image-20240722155701724"></p><p>Function本质上也是一个对象，如下：</p><p><img src="'+Pa+'" alt="image-20240722161843676"></p><h2 id="七-js中常见内置类" tabindex="-1"><a class="header-anchor" href="#七-js中常见内置类" aria-hidden="true">#</a> 七，JS中常见内置类</h2><h3 id="_1-认识包装类型" tabindex="-1"><a class="header-anchor" href="#_1-认识包装类型" aria-hidden="true">#</a> 1，认识包装类型</h3><p><img src="'+Ta+'" alt="image-20240722163610852"></p><p><img src="'+Ga+'" alt="image-20240722163640996"></p><p>对于一个基本类型的字符串，我们可以使用.length和方法，但是它并不是一个对象。为什么可以这么做？</p><p><img src="'+Ha+'" alt="image-20240722175638201"></p><h3 id="_2-数字类型number" tabindex="-1"><a class="header-anchor" href="#_2-数字类型number" aria-hidden="true">#</a> 2，数字类型Number</h3><p><img src="'+Ra+'" alt="image-20240722163702985"></p><p>toString()方法可以将数字转换成某个进制，并且以字符串返回。如下：</p><p><img src="'+Ua+'" alt="image-20240722182104481"></p><p>如果我们要对一个数字直接使用toString，该数字和toString方法之间需要两个点。如下：</p><p><img src="'+Wa+'" alt="image-20240722182526035"></p><p>我们还可以使用toFixed()保留一个数字的某几位小数，或使用parseInt()或parseFloat()将某个数字转换成整数或小数。代码如下：</p><p><img src="'+Ka+'" alt="image-20240722183159951"></p><p>parseInt()和Number.parseInt()相等，是同一个方法。那么它们是怎么实现的呢？如下：</p><p><img src="'+Qa+'" alt="image-20240722183544432"></p><p>通过打印，看看是否以类似的方法实现的？如下：</p><p><img src="'+Xa+'" alt="image-20240722183813721"></p><h3 id="_3-数学对象math" tabindex="-1"><a class="header-anchor" href="#_3-数学对象math" aria-hidden="true">#</a> 3，数学对象Math</h3><p><img src="'+Ya+'" alt="image-20240722163729953"></p><p>Math.random()方法随机生成一个[0, 1)之间的数，我们也可以使用这个方法随机生成某个范围之间的数。如下：</p><p><img src="'+Za+'" alt="image-20240722185234978"></p><h2 id="八-字符串方法" tabindex="-1"><a class="header-anchor" href="#八-字符串方法" aria-hidden="true">#</a> 八，字符串方法</h2><h3 id="_1-基本使用" tabindex="-1"><a class="header-anchor" href="#_1-基本使用" aria-hidden="true">#</a> 1，基本使用</h3><p><img src="'+$a+'" alt="image-20240722163754871"></p><h3 id="_2-修改字符串" tabindex="-1"><a class="header-anchor" href="#_2-修改字符串" aria-hidden="true">#</a> 2，修改字符串</h3><p><img src="'+a2+'" alt="image-20240722163823375"></p><h3 id="_3-查找字符串" tabindex="-1"><a class="header-anchor" href="#_3-查找字符串" aria-hidden="true">#</a> 3，查找字符串</h3><h4 id="a-判断是否包含某个字符" tabindex="-1"><a class="header-anchor" href="#a-判断是否包含某个字符" aria-hidden="true">#</a> A）判断是否包含某个字符</h4><p><img src="'+i2+'" alt="image-20240722163854166"></p><p>使用str.indexOf(searchValue, [, fromIndex])，可以判断str中是否包含searchValue字符串，代码和效果如下：</p><p><img src="'+e2+'" alt="image-20240722213530340"></p><p>在ES6中新增了str.includes方法，可以用来判断是否包含某个字符串，它返回的是布尔类型。代码和效果如下：</p><p><img src="'+s2+'" alt="image-20240722213916882"></p><h4 id="b-判断并替换某个字符串" tabindex="-1"><a class="header-anchor" href="#b-判断并替换某个字符串" aria-hidden="true">#</a> B）判断并替换某个字符串</h4><p>通过str.replace()方法，我们可以对某些字符串进行替换，并生成新的字符串。代码和效果如下：</p><p><img src="'+t2+'" alt="image-20240722214559170"></p><p>除此之外，str.replace()方法的第一个参数可以是查找的字符串，还可以是一个正则表达式。</p><p>str.replace()方法的第二个参数可以是一个匿名函数，函数的返回值会作为替代字符串。代码和效果如下：</p><p><img src="'+r2+'" alt="image-20240722223001051"></p><h3 id="_4-开头和结尾" tabindex="-1"><a class="header-anchor" href="#_4-开头和结尾" aria-hidden="true">#</a> 4，开头和结尾</h3><p><img src="'+p2+'" alt="image-20240722163950702"></p><h3 id="_5-截取字符串" tabindex="-1"><a class="header-anchor" href="#_5-截取字符串" aria-hidden="true">#</a> 5，截取字符串</h3><p><img src="'+n2+'" alt="image-20240722164122372"></p><h4 id="a-slice方法" tabindex="-1"><a class="header-anchor" href="#a-slice方法" aria-hidden="true">#</a> A）slice方法</h4><p>使用str.slice()方法，可以截取一个子字符串。代码和效果如下：</p><p><img src="'+g2+'" alt="image-20240722223700674"></p><p>slice方法的参数还可以传入负数，或第二个参数不传。代码和效果如下：</p><p><img src="'+c2+'" alt="image-20240722224322166"></p><h4 id="b-substr方法" tabindex="-1"><a class="header-anchor" href="#b-substr方法" aria-hidden="true">#</a> B）subStr方法</h4><p>subStr方法不推荐使用，因为某些浏览器可能不支持。第一个参数为起始索引，第二个为截取长度。代码和效果如下：</p><p><img src="'+d2+'" alt="image-20240722224752248"></p><h3 id="_6-其他方法" tabindex="-1"><a class="header-anchor" href="#_6-其他方法" aria-hidden="true">#</a> 6，其他方法</h3><p><img src="'+m2+'" alt="image-20240722164149920"></p><p>使用concat方法可以一次拼接多个字符串，代码和效果如下：</p><p><img src="'+h2+'" alt="image-20240722232835235"></p><p>可以使用trim删除字符串的首位空格，但是不能去除中间的空格。代码和效果如下：</p><p><img src="'+o2+'" alt="image-20240722233105626"></p><p>使用split可以将一个字符串变成一个数组，或使用join方法将一个数组拼接成一个字符串。代码和效果如下：</p><p><img src="'+_2+'" alt="image-20240722233745266"></p>',259),ri={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String",target:"_blank",rel:"noopener noreferrer"},pi=e('<h2 id="九-数组方法" tabindex="-1"><a class="header-anchor" href="#九-数组方法" aria-hidden="true">#</a> 九，数组方法</h2><h3 id="_1-创建数组" tabindex="-1"><a class="header-anchor" href="#_1-创建数组" aria-hidden="true">#</a> 1，创建数组</h3><p><img src="'+l2+'" alt="image-20240722164212436"></p><p><img src="'+x2+'" alt="image-20240722164239633"></p><p>有多种方式可以创建数组，代码和效果如下：</p><p><img src="'+b2+'" alt="image-20240722234413725"></p><h3 id="_2-数组基本操作" tabindex="-1"><a class="header-anchor" href="#_2-数组基本操作" aria-hidden="true">#</a> 2，数组基本操作</h3><p><img src="'+f2+'" alt="image-20240722164310986"></p><p>数组的增删改查，代码和效果如下：</p><p><img src="'+j2+'" alt="image-20240722234923381"></p><h3 id="_3-数组添加、删除" tabindex="-1"><a class="header-anchor" href="#_3-数组添加、删除" aria-hidden="true">#</a> 3，数组添加、删除</h3><p><img src="'+u2+'" alt="image-20240722164338753"></p><h3 id="_4-添加、删除-splice方法" tabindex="-1"><a class="header-anchor" href="#_4-添加、删除-splice方法" aria-hidden="true">#</a> 4，添加、删除-splice方法：</h3><p><img src="'+S2+'" alt="image-20240723001140688"></p><p>splice方法非常强大，可以添加、替换、删除数组元素，修改原数组，不返回新数组。</p><h4 id="a-删除元素" tabindex="-1"><a class="header-anchor" href="#a-删除元素" aria-hidden="true">#</a> A）删除元素</h4><p>删除元素：参数一：start从什么位置开始删除，参数二：删除元素的个数。修改原数组，不返回新数组。代码和效果如下：</p><p><img src="'+w2+'" alt="image-20240723002045201"></p><h4 id="b-新增元素" tabindex="-1"><a class="header-anchor" href="#b-新增元素" aria-hidden="true">#</a> B）新增元素</h4><p>参数一：从什么位置开始新增，参数二：0表示不删除，参数三及其以后：新增的元素。代码和效果如下：</p><p><img src="'+v2+'" alt="image-20240723002540597"></p><h4 id="c-替换元素" tabindex="-1"><a class="header-anchor" href="#c-替换元素" aria-hidden="true">#</a> C）替换元素</h4><p>splice可以先删除元素，再向对应位置添加新的元素。代码和效果如下：</p><p><img src="'+B2+'" alt="image-20240723002916988"></p><h3 id="_5-数组截取-slice" tabindex="-1"><a class="header-anchor" href="#_5-数组截取-slice" aria-hidden="true">#</a> 5，数组截取-slice</h3><p><img src="'+J2+'" alt="image-20240723103828577"></p><p>slice方法和splice方法的区别在于，slice方法不会修改原数组，而splice方法会修改原数组。代码和效果如下：</p><p><img src="'+A2+'" alt="image-20240723103745802"></p><h3 id="_6-数组合并-concat" tabindex="-1"><a class="header-anchor" href="#_6-数组合并-concat" aria-hidden="true">#</a> 6，数组合并-concat</h3><p>arr.concat方法：创建一个新数组，其中包含来自于其他数组和其他项的值。代码和效果如下：</p><p><img src="'+N2+'" alt="image-20240723104414208"></p><h3 id="_7-数组转字符串-join" tabindex="-1"><a class="header-anchor" href="#_7-数组转字符串-join" aria-hidden="true">#</a> 7，数组转字符串-join</h3><p>join方法可以将数组每一项以某个字符进行拼接，然会一个拼接后的字符串。代码和效果如下：</p><p><img src="'+D2+'" alt="image-20240723104725508"></p><h3 id="_8-查找元素" tabindex="-1"><a class="header-anchor" href="#_8-查找元素" aria-hidden="true">#</a> 8，查找元素</h3><p><img src="'+C2+'" alt="image-20240723104921878"></p><h4 id="a-indexof" tabindex="-1"><a class="header-anchor" href="#a-indexof" aria-hidden="true">#</a> A）indexOf</h4><p>我们可以使indexOf查找数组中是否存在某个元素，如果找到返回对应的索引，否则返回-1。</p><p>代码和效果如下：</p><p><img src="'+I2+'" alt="image-20240723105653802"></p><h4 id="b-includes" tabindex="-1"><a class="header-anchor" href="#b-includes" aria-hidden="true">#</a> B）includes</h4><p>我们可以使用ES6 includes方法，来判断某一个元素是否在这个数组中，返回值为布尔类型。代码和效果如下：</p><p><img src="'+E2+'" alt="image-20240723121921413"></p><h4 id="c-findindex" tabindex="-1"><a class="header-anchor" href="#c-findindex" aria-hidden="true">#</a> C）findIndex</h4><p>如果数组中直接存储的是对象，我们想找到符合条件的对象的索引，该怎么办？使用findIndex方法。代码和效果如下：</p><p><img src="'+V2+'" alt="image-20240723122334287"></p><h4 id="c-find" tabindex="-1"><a class="header-anchor" href="#c-find" aria-hidden="true">#</a> C）find</h4><p>但是现在有一个问题，如果数组中存储的不是简单类型，而是对象类型，我们应该如何查找满足条件的对象呢？例如：查找某一个id为101的学生对象，我们可以使用ES6新增的find方法，代码和效果如下：</p><p><img src="'+k2+'" alt="image-20240723110842521"></p><p>我们可以自己手写一个find函数，代码和效果如下：</p><p><img src="'+q2+'" alt="image-20240723114450238"></p><p>我们还可以自己实现一个forEach方法，代码和效果如下：</p><h3 id="_9-数组排序—sort" tabindex="-1"><a class="header-anchor" href="#_9-数组排序—sort" aria-hidden="true">#</a> 9，数组排序—sort</h3><p><img src="'+M2+'" alt="image-20240723121527854"></p><p>如果我们想对一个存储数字的数组，进行升序或降序排列，该怎么办呢？使用sort方法，代码和效果如下：</p><p><img src="'+O2+'" alt="image-20240723122707243"></p><p>接下来我们手动实现sort方法，如下：</p><p><img src="'+y2+'" alt="image-20240723165723576"></p><p>如果我们向对一个数组中，按每一元素的年龄，从低到高进行派列，我们可以这样做，代码如下：</p><p><img src="'+z2+'" alt="image-20240723170122932"></p><h3 id="_10-数组反转—reverse" tabindex="-1"><a class="header-anchor" href="#_10-数组反转—reverse" aria-hidden="true">#</a> 10，数组反转—reverse</h3><p>如果我们向对sort之后的数组进行反转，可以使用reverse。代码和效果如下：</p><p><img src="'+F2+'" alt="image-20240723145801090"></p><h2 id="十-date类型的使用" tabindex="-1"><a class="header-anchor" href="#十-date类型的使用" aria-hidden="true">#</a> 十，Date类型的使用</h2><h3 id="_1-时间的表示" tabindex="-1"><a class="header-anchor" href="#_1-时间的表示" aria-hidden="true">#</a> 1，时间的表示</h3><p><img src="'+L2+'" alt="image-20240723170926997"></p><p><img src="'+P2+'" alt="image-20240723172026833"></p><h3 id="_2-创建日期对象" tabindex="-1"><a class="header-anchor" href="#_2-创建日期对象" aria-hidden="true">#</a> 2，创建日期对象</h3><p><img src="'+T2+'" alt="image-20240723170906024"></p><p>我们可以有很多种Date的创建方式，代码如下：</p><p><img src="'+G2+'" alt="image-20240723173003501"></p><h3 id="_3-时间的表示方式" tabindex="-1"><a class="header-anchor" href="#_3-时间的表示方式" aria-hidden="true">#</a> 3，时间的表示方式</h3><p><img src="'+H2+'" alt="image-20240723172255620"></p><p>两个时间格式可以进行转化，代码和效果如下：</p><p><img src="'+R2+'" alt="image-20240723173919668"></p><h3 id="_4-获取date信息的方法" tabindex="-1"><a class="header-anchor" href="#_4-获取date信息的方法" aria-hidden="true">#</a> 4，获取Date信息的方法</h3><p><img src="'+U2+'" alt="image-20240723174026889"></p><p>在开发中，我们往往对以上两种标准时间的格式都不满意，因此我们需要通过一些方法从Date中获取到我们想要的时间信息，来进行自定义格式化时间，代码和效果如下：</p><p><img src="'+W2+'" alt="image-20240723180642535"></p><h3 id="_5-date设置信息的方法" tabindex="-1"><a class="header-anchor" href="#_5-date设置信息的方法" aria-hidden="true">#</a> 5，Date设置信息的方法</h3><p>我们也可以通过一些方法设置Date信息，代码和效果如下：</p><p><img src="'+K2+'" alt="image-20240723181418133"></p><h3 id="_6-date获取unix时间戳" tabindex="-1"><a class="header-anchor" href="#_6-date获取unix时间戳" aria-hidden="true">#</a> 6，Date获取Unix时间戳</h3><p><img src="'+Q2+'" alt="image-20240723181607244"></p><p>我们可以获取当前日期的时间戳，也可以获取一个date对象的时间戳。代码和效果如下：</p><p><img src="'+X2+'" alt="image-20240723182001601"></p><p>我们通过时间戳，还可以获取到一段代码的执行时间。代码和效果如下：</p><p><img src="'+Y2+'" alt="image-20240723184526286"></p><p>利用时间戳，我们可以封装出一个计算某个函数性能的函数，代码如下：</p><p><img src="'+Z2+'" alt="image-20240723184711223"></p><h3 id="_7-date-parse方法" tabindex="-1"><a class="header-anchor" href="#_7-date-parse方法" aria-hidden="true">#</a> 7，Date.parse方法</h3><p><img src="'+$2+'" alt="image-20240723193841754"></p><p>将字符串时间转换成时间戳，有很多种方式。</p><p>方式一：date.getTime()，代码和效果如下：</p><p><img src="'+ai+'" alt="image-20240723194127890"></p><p>方式二：Date.parse()，代码和效果如下：</p><p><img src="'+ii+'" alt="image-20240723195906545"></p><h3 id="_8-时间格式化函数" tabindex="-1"><a class="header-anchor" href="#_8-时间格式化函数" aria-hidden="true">#</a> 8，时间格式化函数</h3><p><img src="'+ei+'" alt="image-20240723200056813"></p>',99);function ni(gi,ci){const s=r("ExternalLinkIcon");return p(),n("div",null,[ti,i("p",null,[a("更多方法查看MDN文档，"),i("a",ri,[a("String - JavaScript | MDN (mozilla.org)"),g(s)]),a("。")]),pi])}const mi=t(si,[["render",ni],["__file","18.html.vue"]]);export{mi as default};
