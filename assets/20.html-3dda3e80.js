import{_ as a,o as i,c as s,a as e}from"./app-382cdfb3.js";const t="/jixiang/assets/image-20240727085431231-18d6f8a9.png",p="/jixiang/assets/image-20240727085451940-c1892423.png",g="/jixiang/assets/image-20240727085513115-40b2de15.png",n="/jixiang/assets/image-20240727085533990-2210b5f2.png",r="/jixiang/assets/image-20240727090230960-78a05c46.png",m="/jixiang/assets/image-20240727090256481-7373b1a2.png",c="/jixiang/assets/image-20240727090328335-ab6f92c9.png",o="/jixiang/assets/image-20240727085555506-b721361f.png",d="/jixiang/assets/image-20240727091808044-7e4c3468.png",_="/jixiang/assets/image-20240727091916112-be4de180.png",l="/jixiang/assets/image-20240727093104557-c24f18de.png",h="/jixiang/assets/image-20240727094954088-98aa2921.png",x="/jixiang/assets/image-20240727102943941-8994b4a1.png",j="/jixiang/assets/image-20240727104132788-7cbaf4cd.png",b="/jixiang/assets/image-20240727122532265-1c9b01d6.png",f="/jixiang/assets/image-20240727124454897-4104c445.png",u="/jixiang/assets/image-20240727124557911-74ce388b.png",S="/jixiang/assets/image-20240727140151971-c40c720e.png",C="/jixiang/assets/image-20240727140642759-e6d5fe72.png",R="/jixiang/assets/image-20240727141040155-09a2c0db.png",v="/jixiang/assets/image-20240727142313872-0280bd85.png",M="/jixiang/assets/image-20240727143212520-ba6e124d.png",A="/jixiang/assets/image-20240727151456116-167a0539.png",B="/jixiang/assets/image-20240727203058127-0c17cb56.png",k="/jixiang/assets/image-20240727203717321-c410f9a0.png",D="/jixiang/assets/image-20240727204051815-a050de34.png",y="/jixiang/assets/image-20240727204253512-a6bbd68a.png",O="/jixiang/assets/image-20240727205309106-ef9048a4.png",J="/jixiang/assets/image-20240727205425106-bcc907ba.png",H="/jixiang/assets/image-20240727205444340-54d3ea85.png",T="/jixiang/assets/image-20240727205633554-2e23346f.png",X="/jixiang/assets/image-20240727210104224-a5749090.png",w="/jixiang/assets/image-20240727210152787-1bfb565c.png",N="/jixiang/assets/image-20240727210356866-a7d9b2bb.png",P="/jixiang/assets/image-20240727210453228-17453676.png",W="/jixiang/assets/image-20240727210648528-c8aeb21d.png",E="/jixiang/assets/image-20240727210908155-d92da1e1.png",U="/jixiang/assets/image-20240727210937179-d015ac2f.png",I="/jixiang/assets/image-20240727213429549-70a064a4.png",V="/jixiang/assets/image-20240727213808635-f0b9410a.png",F="/jixiang/assets/image-20240727214059634-4b3059df.png",L="/jixiang/assets/image-20240727211914863-e0962b8e.png",Y="/jixiang/assets/image-20240727214806309-dd362701.png",G="/jixiang/assets/image-20240727215032341-325d603f.png",q="/jixiang/assets/image-20240727215730369-15c9b7fd.png",z="/jixiang/assets/image-20240727220222565-fa0079f4.png",K="/jixiang/assets/image-20240727220549769-13d36373.png",Q="/jixiang/assets/image-20240727220855160-c9528d53.png",Z="/jixiang/assets/image-20240727221030881-a0ec3a4c.png",$="/jixiang/assets/image-20240727225003089-7f0e12e9.png",aa="/jixiang/assets/image-20240727225959717-70d23903.png",ia="/jixiang/assets/image-20240727231616720-d7cdbcc8.png",sa="/jixiang/assets/image-20240727211942041-dc09535d.png",ea="/jixiang/assets/image-20240727232855793-6c4d6a1b.png",ta="/jixiang/assets/image-20240727233438679-1869904c.png",pa="/jixiang/assets/image-20240727233752417-c88b9e1e.png",ga="/jixiang/assets/image-20240728073808067-bac3c098.png",na="/jixiang/assets/image-20240728074159712-470c6ae0.png",ra="/jixiang/assets/image-20240728080036118-8dddf30e.png",ma="/jixiang/assets/image-20240728080706823-dbacdd17.png",ca="/jixiang/assets/image-20240728082749807-810d3a16.png",oa="/jixiang/assets/image-20240728085249651-1b1a0a22.png",da="/jixiang/assets/image-20240728093946162-2572a24a.png",_a="/jixiang/assets/image-20240728101317037-e134b06f.png",la="/jixiang/assets/image-20240728102131461-554b701c.png",ha="/jixiang/assets/image-20240728103234007-4099f746.png",xa="/jixiang/assets/image-20240728103355822-7f436577.png",ja="/jixiang/assets/image-20240728111719251-a08b2a5c.png",ba="/jixiang/assets/image-20240728112529018-6983d19e.png",fa="/jixiang/assets/image-20240728113028712-bbc7e986.png",ua="/jixiang/assets/image-20240728115138160-4e23bf13.png",Sa="/jixiang/assets/image-20240728115827543-412d4051.png",Ca="/jixiang/assets/image-20240728120642102-9f47a276.png",Ra="/jixiang/assets/image-20240728121034784-bc1da221.png",va="/jixiang/assets/image-20240728121417335-6ce01b42.png",Ma="/jixiang/assets/image-20240728155040181-5863649e.png",Aa="/jixiang/assets/image-20240728160716902-a3a89491.png",Ba="/jixiang/assets/image-20240728161130371-d7bba411.png",ka="/jixiang/assets/image-20240728162043913-19f69a87.png",Da="/jixiang/assets/image-20240728172245532-5c27e309.png",ya="/jixiang/assets/image-20240728172859369-e440abed.png",Oa="/jixiang/assets/image-20240728155116289-177f6039.png",Ja="/jixiang/assets/image-20240728155139348-5a503bf1.png",Ha="/jixiang/assets/image-20240728174424823-e4390433.png",Ta="/jixiang/assets/image-20240728174941955-2ff27d21.png",Xa="/jixiang/assets/image-20240728175433178-5e33fa1f.png",wa="/jixiang/assets/image-20240728175735498-983d211a.png",Na="/jixiang/assets/image-20240728155202943-861e2a39.png",Pa="/jixiang/assets/image-20240728155221989-8f86766a.png",Wa="/jixiang/assets/image-20240728155239078-a4f1bedc.png",Ea="/jixiang/assets/image-20240728185928077-783be0a2.png",Ua="/jixiang/assets/image-20240728192127917-5be27101.png",Ia="/jixiang/assets/image-20240728155305253-c3e94232.png",Va="/jixiang/assets/image-20240728192445266-e775768c.png",Fa="/jixiang/assets/image-20240728194139804-79707051.png",La="/jixiang/assets/image-20240728155327793-bc2ccd06.png",Ya="/jixiang/assets/image-20240728155352716-219f2df8.png",Ga="/jixiang/assets/image-20240728220931892-3849bbdf.png",qa="/jixiang/assets/image-20240728155425754-0c441d7a.png",za="/jixiang/assets/image-20240728155445642-313e875a.png",Ka="/jixiang/assets/image-20240729085720410-2b88f97c.png",Qa="/jixiang/assets/image-20240729090708309-cf3d579c.png",Za="/jixiang/assets/image-20240729105937607-815b3e62.png",$a="/jixiang/assets/image-20240729110514592-f33e1868.png",a2="/jixiang/assets/image-20240729113548630-4fef5335.png",i2="/jixiang/assets/image-20240729113927123-c6780dbe.png",s2="/jixiang/assets/image-20240729115638650-ce7b2ab2.png",e2="/jixiang/assets/image-20240729123756339-efc941b1.png",t2="/jixiang/assets/image-20240729132208098-21de9c8e.png",p2="/jixiang/assets/image-20240729135050305-40ae1b01.png",g2="/jixiang/assets/image-20240729135110234-c4d8ea02.png",n2="/jixiang/assets/image-20240729135136961-e610fd2a.png",r2="/jixiang/assets/image-20240729135157192-047517cb.png",m2="/jixiang/assets/image-20240729140524738-d1850221.png",c2="/jixiang/assets/image-20240729140743534-a2440fb9.png",o2="/jixiang/assets/image-20240729135233888-3a57066f.png",d2="/jixiang/assets/image-20240729143245205-bfd5ff34.png",_2="/jixiang/assets/image-20240729144017407-c67f4c1c.png",l2="/jixiang/assets/image-20240729153911619-c9769fe6.png",h2="/jixiang/assets/image-20240729154937732-29b10754.png",x2="/jixiang/assets/image-20240729135307499-ac372a81.png",j2="/jixiang/assets/image-20240729135250767-80d01814.png",b2="/jixiang/assets/image-20240729211134638-3ebe3879.png",f2="/jixiang/assets/image-20240729203350475-5e7deea7.png",u2="/jixiang/assets/image-20240729211422829-0446d2b2.png",S2="/jixiang/assets/image-20240729211705502-146d0657.png",C2="/jixiang/assets/image-20240729212202025-b2a33288.png",R2="/jixiang/assets/image-20240729212321976-e0c7a7ce.png",v2="/jixiang/assets/image-20240729213012116-80faa69a.png",M2="/jixiang/assets/image-20240729213248708-9ed80f68.png",A2="/jixiang/assets/image-20240729213417156-fd3aa54e.png",B2="/jixiang/assets/image-20240729213916950-ba0c25a1.png",k2="/jixiang/assets/image-20240729214225998-f2887b8a.png",D2="/jixiang/assets/image-20240729214415230-f1cba040.png",y2="/jixiang/assets/image-20240729214945729-fd8ce1be.png",O2="/jixiang/assets/image-20240729215528533-4e3db275.png",J2="/jixiang/assets/image-20240729215555287-0bcfcba0.png",H2="/jixiang/assets/image-20240731215200621-3da494ed.png",T2="/jixiang/assets/image-20240731215222965-852b8212.png",X2="/jixiang/assets/image-20240731215244749-967ddf11.png",w2="/jixiang/assets/image-20240731220146954-bdd74b8a.png",N2="/jixiang/assets/image-20240731221902929-f965096a.png",P2="/jixiang/assets/image-20240731220221981-d8c97c8c.png",W2="/jixiang/assets/image-20240731223347121-47013505.png",E2="/jixiang/assets/image-20240731222457076-634231ca.png",U2="/jixiang/assets/image-20240731223615026-65baee8a.png",I2="/jixiang/assets/image-20240731225236112-3c082a7e.png",V2="/jixiang/assets/image-20240731225722988-3e01045a.png",F2="/jixiang/assets/image-20240731230054189-1c71a1ce.png",L2="/jixiang/assets/image-20240731230219934-cbefa63d.png",Y2="/jixiang/assets/image-20240731220239754-d5716e19.png",G2="/jixiang/assets/image-20240731230843472-d8986713.png",q2="/jixiang/assets/image-20240731231310317-a9bf7727.png",z2="/jixiang/assets/image-20240731231453562-cb6d1a7a.png",K2="/jixiang/assets/image-20240731231519474-286e9e9c.png",Q2="/jixiang/assets/image-20240731231535846-5d102f1d.png",Z2="/jixiang/assets/image-20240731231812892-148306a3.png",$2="/jixiang/assets/image-20240731233928323-f3635e47.png",ai="/jixiang/assets/image-20240731234027342-e9633398.png",ii="/jixiang/assets/image-20240731234947123-0f11d07a.png",si="/jixiang/assets/image-20240731235046382-bce1361b.png",ei="/jixiang/assets/image-20240731235255711-b9680ca3.png",ti="/jixiang/assets/image-20240731235814688-421c1db2.png",pi="/jixiang/assets/image-20240801073253177-0c500654.png",gi="/jixiang/assets/image-20240801074506796-e7aa59e6.png",ni="/jixiang/assets/image-20240801074832093-bf4c574d.png",ri="/jixiang/assets/image-20240801085902700-4b29e35a.png",mi="/jixiang/assets/image-20240801090348129-8e0b3b78.png",ci="/jixiang/assets/image-20240801091714203-e0cdf772.png",oi="/jixiang/assets/image-20240801092021768-6e2da989.png",di="/jixiang/assets/image-20240801093905351-43aab200.png",_i="/jixiang/assets/image-20240801094010449-806f69ee.png",li="/jixiang/assets/image-20240801094251188-8ab353fa.png",hi="/jixiang/assets/image-20240801092050781-b1caadb5.png",xi="/jixiang/assets/image-20240801092116810-534e08f4.png",ji="/jixiang/assets/image-20240801124033825-4e76af9d.png",bi="/jixiang/assets/image-20240801124350540-a1cf8ae9.png",fi="/jixiang/assets/image-20240801125126196-4ff3db7f.png",ui="/jixiang/assets/image-20240801125522218-57f348b0.png",Si="/jixiang/assets/image-20240801130115272-231d662d.png",Ci="/jixiang/assets/image-20240801130938088-b1644385.png",Ri="/jixiang/assets/image-20240801131246105-6b246ace.png",vi="/jixiang/assets/image-20240801132556673-96853201.png",Mi="/jixiang/assets/image-20240801132811475-f8056b8a.png",Ai="/jixiang/assets/image-20240801132906340-09b29434.png",Bi="/jixiang/assets/image-20240801133214070-530d2e96.png",ki="/jixiang/assets/image-20240801135443146-736f028d.png",Di="/jixiang/assets/image-20240801140022558-e4a5b635.png",yi="/jixiang/assets/image-20240801141534268-e4c95e22.png",Oi="/jixiang/assets/image-20240801142003525-8bc20f40.png",Ji="/jixiang/assets/image-20240801142242700-8eed6e12.png",Hi="/jixiang/assets/image-20240801142539994-95a3da6f.png",Ti="/jixiang/assets/image-20240801142716829-967929a9.png",Xi="/jixiang/assets/image-20240801142952338-e0b7379d.png",wi="/jixiang/assets/image-20240801180909370-e9ebb242.png",Ni="/jixiang/assets/image-20240801182525155-36072755.png",Pi="/jixiang/assets/image-20240801183009811-3733e7d7.png",Wi="/jixiang/assets/image-20240801183221223-edec7765.png",Ei="/jixiang/assets/image-20240801185535867-b784df7d.png",Ui="/jixiang/assets/image-20240801190157029-4c921e13.png",Ii="/jixiang/assets/image-20240801215818023-895e8aca.png",Vi="/jixiang/assets/image-20240801191104898-45891a06.png",Fi="/jixiang/assets/image-20240801191335238-93b2ea89.png",Li="/jixiang/assets/image-20240801191709596-2e1d0633.png",Yi="/jixiang/assets/image-20240801192034999-757819cc.png",Gi="/jixiang/assets/image-20240801192908122-bfb7b4cd.png",qi="/jixiang/assets/image-20240801210731112-ac22b03f.png",zi="/jixiang/assets/image-20240801211034076-a93633b8.png",Ki="/jixiang/assets/image-20240801211425143-4501c30e.png",Qi="/jixiang/assets/image-20240801215226646-818e2357.png",Zi="/jixiang/assets/image-20240801215706091-23bdad1c.png",$i="/jixiang/assets/image-20240801220120837-2940b591.png",a0="/jixiang/assets/image-20240801220144466-2454d114.png",i0="/jixiang/assets/image-20240801222326138-394fd79e.png",s0="/jixiang/assets/image-20240801222003100-ac0bea45.png",e0="/jixiang/assets/image-20240801222235587-3722c2fb.png",t0="/jixiang/assets/image-20240801222802956-ee9b9ea7.png",p0="/jixiang/assets/image-20240801222910403-fe20b69b.png",g0="/jixiang/assets/image-20240801224030464-21143eb0.png",n0="/jixiang/assets/image-20240801224713730-77d593c9.png",r0="/jixiang/assets/image-20240801224837830-a1a89ccd.png",m0="/jixiang/assets/image-20240801230337033-4c910f82.png",c0="/jixiang/assets/image-20240801230512343-c8ad38a6.png",o0="/jixiang/assets/image-20240801233343674-1f674019.png",d0="/jixiang/assets/image-20240801234011804-5d586461.png",_0="/jixiang/assets/image-20240801234438086-f84076ff.png",l0="/jixiang/assets/image-20240801235639839-1aab7394.png",h0="/jixiang/assets/image-20240802080718639-8dff85b2.png",x0="/jixiang/assets/image-20240802080804273-93d5091a.png",j0="/jixiang/assets/image-20240802080830049-fd4d234a.png",b0="/jixiang/assets/image-20240802083257702-b16e5df1.png",f0="/jixiang/assets/image-20240802084826693-bfb14348.png",u0="/jixiang/assets/image-20240802085350452-44e4ed53.png",S0="/jixiang/assets/image-20240802085908112-6503bec0.png",C0="/jixiang/assets/image-20240802090321547-34f82fd4.png",R0="/jixiang/assets/image-20240802101915476-a74ca683.png",v0="/jixiang/assets/image-20240802102813097-efd59266.png",M0="/jixiang/assets/image-20240802102941598-aca0fd3f.png",A0="/jixiang/assets/image-20240802080858492-fdeaf067.png",B0="/jixiang/assets/image-20240802101525370-b21cba75.png",k0="/jixiang/assets/image-20240802104246875-a0f6c9d2.png",D0="/jixiang/assets/image-20240802104514371-d0ed5291.png",y0="/jixiang/assets/image-20240802104902165-d4a318a4.png",O0="/jixiang/assets/image-20240802112133588-3d6c2dde.png",J0="/jixiang/assets/image-20240802112159179-b7224ffe.png",H0="/jixiang/assets/image-20240802112852225-5c63b7a9.png",T0="/jixiang/assets/image-20240802113208500-997d511b.png",X0="/jixiang/assets/image-20240802121749985-ca62d716.png",w0="/jixiang/assets/image-20240802123255792-bcd053ea.png",N0="/jixiang/assets/image-20240802123621499-4ea3f496.png",P0="/jixiang/assets/image-20240802124312271-22706a64.png",W0="/jixiang/assets/image-20240802125119791-8ad0c409.png",E0="/jixiang/assets/image-20240802125335695-e52db299.png",U0="/jixiang/assets/image-20240802183119546-6f87984b.png",I0="/jixiang/assets/Vue和React数据管理和渲染流程对比-1722595184443-f9faa125.png",V0="/jixiang/assets/image-20240802190441123-d1e2458c.png",F0="/jixiang/assets/image-20240802191002161-670b133b.png",L0="/jixiang/assets/image-20240802191955021-e495c426.png",Y0="/jixiang/assets/image-20240802201205757-84b764f5.png",G0="/jixiang/assets/image-20240802194113143-83107feb.png",q0="/jixiang/assets/image-20240802194848755-0a6adfac.png",z0="/jixiang/assets/image-20240802201313815-424f91f2.png",K0="/jixiang/assets/image-20240802201335577-ddbe7311.png",Q0="/jixiang/assets/image-20240802214543778-a28d4293.png",Z0="/jixiang/assets/image-20240802220925381-80aaccb1.png",$0="/jixiang/assets/image-20240802201411114-dfaa6ce1.png",as="/jixiang/assets/image-20240804152224506-cfbe17b8.png",is="/jixiang/assets/image-20240804152339304-91790e51.png",ss="/jixiang/assets/image-20240804153821227-b983b76b.png",es="/jixiang/assets/image-20240804155056156-1986ce8c.png",ts="/jixiang/assets/image-20240804155949351-b9d8c238.png",ps="/jixiang/assets/image-20240804160107091-e4f936cf.png",gs="/jixiang/assets/image-20240804160440063-697a722e.png",ns="/jixiang/assets/image-20240804162343888-d59b9dd2.png",rs="/jixiang/assets/image-20240804163325280-01036044.png",ms="/jixiang/assets/image-20240804163442404-866f1678.png",cs="/jixiang/assets/image-20240804163905787-7f9381ce.png",os="/jixiang/assets/image-20240804164525219-0de2e33d.png",ds="/jixiang/assets/image-20240805091827402-d10ddc13.png",_s="/jixiang/assets/image-20240804184940325-4e1c1e80.png",ls="/jixiang/assets/image-20240804185705159-ad3d67d6.png",hs="/jixiang/assets/image-20240805001558713-23380119.png",xs="/jixiang/assets/image-20240805003752355-3fa54969.png",js="/jixiang/assets/image-20240805004611983-094c3e43.png",bs="/jixiang/assets/image-20240805090802415-7d8238ac.png",fs="/jixiang/assets/image-20240805091709267-37244a78.png",us="/jixiang/assets/image-20240805091933309-42caab2d.png",Ss="/jixiang/assets/image-20240805093131351-940d4aac.png",Cs="/jixiang/assets/image-20240805094039197-f4ad7f1c.png",Rs="/jixiang/assets/image-20240805094621228-7e39e644.png",vs="/jixiang/assets/image-20240805095305181-35399bec.png",Ms="/jixiang/assets/image-20240805092013978-d2e52985.png",As="/jixiang/assets/image-20240805101215050-7517ede2.png",Bs="/jixiang/assets/image-20240805110929852-817c7da1.png",ks="/jixiang/assets/image-20240805110721653-a62f64d5.png",Ds="/jixiang/assets/image-20240805111729521-31d4c059.png",ys="/jixiang/assets/image-20240805092054012-6715002a.png",Os="/jixiang/assets/image-20240805112930078-42b3e500.png",Js="/jixiang/assets/image-20240805114003238-bb4b0674.png",Hs="/jixiang/assets/image-20240805114640532-de825313.png",Ts="/jixiang/assets/image-20240926233653117-4ccf4f40.png",Xs="/jixiang/assets/image-20240926233724253-1f9d514c.png",ws="/jixiang/assets/image-20240927000133871-746b323f.png",Ns="/jixiang/assets/image-20240927072541917-d48aef80.png",Ps="/jixiang/assets/image-20240927080654788-65c243f2.png",Ws="/jixiang/assets/image-20240927081029668-40978826.png",Es="/jixiang/assets/image-20240927081919471-55530148.png",Us="/jixiang/assets/image-20240927082102825-0046d5dd.png",Is="/jixiang/assets/image-20240929230757562-b773bfa0.png",Vs="/jixiang/assets/image-20240929230947746-a245857e.png",Fs="/jixiang/assets/image-20240929231018994-b24e2fba.png",Ls="/jixiang/assets/image-20240929233711660-e02f737c.png",Ys="/jixiang/assets/image-20240929233948647-b68fa2b1.png",Gs="/jixiang/assets/image-20240930000010753-df3c400e.png",qs="/jixiang/assets/image-20240930000027589-8519f40d.png",zs="/jixiang/assets/image-20240929231402478-90b50340.png",Ks="/jixiang/assets/image-20240930001139434-879ca851.png",Qs="/jixiang/assets/image-20240930003534210-83d0d7ec.png",Zs="/jixiang/assets/image-20240930074902337-8b208093.png",$s="/jixiang/assets/image-20240930075145718-25f8c551.png",ae="/jixiang/assets/image-20240930075339991-c78e06f4.png",ie="/jixiang/assets/image-20240930080839828-88542300.png",se="/jixiang/assets/image-20240930081557266-ddb76ecf.png",ee="/jixiang/assets/image-20240930081805732-85a4dee2.png",te="/jixiang/assets/image-20240930082634270-a150e685.png",pe="/jixiang/assets/image-20240930082811327-b4b27173.png",ge="/jixiang/assets/image-20240930110718051-241faff6.png",ne="/jixiang/assets/image-20240930112314593-3bc246ef.png",re="/jixiang/assets/image-20240930112806858-dcc6b9c2.png",me="/jixiang/assets/image-20240930112926128-92aec748.png",ce="/jixiang/assets/image-20240930113457730-d64b09ee.png",oe="/jixiang/assets/image-20240930115045193-cebef905.png",de="/jixiang/assets/image-20240930115136818-f157c931.png",_e="/jixiang/assets/image-20240930115237791-02687eeb.png",le="/jixiang/assets/image-20240930115402391-53b113c9.png",he="/jixiang/assets/image-20240930120146908-6c088440.png",xe="/jixiang/assets/image-20240930120622925-ad2af288.png",je="/jixiang/assets/image-20240930121120020-2e0710db.png",be="/jixiang/assets/image-20240930122001156-a6c2c774.png",fe="/jixiang/assets/image-20240930122131007-4f1dcbb5.png",ue="/jixiang/assets/image-20240930122934984-8968740f.png",Se="/jixiang/assets/image-20240930123812037-0202beca.png",Ce="/jixiang/assets/image-20240930124349421-026b0115.png",Re="/jixiang/assets/image-20240930124523030-d46501e2.png",ve="/jixiang/assets/image-20240930124943535-cfd22c1d.png",Me="/jixiang/assets/image-20240930125406730-5c8566b3.png",Ae="/jixiang/assets/image-20240930135311739-0fc2b430.png",Be="/jixiang/assets/image-20240930135627417-9ac89f4e.png",ke="/jixiang/assets/image-20240930144054891-21ce224b.png",De="/jixiang/assets/image-20240930144721231-0b44f0ea.png",ye="/jixiang/assets/image-20240930145702523-e6f820c4.png",Oe="/jixiang/assets/image-20240930144116663-bb249e7f.png",Je="/jixiang/assets/image-20240930144149304-0481c130.png",He="/jixiang/assets/image-20240930155428394-6fc4ae26.png",Te="/jixiang/assets/image-20240930155732119-e57e573e.png",Xe="/jixiang/assets/image-20240930160415538-9506258a.png",we="/jixiang/assets/image-20240930160640025-dd66d0b8.png",Ne="/jixiang/assets/image-20240930161939728-6449a5d1.png",Pe="/jixiang/assets/image-20240930163410114-890fcaeb.png",We="/jixiang/assets/image-20240930163714871-0b12c028.png",Ee="/jixiang/assets/image-20240930160737205-f22b79ee.png",Ue="/jixiang/assets/image-20240930164737546-7e8e7225.png",Ie="/jixiang/assets/image-20240930163815898-c35a8a2e.png",Ve="/jixiang/assets/image-20240930220941039-661129e7.png",Fe="/jixiang/assets/image-20240930222904589-697e1197.png",Le="/jixiang/assets/image-20240930223429369-e57a87f3.png",Ye="/jixiang/assets/image-20240930223649884-5a50c1da.png",Ge="/jixiang/assets/image-20240930163845890-a20af9de.png",qe="/jixiang/assets/image-20240930225643748-edd66330.png",ze="/jixiang/assets/image-20240930230241831-e169f73d.png",Ke="/jixiang/assets/image-20240930230626594-799e1bc5.png",Qe="/jixiang/assets/image-20240930231452733-0678e9f4.png",Ze="/jixiang/assets/image-20240930231611085-206b1822.png",$e="/jixiang/assets/image-20240930233507018-a1e5326e.png",at="/jixiang/assets/image-20240930233840751-3eeab2e6.png",it="/jixiang/assets/image-20240930234021312-01e72dd3.png",st="/jixiang/assets/image-20241001155557563-8c08502f.png",et="/jixiang/assets/image-20241001155630874-ee0b6826.png",tt="/jixiang/assets/image-20241001164458728-01829ad7.png",pt="/jixiang/assets/image-20241001175244456-51764aee.png",gt="/jixiang/assets/image-20241001175319859-635ad4a1.png",nt="/jixiang/assets/image-20241001180351914-c8dacac9.png",rt="/jixiang/assets/image-20241001181545577-05a627da.png",mt="/jixiang/assets/image-20241001224415613-a5a6ee5c.png",ct="/jixiang/assets/image-20241001224548670-6ce12445.png",ot="/jixiang/assets/image-20241001225323869-36622584.png",dt="/jixiang/assets/image-20241001233249747-70344fc8.png",_t="/jixiang/assets/image-20241001233431381-1f53e8f5.png",lt="/jixiang/assets/image-20241001233600981-31f0cad6.png",ht="/jixiang/assets/image-20241001233633355-9ebd8cb3.png",xt="/jixiang/assets/image-20241001181607134-883902f7.png",jt="/jixiang/assets/image-20241001235437860-0c5267e4.png",bt="/jixiang/assets/image-20241002075039608-9df8bd83.png",ft="/jixiang/assets/image-20241001235953833-e1c1ac5f.png",ut="/jixiang/assets/image-20241002000802607-a0af1eab.png",St="/jixiang/assets/image-20241002002926331-0c411c03.png",Ct="/jixiang/assets/image-20241002003139831-84a146ac.png",Rt="/jixiang/assets/image-20241002104429767-04482380.png",vt="/jixiang/assets/image-20241002104459992-cbfa3aa8.png",Mt="/jixiang/assets/image-20241002092002146-4c5a7388.png",At="/jixiang/assets/image-20241002113131609-fe60c279.png",Bt="/jixiang/assets/image-20241002113228287-d8e21257.png",kt="/jixiang/assets/image-20241002114506790-12a685fb.png",Dt="/jixiang/assets/image-20241002115642648-c7174082.png",yt="/jixiang/assets/image-20241002115904812-8cbbe355.png",Ot="/jixiang/assets/image-20241002155528409-01441564.png",Jt="/jixiang/assets/image-20241002160109385-59b6c0df.png",Ht="/jixiang/assets/image-20241002132148101-b0a347fa.png",Tt="/jixiang/assets/image-20241002132429644-e1c28a0f.png",Xt="/jixiang/assets/image-20241002130951211-fda49bf6.png",wt="/jixiang/assets/image-20241002151102643-db8b607a.png",Nt="/jixiang/assets/image-20241002151537147-6acfc1fe.png",Pt="/jixiang/assets/image-20241002151818667-7f744256.png",Wt="/jixiang/assets/image-20241002161049690-22b28056.png",Et="/jixiang/assets/image-20241002161322104-42eb1457.png",Ut="/jixiang/assets/image-20241002161407248-2c4bcb29.png",It="/jixiang/assets/image-20241002161434505-7ab850dd.png",Vt="/jixiang/assets/image-20241002162316502-8358902c.png",Ft="/jixiang/assets/image-20241002162643492-b1379be1.png",Lt="/jixiang/assets/image-20241002163224632-4710dc84.png",Yt="/jixiang/assets/image-20241002163824546-5d5abeed.png",Gt="/jixiang/assets/image-20241002171842701-864c4cc9.png",qt="/jixiang/assets/image-20240805201809118-512872ae.png",zt="/jixiang/assets/image-20240805201844036-53ba0a46.png",Kt="/jixiang/assets/image-20240805201902265-f246db05.png",Qt="/jixiang/assets/image-20240805201925411-090df6ae.png",Zt={},$t=e('<h2 id="一-邂逅react开发" tabindex="-1"><a class="header-anchor" href="#一-邂逅react开发" aria-hidden="true">#</a> 一，邂逅React开发</h2><h3 id="_1-react的介绍和特点" tabindex="-1"><a class="header-anchor" href="#_1-react的介绍和特点" aria-hidden="true">#</a> 1，React的介绍和特点</h3><p><img src="'+t+'" alt="image-20240727085431231"></p><p><img src="'+p+'" alt="image-20240727085451940"></p><p><img src="'+g+'" alt="image-20240727085513115"></p><p><img src="'+n+'" alt="image-20240727085533990"></p><h3 id="_2-react开发依赖分析" tabindex="-1"><a class="header-anchor" href="#_2-react开发依赖分析" aria-hidden="true">#</a> 2，React开发依赖分析</h3><p><img src="'+r+'" alt="image-20240727090230960"></p><p><img src="'+m+'" alt="image-20240727090256481"></p><p><img src="'+c+'" alt="image-20240727090328335"></p><h3 id="_3-hello-react案例" tabindex="-1"><a class="header-anchor" href="#_3-hello-react案例" aria-hidden="true">#</a> 3，Hello React案例</h3><p><img src="'+o+'" alt="image-20240727085555506"></p><p><img src="'+d+'" alt="image-20240727091808044"></p><p>第一步：以CDN的方式，引入三个依赖。代码如下：</p><p><img src="'+_+'" alt="image-20240727091916112"></p><p>第二步：在界面上展示Hello World，代码如下：</p><p><img src="'+l+'" alt="image-20240727093104557"></p><p>第三步：绑定状态和button点击事件，点击按钮页面内容发生变化。代码如下：</p><p><img src="'+h+'" alt="image-20240727094954088"></p><h3 id="_4-react组件化的封装" tabindex="-1"><a class="header-anchor" href="#_4-react组件化的封装" aria-hidden="true">#</a> 4，React组件化的封装</h3><p><img src="'+x+'" alt="image-20240727102943941"></p><p>以组件化方式对Hello World案例进行重构，并使用类组件。代码如下：</p><p><img src="'+j+'" alt="image-20240727104132788"></p><h3 id="_5-react数据事件处理" tabindex="-1"><a class="header-anchor" href="#_5-react数据事件处理" aria-hidden="true">#</a> 5，React数据事件处理</h3><h4 id="a-组件化-数据依赖" tabindex="-1"><a class="header-anchor" href="#a-组件化-数据依赖" aria-hidden="true">#</a> A）组件化-数据依赖</h4><p><img src="'+b+'" alt="image-20240727122532265"></p><p>参与界面更新的数据：参与数据流，定义在当前对象的state中。</p><ul><li>我们可以通过在构造函数中this.state = {定义的数据}</li><li>当数据发生变化时，我们可以调用this.setState来更新数据，并且通知React进行update操作。在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面。</li></ul><p>参数数据流需要定义在当前对象的state中，在render函数中使用要以this.state开头。代码如下：</p><p><img src="'+f+'" alt="image-20240727124454897"></p><h4 id="b-组件化-事件绑定" tabindex="-1"><a class="header-anchor" href="#b-组件化-事件绑定" aria-hidden="true">#</a> B）组件化-事件绑定</h4><p><img src="'+u+'" alt="image-20240727124557911"></p><p>先将事件处理函数绑定到button上，代码和效果如下：</p><p><img src="'+S+'" alt="image-20240727140151971"></p><p>那么组件事件处理函数中的this到底指向谁？先来看两段代码，ES6的类中，默认开启了严格模式，因此实例方法通过默认绑定，this指向undefined。代码如下：</p><p><img src="'+C+'" alt="image-20240727140642759"></p><p>普通函数默认调用，this也指向undefined。因为会经过babel转化，babel会默认开启严格模式。代码和效果如下：</p><p><img src="'+R+'" alt="image-20240727141040155"></p><p>组件中的方法，this默认绑定为undefined。因此当我们使用this.setState方法修改状态时，会报错。</p><p>所以我们需要使用bind方法，将render函数中的this(指向当前组件实例)绑定到btnClick函数中。代码和效果如下：</p><p><img src="'+v+'" alt="image-20240727142313872"></p><p>此时我们就可以使用this.setState函数，来修改组件中的状态了。代码和效果如下：</p><p><img src="'+M+'" alt="image-20240727143212520"></p><p>如果有多个按钮，点击后触发同一个事件处理函数。那么我们每个按钮都需要使用bind函数绑定this，这样很麻烦，我们可以在constructor中的提前绑定好this。代码如下：</p><p><img src="'+A+'" alt="image-20240727151456116"></p><h3 id="_6-react其他案例实现" tabindex="-1"><a class="header-anchor" href="#_6-react其他案例实现" aria-hidden="true">#</a> 6，React其他案例实现</h3><h4 id="a-电影列表展示" tabindex="-1"><a class="header-anchor" href="#a-电影列表展示" aria-hidden="true">#</a> A）电影列表展示</h4><p><img src="'+B+'" alt="image-20240727203058127"></p><p>渲染电影列表</p><p>方式一：使用for循环渲染电影列表，代码和效果如下：</p><p><img src="'+k+'" alt="image-20240727203717321"></p><p>方式二：使用map函数进行渲染，代码和效果如下：</p><p><img src="'+D+'" alt="image-20240727204051815"></p><h4 id="b-计数器案例" tabindex="-1"><a class="header-anchor" href="#b-计数器案例" aria-hidden="true">#</a> B）计数器案例</h4><p><img src="'+y+'" alt="image-20240727204253512"></p><p><img src="'+O+'" alt="image-20240727205309106"></p><h3 id="_7-生成demo模板" tabindex="-1"><a class="header-anchor" href="#_7-生成demo模板" aria-hidden="true">#</a> 7，生成demo模板</h3><p><img src="'+J+'" alt="image-20240727205425106"></p><p><img src="'+H+'" alt="image-20240727205444340"></p><p>生成demo模板，操作如下：</p><p>步骤一：准备对应的代码，如下：</p><p><img src="'+T+'" alt="image-20240727205633554"></p><p>步骤二：放入到代码片段生成网站中，操作如下：</p><p><img src="'+X+'" alt="image-20240727210104224"></p><p><img src="'+w+'" alt="image-20240727210152787"></p><p>步骤三：在VsCode中，找到对应的配置文件。操作如下：</p><p><img src="'+N+'" alt="image-20240727210356866"></p><p><img src="'+P+'" alt="image-20240727210453228"></p><p><img src="'+W+'" alt="image-20240727210648528"></p><h2 id="二-jsx语法" tabindex="-1"><a class="header-anchor" href="#二-jsx语法" aria-hidden="true">#</a> 二，JSX语法</h2><h3 id="_1-认识jsx语法" tabindex="-1"><a class="header-anchor" href="#_1-认识jsx语法" aria-hidden="true">#</a> 1，认识JSX语法</h3><p><img src="'+E+'" alt="image-20240727210908155"></p><p><img src="'+U+'" alt="image-20240727210937179"></p><p>在JS中，把一段html结构赋值给一个变量是错误的语法。</p><p>JSX的属性规范如下：</p><p>规范一：JSX中，只能有一个根元素，代码如下：</p><p><img src="'+I+'" alt="image-20240727213429549"></p><p>规范二：jsx结构通常会包裹一个()，将整个jsx当作一个整体，实现换行。代码如下：</p><p><img src="'+V+'" alt="image-20240727213808635"></p><p>规范三：JSX标签可以是单标签，也可以是双标签。代码如下：</p><p><img src="'+F+'" alt="image-20240727214059634"></p><h3 id="_2-jsx的内容绑定" tabindex="-1"><a class="header-anchor" href="#_2-jsx的内容绑定" aria-hidden="true">#</a> 2，JSX的内容绑定</h3><p><img src="'+L+'" alt="image-20240727211914863"></p><h4 id="a-jsx中的注释" tabindex="-1"><a class="header-anchor" href="#a-jsx中的注释" aria-hidden="true">#</a> A）JSX中的注释</h4><p>在JSX结构中，编写注释。格式为: {/* */}，代码如下：</p><p><img src="'+Y+'" alt="image-20240727214806309"></p><p>在.jsx的文件中，编写注释非常方便，ctrl+/ 就可以直接生成注释结构。操作如下：</p><p><img src="'+G+'" alt="image-20240727215032341"></p><h4 id="b-嵌入变量作为子元素" tabindex="-1"><a class="header-anchor" href="#b-嵌入变量作为子元素" aria-hidden="true">#</a> B）嵌入变量作为子元素</h4><p>情况一：当变量是Number、String、Array类型时，可以直接显示。代码和效果如下：</p><p><img src="'+q+'" alt="image-20240727215730369"></p><p>情况二：当变量是null、undefined、Boolean类型时，内容为空；</p><p><img src="'+z+'" alt="image-20240727220222565"></p><p>注意：如果我们就希望显示undefined、null、boolean，该怎么办？先将其转换成字符串，再进行展示。代码和效果如下：</p><p><img src="'+K+'" alt="image-20240727220549769"></p><p>情况三：Object对象类型不能作为子元素（not valid as a React child）。代码和效果如下：</p><p><img src="'+Q+'" alt="image-20240727220855160"></p><p>一般情况，我们是想获取对象中的key或值，代码如下：</p><p><img src="'+Z+'" alt="image-20240727221030881"></p><h4 id="c-jsx嵌入表达式" tabindex="-1"><a class="header-anchor" href="#c-jsx嵌入表达式" aria-hidden="true">#</a> C）JSX嵌入表达式</h4><p>在大括号中，可以插入对应的表达式。</p><p>情况一：运算表达式，代码如下：</p><p><img src="'+$+'" alt="image-20240727225003089"></p><p>情况二：三元运算符，代码如下：</p><p><img src="'+aa+'" alt="image-20240727225959717"></p><p>情况三：执行一个函数，操作如下：</p><p><img src="'+ia+'" alt="image-20240727231616720"></p><h3 id="_3-jsx属性绑定" tabindex="-1"><a class="header-anchor" href="#_3-jsx属性绑定" aria-hidden="true">#</a> 3，JSX属性绑定</h3><h4 id="a-基本属性绑定" tabindex="-1"><a class="header-anchor" href="#a-基本属性绑定" aria-hidden="true">#</a> A）基本属性绑定</h4><p><img src="'+sa+'" alt="image-20240727211942041"></p><p>绑定公共属性title，代码和效果如下：</p><p><img src="'+ea+'" alt="image-20240727232855793"></p><p>绑定img元素的url属性，代码和效果如下：</p><p><img src="'+ta+'" alt="image-20240727233438679"></p><p>绑定a元素的href属性，代码和操作如下：</p><p><img src="'+pa+'" alt="image-20240727233752417"></p><h4 id="b-动态绑定class" tabindex="-1"><a class="header-anchor" href="#b-动态绑定class" aria-hidden="true">#</a> B）动态绑定class</h4><p>在JSX中，在标签上使用class属性，控制台会有警告。代码和效果如下：</p><p><img src="'+ga+'" alt="image-20240728073808067"></p><p>因此，我们要将class属性替换为className，因为jsx本质是js代码，class是一个关键字。代码和操作如下：</p><p><img src="'+na+'" alt="image-20240728074159712"></p><p>需求：如果状态isActive为true，那么h2的className属性多一个active类名，否则就不添加。</p><p>方式一：三元运算符，代码和效果如下：</p><p><img src="'+ra+'" alt="image-20240728080036118"></p><p>方式二：数组，代码和效果如下：</p><p><img src="'+ma+'" alt="image-20240728080706823"></p><p>class绑定的写法三：第三方库classNames -&gt; npm install classNames。</p><h4 id="c-动态绑定style" tabindex="-1"><a class="header-anchor" href="#c-动态绑定style" aria-hidden="true">#</a> C）动态绑定style</h4><p>JSX中，只能动态绑定syle，也就是说，style不能绑定一个字符串，只能是一个对象。否则会报错。代码和效果如下：</p><p><img src="'+ca+'" alt="image-20240728082749807"></p><h3 id="_4-jsx的事件绑定" tabindex="-1"><a class="header-anchor" href="#_4-jsx的事件绑定" aria-hidden="true">#</a> 4，JSX的事件绑定</h3><p><img src="'+oa+'" alt="image-20240728085249651"></p><h4 id="a-事件绑定" tabindex="-1"><a class="header-anchor" href="#a-事件绑定" aria-hidden="true">#</a> A）事件绑定</h4><p>我们绑定了事件处理函数，当函数触发。需要通过this.setState来修改状态。但是组件中的方法中，this指向undefined。代码和效果如下：</p><p><img src="'+da+'" alt="image-20240728093946162"></p><p>所以，当我们调用setState就会报错，因为此时事件处理函数中的this指向undefined。我们需要改变this指向。</p><p>方式一：在constructor函数中，使用bind方法绑定this为当前组件实例对象。代码和效果如下：</p><p><img src="'+_a+'" alt="image-20240728101317037"></p><p>方式二：使用ES6 fields，代码如下：</p><p><img src="'+la+'" alt="image-20240728102131461"></p><p>方式三：直接传入一个箭头函数，开发中用的最多。代码和效果如下：</p><p><img src="'+ha+'" alt="image-20240728103234007"></p><h4 id="b-事件参数传递" tabindex="-1"><a class="header-anchor" href="#b-事件参数传递" aria-hidden="true">#</a> B）事件参数传递</h4><p><img src="'+xa+'" alt="image-20240728103355822"></p><p>我们有时候可能想要获取到事件对象event，我们可以在事件处理函数中，通过形参接收。代码和效果如下：</p><p><img src="'+ja+'" alt="image-20240728111719251"></p><p>在获取事件对象的同时，我们还需要接收一些额外参数，应该怎么做？代码和效果如下：</p><p><img src="'+ba+'" alt="image-20240728112529018"></p><p>需求：展示电影列表，默认第一项选中，点哪一项，哪一项高亮。代码和效果如下：</p><p>第一步：渲染电影列表基本结构，代码和效果如下：</p><p><img src="'+fa+'" alt="image-20240728113028712"></p><p>第二步：实现点击哪一项，哪一项就高亮。代码和效果如下：</p><p><img src="'+ua+'" alt="image-20240728115138160"></p><p>对上面的案例代码进行重构。</p><p>重构方式一：将ul中的渲染内容，抽离出去。代码和效果如下：</p><p><img src="'+Sa+'" alt="image-20240728115827543"></p><p>重构方式二：只是将map传入的函数，进行抽离。但是代码会报错，原因是因为抽离出去的函数，中的this指向window。代码和效果如下：</p><p><img src="'+Ca+'" alt="image-20240728120642102"></p><p>解决方式一：map函数第一个参数接收一个函数，还有第二个参数，绑定this指向。代码和效果如下：</p><p><img src="'+Ra+'" alt="image-20240728121034784"></p><p>解决方式二：将抽离出去的函数，改为箭头函数。代码和效果如下：</p><p><img src="'+va+'" alt="image-20240728121417335"></p><h3 id="_5-jsx的条件渲染" tabindex="-1"><a class="header-anchor" href="#_5-jsx的条件渲染" aria-hidden="true">#</a> 5，JSX的条件渲染</h3><p><img src="'+Ma+'" alt="image-20240728155040181"></p><p>某些情况下，界面的内容会根据不同的情况显示不同的内容，或者决定是否渲染某部分内容。在vue中，我们会通过指令来控制：比如v-if、v-show。在React中，所有的条件判断都和普通的JavaScript代码一致。</p><p>方式一：条件判断语句，适合逻辑较多的情况。代码和效果如下：</p><p><img src="'+Aa+'" alt="image-20240728160716902"></p><p>方式二：三元运算符，适合逻辑比较简单。代码和效果如下：</p><p><img src="'+Ba+'" alt="image-20240728161130371"></p><p>三元运算符也适用于条件判断复杂的情况，将对应逻辑抽离到一个函数中。</p><p>方式三：逻辑与运算符&amp;&amp;适合如果条件成立，渲染某一个组件；如果条件不成立，什么内容也不渲染。</p><p><img src="'+ka+'" alt="image-20240728162043913"></p><p>方式四：在webpack环境中，可以使用可选链。此处先不使用，因为不是在webpack环境中。</p><p>案例练习：点击按钮切换Hello World的展示与隐藏，代码和效果如下：</p><p><img src="'+Da+'" alt="image-20240728172245532"></p><p>我们想实现类似于vue中v-show指令的效果，代码和效果如下：</p><p><img src="'+ya+'" alt="image-20240728172859369"></p><h3 id="_6-jsx的列表渲染" tabindex="-1"><a class="header-anchor" href="#_6-jsx的列表渲染" aria-hidden="true">#</a> 6，JSX的列表渲染</h3><p><img src="'+Oa+'" alt="image-20240728155116289"></p><p><img src="'+Ja+'" alt="image-20240728155139348"></p><p>真实开发中我们会从服务器请求到大量的数据，数据会以列表的形式存储。如何展示列表呢？在React中，展示列表最多的方式就是使用数组的map高阶函数。</p><p>展示学生列表，代码和效果如下：</p><p><img src="'+Ha+'" alt="image-20240728174424823"></p><p>现在我们像根据某些条件，展示特定的学生信息。例如：只展示分数大于100的学生信息。代码和效果如下：</p><p><img src="'+Ta+'" alt="image-20240728174941955"></p><p>因为分数大于100的学生有很多，所以我们只展示前2条数据。我们可以使用slice方法对过滤出来的数组进行截取，代码和效果如下：</p><p><img src="'+Xa+'" alt="image-20240728175433178"></p><p>上述步骤，我们可以一次进行处理，代码和效果如下：</p><p><img src="'+wa+'" alt="image-20240728175735498"></p><h2 id="三-jsx的原理和本质" tabindex="-1"><a class="header-anchor" href="#三-jsx的原理和本质" aria-hidden="true">#</a> 三，JSX的原理和本质</h2><h3 id="_1-jsx的本质" tabindex="-1"><a class="header-anchor" href="#_1-jsx的本质" aria-hidden="true">#</a> 1，JSX的本质</h3><p><img src="'+Na+'" alt="image-20240728155202943"></p><h3 id="_2-createelement源码" tabindex="-1"><a class="header-anchor" href="#_2-createelement源码" aria-hidden="true">#</a> 2，createElement源码</h3><p><img src="'+Pa+'" alt="image-20240728155221989"></p><h3 id="_3-babel转换" tabindex="-1"><a class="header-anchor" href="#_3-babel转换" aria-hidden="true">#</a> 3，Babel转换</h3><p><img src="'+Wa+'" alt="image-20240728155239078"></p><p>我们想亲眼看到我们编写的JSX代码经过转换后的样子。</p><p>步骤一：将编写的JSX代码复制，操作如下：</p><p><img src="'+Ea+'" alt="image-20240728185928077"></p><p>步骤二：打开Babel在线工具，操作如下：</p><p>在线Babel链接：https://babeljs.io/repl/#?presets=react</p><p><img src="'+Ua+'" alt="image-20240728192127917"></p><h3 id="_4-直接编写jsx代码" tabindex="-1"><a class="header-anchor" href="#_4-直接编写jsx代码" aria-hidden="true">#</a> 4，直接编写JSX代码</h3><p><img src="'+Ia+'" alt="image-20240728155305253"></p><p>我们尝试编写原生React代码。</p><p>第一步：去除babel和script的type属性，浏览器会报错。操作如下：</p><p><img src="'+Va+'" alt="image-20240728192445266"></p><p>第二步：将转换后的元素React代码，替换之前编写的JSX代码。操作如下：</p><p><img src="'+Fa+'" alt="image-20240728194139804"></p><h3 id="_5-虚拟dom的创建过程" tabindex="-1"><a class="header-anchor" href="#_5-虚拟dom的创建过程" aria-hidden="true">#</a> 5，虚拟DOM的创建过程</h3><p><img src="'+La+'" alt="image-20240728155327793"></p><p><img src="'+Ya+'" alt="image-20240728155352716"></p><p>这个ReactElement对象是什么作用呢？React为什么要创建它呢？</p><ul><li>原因是React利用ReactElement对象组成了一个JavaScript的对象树。</li><li>JavaScript的对象树就是虚拟DOM（Virtual DOM）。</li></ul><p><img src="'+Ga+'" alt="image-20240728220931892"></p><p>虚拟DOM有什么作用呢？</p><ul><li>状态发生变化 -&gt; render函数重新执行 -&gt; 重新调用一大堆React.createElement -&gt; 新旧虚拟DOM使用diff算法进行对比，做到局部更新。</li><li>因为生成的虚拟DOM，所以最终可以生成web端的元素，或IOS/Android端的元素，可以做跨平台。</li></ul><h3 id="_6-声明式编程" tabindex="-1"><a class="header-anchor" href="#_6-声明式编程" aria-hidden="true">#</a> 6，声明式编程</h3><p><img src="'+qa+'" alt="image-20240728155425754"></p><h3 id="_7-案例练习" tabindex="-1"><a class="header-anchor" href="#_7-案例练习" aria-hidden="true">#</a> 7，案例练习</h3><p><img src="'+za+'" alt="image-20240728155445642"></p><p>步骤一：列表渲染，展示静态数据。操作如下：</p><p><img src="'+Ka+'" alt="image-20240729085720410"></p><p>步骤二：计算总价格，并在底部展示。代码和效果如下：</p><p><img src="'+Qa+'" alt="image-20240729090708309"></p><p>步骤三：将有人民币符号的价格抽离出一个函数，代码和效果如下：</p><p><img src="'+Za+'" alt="image-20240729105937607"></p><p>步骤四：当数量为1时，减按钮处于禁用状态。代码和效果如下：</p><p><img src="'+$a+'" alt="image-20240729110514592"></p><p>步骤五：实现点击+1或-1按钮，能修改数量。代码和效果如下：</p><p><img src="'+a2+'" alt="image-20240729113548630"></p><p><img src="'+i2+'" alt="image-20240729113927123"></p><p>步骤六：我们可以看到减按钮和加按钮逻辑代码都一样，因此我们可以将代码抽取到一个函数中。代码和效果如下：</p><p><img src="'+s2+'" alt="image-20240729115638650"></p><p>第七步：点击删除按钮，实现移除一条图书信息</p><p><img src="'+e2+'" alt="image-20240729123756339"></p><p>第八步：当一条书籍信息也没有时，我们应该展示 “购物车为空，请添加书籍”。代码和效果如下：</p><p><img src="'+t2+'" alt="image-20240729132208098"></p><h2 id="三-react脚手架" tabindex="-1"><a class="header-anchor" href="#三-react脚手架" aria-hidden="true">#</a> 三，React脚手架</h2><h3 id="_1-认识脚手架工具" tabindex="-1"><a class="header-anchor" href="#_1-认识脚手架工具" aria-hidden="true">#</a> 1，认识脚手架工具</h3><p><img src="'+p2+'" alt="image-20240729135050305"></p><p><img src="'+g2+'" alt="image-20240729135110234"></p><h3 id="_2-create-react-app" tabindex="-1"><a class="header-anchor" href="#_2-create-react-app" aria-hidden="true">#</a> 2，create-react-app</h3><p><img src="'+n2+'" alt="image-20240729135136961"></p><p><img src="'+r2+`" alt="image-20240729135157192"></p><p>第一步：全局安装React脚手架，操作如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> create-react-app <span class="token parameter variable">-g</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+m2+`" alt="image-20240729140524738"></p><p>第二步：查看React脚手架版本，操作如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>create-react-app <span class="token parameter variable">--version</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+c2+'" alt="image-20240729140743534"></p><h3 id="_3-创建react项目" tabindex="-1"><a class="header-anchor" href="#_3-创建react项目" aria-hidden="true">#</a> 3，创建React项目</h3><h4 id="a-创建并运行项目" tabindex="-1"><a class="header-anchor" href="#a-创建并运行项目" aria-hidden="true">#</a> A）创建并运行项目</h4><p><img src="'+o2+`" alt="image-20240729135233888"></p><p>第一步：创建React项目，操作如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> init react-app 02_learn_scaffold
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+d2+'" alt="image-20240729143245205"></p><p>第二步：查看版本，操作如下：</p><p><img src="'+_2+'" alt="image-20240729144017407"></p><p>第三步：创建项目，注意项目名称不能包含大写字母。操作如下：</p><p><img src="'+l2+'" alt="image-20240729153911619"></p><p>注意：早期React创建处理的项目，是使用yarn进行管理的。</p><p>第四步：使用VsCode打开项目，并启动启动项目查看效果。操作如下：</p><p><img src="'+h2+'" alt="image-20240729154937732"></p><h4 id="b-介绍pwa" tabindex="-1"><a class="header-anchor" href="#b-介绍pwa" aria-hidden="true">#</a> B）介绍PWA</h4><p><img src="'+x2+'" alt="image-20240729135307499"></p><ul><li>App Manifest就是将一个网页以App图标的方式展示在手机桌面。</li><li>Service Worker 是用来做离线缓存。</li><li>消息推送。</li></ul><h4 id="c-梳理项目结构" tabindex="-1"><a class="header-anchor" href="#c-梳理项目结构" aria-hidden="true">#</a> C）梳理项目结构</h4><p><img src="'+j2+'" alt="image-20240729135250767"></p><h3 id="_4-从零编写代码" tabindex="-1"><a class="header-anchor" href="#_4-从零编写代码" aria-hidden="true">#</a> 4，从零编写代码</h3><h4 id="a-删除文件" tabindex="-1"><a class="header-anchor" href="#a-删除文件" aria-hidden="true">#</a> A）删除文件</h4><p><img src="'+b2+'" alt="image-20240729211134638"></p><p>第一步：将一些我们用不上的文件删除，操作如下：</p><p><img src="'+f2+'" alt="image-20240729203350475"></p><p>第二步：删除index.html中关于manifest的html代码。操作如下：</p><p><img src="'+u2+'" alt="image-20240729211422829"></p><p>第三步：书写基本结构，查看效果。代码和效果如下：</p><p><img src="'+S2+'" alt="image-20240729211705502"></p><p>第四步：为了方便维护，我们应该将App组件从index.js文件中抽离到一个jsx文件中，代码和效果如下：</p><p><img src="'+C2+'" alt="image-20240729212202025"></p><p>第五步：在index.js中导入，并使用。代码和效果如下：</p><p><img src="'+R2+'" alt="image-20240729212321976"></p><p>第六步：创建Components文件夹，并在该文件夹下创建HelloWorld组件，并导出。代码如下：</p><p><img src="'+v2+'" alt="image-20240729213012116"></p><p>第七步：在App组件中导入并使用，代码和效果如下：</p><p><img src="'+M2+'" alt="image-20240729213248708"></p><p>到此，从零编写代码就已经完成。</p><h3 id="_5-webpack的配置" tabindex="-1"><a class="header-anchor" href="#_5-webpack的配置" aria-hidden="true">#</a> 5，webpack的配置</h3><p><img src="'+A2+'" alt="image-20240729213417156"></p><p>默认情况下，React将webpack配置隐藏起来了。我们想要查看有两种方式。</p><ul><li>查看React的源码</li><li>使用命令，让webpack配置文件显示出来。</li></ul><p>我们采取第二种方式，运行npm run eject。</p><p>第一步：终端运行npm run eject命令，操作如下：</p><p><img src="'+B2+'" alt="image-20240729213916950"></p><p>第二步：输入yes，会提示让我们处理未跟踪的文件，或暂存和提交修改的文件。操作如下：</p><p><img src="'+k2+'" alt="image-20240729214225998"></p><p>第三步：使用git将所有修改文件暂存并提交，操作如下：</p><p><img src="'+D2+'" alt="image-20240729214415230"></p><p>第四步：再次运行npm run eject，并且会多了两个文件夹(config和scripts)，并且将所有依赖放入到package.json文件的dependencies节点。操作和效果如下：</p><p><img src="'+y2+'" alt="image-20240729214945729"></p><p><img src="'+O2+'" alt="image-20240729215528533"></p><p><img src="'+J2+'" alt="image-20240729215555287"></p><h2 id="四-组件化开发-一" tabindex="-1"><a class="header-anchor" href="#四-组件化开发-一" aria-hidden="true">#</a> 四，组件化开发(一)</h2><h3 id="_1-组件化开发" tabindex="-1"><a class="header-anchor" href="#_1-组件化开发" aria-hidden="true">#</a> 1，组件化开发</h3><p><img src="'+H2+'" alt="image-20240731215200621"></p><p><img src="'+T2+'" alt="image-20240731215222965"></p><p><img src="'+X2+'" alt="image-20240731215244749"></p><h3 id="_2-类组件" tabindex="-1"><a class="header-anchor" href="#_2-类组件" aria-hidden="true">#</a> 2，类组件</h3><p><img src="'+w2+'" alt="image-20240731220146954"></p><p>类组件的要求：</p><ul><li>组件的名称必须是大写字母开头(无论是类组件还是函数组件)。</li><li>类组件需要继承自 React.Component。</li><li>类组件必须实现render函数。</li></ul><p>实现一个类组件(代码片段，rce)，代码如下：</p><p><img src="'+N2+'" alt="image-20240731221902929"></p><h3 id="_3-render函数返回值" tabindex="-1"><a class="header-anchor" href="#_3-render函数返回值" aria-hidden="true">#</a> 3，render函数返回值</h3><p><img src="'+P2+'" alt="image-20240731220221981"></p><p>render会在什么时候会被调用？</p><ul><li>初次渲染会被调用。</li><li>调用setState修改状态。</li></ul><p>render函数返回值有哪些？</p><ul><li>React元素，包括普通html元素，JSX或子组件。</li><li>数组或fragment。</li><li>子组件</li></ul><h4 id="a-返回react元素" tabindex="-1"><a class="header-anchor" href="#a-返回react元素" aria-hidden="true">#</a> A) 返回React元素</h4><p>其一：返回JSX，代码如下：</p><p><img src="'+W2+'" alt="image-20240731223347121"></p><p><img src="'+E2+'" alt="image-20240731222457076"></p><p>其二：返回子组件，代码如下：</p><p><img src="'+U2+'" alt="image-20240731223615026"></p><h4 id="b-返回数组或fragment" tabindex="-1"><a class="header-anchor" href="#b-返回数组或fragment" aria-hidden="true">#</a> B）返回数组或fragment</h4><p>其一：返回数组，代码如下：</p><p><img src="'+I2+'" alt="image-20240731225236112"></p><p>其二：返回fragment，默认情况下返回的jsx只能有一个根元素，我们通常用div元素进行包裹。但是我们又不希望这个div元素渲染，因此我们可以使用fragment标签。官方文档如下：</p><p><img src="'+V2+'" alt="image-20240731225722988"></p><h4 id="c-portals" tabindex="-1"><a class="header-anchor" href="#c-portals" aria-hidden="true">#</a> C）Portals</h4><p>可以渲染子节点到不同的 DOM 子树中。</p><h4 id="d-字符串或数字" tabindex="-1"><a class="header-anchor" href="#d-字符串或数字" aria-hidden="true">#</a> D）字符串或数字</h4><p>它们在 DOM 中会被渲染为文本节点，代码如下：</p><p><img src="'+F2+'" alt="image-20240731230054189"></p><h4 id="d-布尔类型或null" tabindex="-1"><a class="header-anchor" href="#d-布尔类型或null" aria-hidden="true">#</a> D）布尔类型或null</h4><p>什么都不渲染。</p><p><img src="'+L2+'" alt="image-20240731230219934"></p><h3 id="_4-函数式组件" tabindex="-1"><a class="header-anchor" href="#_4-函数式组件" aria-hidden="true">#</a> 4，函数式组件</h3><p><img src="'+Y2+'" alt="image-20240731220239754"></p><p>函数式组件的特点：</p><ul><li>没有生命周期，也会被更新并挂载，但是没有生命周期函数；</li><li>this关键字不能指向组件实例（因为没有组件实例）；</li><li>没有内部状态（state）；</li></ul><p>创建一个函数式组件，在index.js文件中导入并使用。代码如下：</p><p><img src="'+G2+'" alt="image-20240731230843472"></p><p>注意：函数式组件中是没有状态的，必须使用hooks，代码如下：</p><p><img src="'+q2+'" alt="image-20240731231310317"></p><h3 id="_5-组件生命周期" tabindex="-1"><a class="header-anchor" href="#_5-组件生命周期" aria-hidden="true">#</a> 5，组件生命周期</h3><h4 id="a-什么是生命周期" tabindex="-1"><a class="header-anchor" href="#a-什么是生命周期" aria-hidden="true">#</a> A）什么是生命周期</h4><p><img src="'+z2+'" alt="image-20240731231453562"></p><h4 id="b-生命周期函数" tabindex="-1"><a class="header-anchor" href="#b-生命周期函数" aria-hidden="true">#</a> B）生命周期函数</h4><p><img src="'+K2+'" alt="image-20240731231519474"></p><p><img src="'+Q2+'" alt="image-20240731231535846"></p><p><img src="'+Z2+'" alt="image-20240731231812892"></p><h4 id="c-挂载阶段" tabindex="-1"><a class="header-anchor" href="#c-挂载阶段" aria-hidden="true">#</a> C）挂载阶段</h4><p>挂载阶段构造函数执行流程：</p><p>constructor =&gt; render =&gt; React updates DOM and Refs =&gt; componentDidMount</p><p>第一步：创建HelloWorld组件，代码和效果如下：</p><p><img src="'+$2+'" alt="image-20240731233928323"></p><p>第二步：在App组件中导入并使用，代码结构如下：</p><p><img src="'+ai+'" alt="image-20240731234027342"></p><p>第三步：在constructor函数和render函数中加入控制台打印，代码如下：</p><p><img src="'+ii+'" alt="image-20240731234947123"></p><p>第四步：咋控制台中查看效果，如下：</p><p><img src="'+si+'" alt="image-20240731235046382"></p><p>注意：多次使用HelloWorld组件，相应的钩子函数会执行两次。代码如下：</p><p><img src="'+ei+'" alt="image-20240731235255711"></p><p>第五步：当组件挂载完成，会调用componentDidMount函数，代码和效果如下：</p><p><img src="'+ti+'" alt="image-20240731235814688"></p><h4 id="d-更新阶段" tabindex="-1"><a class="header-anchor" href="#d-更新阶段" aria-hidden="true">#</a> D）更新阶段</h4><p>更新阶段执行流程：</p><p>render =&gt; React updates DOM and refs =&gt; componentDidUpdates</p><p><img src="'+pi+'" alt="image-20240801073253177"></p><h4 id="e-卸载阶段" tabindex="-1"><a class="header-anchor" href="#e-卸载阶段" aria-hidden="true">#</a> E）卸载阶段</h4><p>触发卸载 =&gt; 执行componentWillUnmount</p><p>第一步：在App组件中添加点击按钮，触发HelloWorld组件的隐藏与显示，App组件中的代码如下：</p><p><img src="'+gi+'" alt="image-20240801074506796"></p><p>第二步：当切换为隐藏状态时，HelloWorld组件会被卸载，从而执行componentWillUnmount，代码和效果如下：</p><p><img src="'+ni+'" alt="image-20240801074832093"></p><h4 id="f-不常用生命周期函数" tabindex="-1"><a class="header-anchor" href="#f-不常用生命周期函数" aria-hidden="true">#</a> F）不常用生命周期函数</h4><p><img src="'+ri+'" alt="image-20240801085902700"></p><p>shouldComponentUpdate：该生命周期函数很常用，但是我们等待讲性能优化时再来详细讲解。代码如下：</p><p><img src="'+mi+'" alt="image-20240801090348129"></p><p>getSnapshotBeforeUpdate：在React更新DOM之前回调的一个函数，可以获取DOM更新前的一些信息（比如说滚动位置）。并且该钩子函数的返回值可以在componentDidUpdate中拿到，代码如下：</p><p><img src="'+ci+'" alt="image-20240801091714203"></p><h3 id="_6-组件间的通信" tabindex="-1"><a class="header-anchor" href="#_6-组件间的通信" aria-hidden="true">#</a> 6，组件间的通信</h3><h4 id="a-组件嵌套" tabindex="-1"><a class="header-anchor" href="#a-组件嵌套" aria-hidden="true">#</a> A）组件嵌套</h4><p><img src="'+oi+'" alt="image-20240801092021768"></p><p>创建Header、Main和Footer组件，代码如下：</p><p><img src="'+di+'" alt="image-20240801093905351"></p><p>第二步：在App中引入这些子组件并使用，代码如下：</p><p><img src="'+_i+'" alt="image-20240801094010449"></p><p>第三步：在Main组件中，创建MainBanner和MainProduct子组件，并引入。代码和效果如下：</p><p><img src="'+li+'" alt="image-20240801094251188"></p><p><img src="'+hi+'" alt="image-20240801092050781"></p><h4 id="a-父子通信props" tabindex="-1"><a class="header-anchor" href="#a-父子通信props" aria-hidden="true">#</a> A）父子通信props</h4><p><img src="'+xi+'" alt="image-20240801092116810"></p><p>第一步：我们可以通过自定义属性将父组件(Main)中的数据传递给子组件(MainBanner)，代码如下：</p><p><img src="'+ji+'" alt="image-20240801124033825"></p><p>第二步：子组件(MainBanner)在constructor中通过props获取父组件(Main)传递过来的数据，代码和效果如下：</p><p><img src="'+bi+'" alt="image-20240801124350540"></p><p>第三步：在子组件(MainBanner)中使用通过props属性使用父组件传递过来的数据，代码和效果如下：</p><p><img src="'+fi+'" alt="image-20240801125126196"></p><p>第四步：父组件(Main)向子组件(Mainproduct)通过自定义属性传递数据，代码如下：</p><p><img src="'+ui+'" alt="image-20240801125522218"></p><p>第五步：在子组件(Mainproduct)中接父组件(Main)收传递过来的数据，注意：如果子组件中没有自己的状态，可以省略constructor函数。代码如下：</p><p><img src="'+Si+'" alt="image-20240801130115272"></p><p>案例练习：获取动态数据并传递和展示。</p><p>第一步：安装axios，操作如下：</p><p><img src="'+Ci+'" alt="image-20240801130938088"></p><p>第二步：在Main组件的componentDidMount钩子函数中获取数据，并在控制台打印。代码和操作如下：</p><p><img src="'+Ri+'" alt="image-20240801131246105"></p><p>第三步：修改子组件中的对应代码。</p><p>1）修改子组件(MainBanner)中的代码，如下：</p><p><img src="'+vi+'" alt="image-20240801132556673"></p><p>2）修改子组件(MainProduct)中的代码，如下：</p><p><img src="'+Mi+'" alt="image-20240801132811475"></p><p>第四步：查看效果，如下：</p><p><img src="'+Ai+'" alt="image-20240801132906340"></p><h4 id="b-props类型校验" tabindex="-1"><a class="header-anchor" href="#b-props类型校验" aria-hidden="true">#</a> B）props类型校验</h4><p><img src="'+Bi+'" alt="image-20240801133214070"></p><p>对于传递给子组件的数据，有时候我们可能希望进行验证，特别是对于大型项目来说。</p><p>第一步：引入prop-types这个包，并编写代码对props中的属性进行限制，代码如下：</p><p><img src="'+ki+'" alt="image-20240801135443146"></p><p>第二步：在父组件(Main)中，给子组件(MainBanner)传递数据。通过自定义属性传入错误类型，并查看控制台报错如下：</p><p><img src="'+Di+'" alt="image-20240801140022558"></p><p>如何给在prop没有传递的情况下，给一个默认值？</p><p>方式一：通过组件名.defaultProps进行定义。</p><p>1)编写props属性校验规则代码，如下：</p><p><img src="'+yi+'" alt="image-20240801141534268"></p><p>2）为了方便观察默认值，我们需要添加对应的样式，代码和效果如下：</p><p><img src="'+Oi+'" alt="image-20240801142003525"></p><p>3）使用没有传入自定义属性的子组件MainBanner，代码和效果如下：</p><p><img src="'+Ji+'" alt="image-20240801142242700"></p><p>方式二：从ES2022开始，你也可以在React类组件中将defaultProps声明为静态属性。代码如下：</p><p><img src="'+Hi+'" alt="image-20240801142539994"></p><p>官方文档有说明，如下：</p><p><img src="'+Ti+'" alt="image-20240801142716829"></p><p>需要注意的是，函数式组件props类型校验和默认值的写法与类组件中保持一致，如下：</p><p><img src="'+Xi+'" alt="image-20240801142952338"></p><h4 id="c-子父通信-自定义函数" tabindex="-1"><a class="header-anchor" href="#c-子父通信-自定义函数" aria-hidden="true">#</a> C）子父通信-自定义函数</h4><p><img src="'+wi+'" alt="image-20240801180909370"></p><p>在React中，子组件向父组件传递数据也是通过自定义属性传递一个函数，实现的。</p><p>案例：希望点击子组件AddCounter的按钮，实现对父组件App中的数据进行修改。</p><p>步骤一：在子组件AddCounter中监听按钮的点击，代码如下:</p><p><img src="'+Ni+'" alt="image-20240801182525155"></p><p>步骤二：对传入过来的props进行类型校验，必须是一个函数。代码如下：</p><p><img src="'+Pi+'" alt="image-20240801183009811"></p><p>步骤三：在App组件中向子组件AddCounter通过自定义属性传递一个函数，代码如下：</p><p><img src="'+Wi+'" alt="image-20240801183221223"></p><p>步骤四：自定义属性传递的函数中还要有一个函数调用，代码如下：</p><p><img src="'+Ei+'" alt="image-20240801185535867"></p><p>第五步：点击子组件AddCount的按钮时，触发子组件的事件处理函数addCount，在内部调用通过自定义属性传递过来的函数，实现修改父组件中的状态。代码和效果如下：</p><p><img src="'+Ui+'" alt="image-20240801190157029"></p><h4 id="d-通信案例练习" tabindex="-1"><a class="header-anchor" href="#d-通信案例练习" aria-hidden="true">#</a> D）通信案例练习</h4><p><img src="'+Ii+'" alt="image-20240801215818023"></p><p>第一步：在App组件中定义tab栏数据，代码如下：</p><p><img src="'+Vi+'" alt="image-20240801191104898"></p><p>第二步：将tab栏抽离成一个组件，在App组件中导入并使用。代码如下：</p><p><img src="'+Fi+'" alt="image-20240801191335238"></p><p>第三步：在父组件App中通过自定义属性titles传递状态，代码如下：</p><p><img src="'+Li+'" alt="image-20240801191709596"></p><p>第四步：在子组件TabControl中通过props接收并渲染。代码和效果如下：</p><p><img src="'+Yi+'" alt="image-20240801192034999"></p><p>第五步：创建对应的css文件夹编写样式。当某一个item选中时，文字变成红色，并且底部有红色边框。代码如下：</p><p><img src="'+Gi+'" alt="image-20240801192908122"></p><p>第六步：定义一个状态currentIndex，来记录当前选中的索引，并且根据当前索引判断是否添加active类名。代码如下：</p><p><img src="'+qi+'" alt="image-20240801210731112"></p><p>第七步：实现点击item的处理函数，并且可以传递当前item的index。代码和效果如下：</p><p><img src="'+zi+'" alt="image-20240801211034076"></p><p>第八步：实现点击不同item，通过添加对应类名，从而文字变色和带有红色底部边框的效果。代码如下：</p><p><img src="'+Ki+'" alt="image-20240801211425143"></p><p>第九步：点击不同的tab项，下方展示不同的内容。先在App组件中定义一个状态index，并通过自定义属性传递一个函数。代码如下：</p><p><img src="'+Qi+'" alt="image-20240801215226646"></p><p>第十步：在点击不同tab项，修改currentIndex的同时，也调用父组件传递过来的方法，从而修改父组件中的状态tabIndex。代码和效果如下：</p><p><img src="'+Zi+'" alt="image-20240801215706091"></p><h3 id="_7-组件插槽用法" tabindex="-1"><a class="header-anchor" href="#_7-组件插槽用法" aria-hidden="true">#</a> 7，组件插槽用法</h3><p><img src="'+$i+'" alt="image-20240801220120837"></p><h4 id="a-方式一-children属性" tabindex="-1"><a class="header-anchor" href="#a-方式一-children属性" aria-hidden="true">#</a> A）方式一：children属性</h4><p><img src="'+a0+'" alt="image-20240801220144466"></p><p>需求：对于我们编写的Navbar组件来说，一般分为三个部分，左中右。我们想根据传入不同的内容，使用NavBar展示不同的效果。因此我们可以实现类似于Vue中插槽。</p><p>为了方便观察，给子组件NavBar添加样式，代码如下：</p><p><img src="'+i0+'" alt="image-20240801222326138"></p><p>第一步：在App组件中，向NavBar组件标签中传递内容，代码如下：</p><p><img src="'+s0+'" alt="image-20240801222003100"></p><p>第二步：NavBar组件中通过this.props.children属性接收传递过来的内容，并使用。代码和效果如下：</p><p><img src="'+e0+'" alt="image-20240801222235587"></p><p>但是通过children属性实现插槽效果有一个弊端，那就是只传递一个元素时，children不再是一个数组。代码和效果如下：</p><p><img src="'+t0+'" alt="image-20240801222802956"></p><p><img src="'+p0+'" alt="image-20240801222910403"></p><p>此外，如果我们要求向组件标签中，只能传递一个元素时，我们可以使用PropTypes进行限制，代码和效果如下：</p><p><img src="'+g0+'" alt="image-20240801224030464"></p><p>相反如果我们希望组件标签中传递的内容不能为一个元素，我们也可以使用propTypes规定props.children必须是一个数组。代码和效果如下：</p><p><img src="'+n0+'" alt="image-20240801224713730"></p><h4 id="b-方式二-props属性" tabindex="-1"><a class="header-anchor" href="#b-方式二-props属性" aria-hidden="true">#</a> B）方式二：props属性</h4><p><img src="'+r0+'" alt="image-20240801224837830"></p><p>通过props.children属性实现插槽效果的两个弊端：</p><ul><li>组件标签中传入一个元素，children是一个对象。传入多个元素，children是一个数组。</li><li>如果children是一个数组，我们在使用时，对顺序有要求，不然渲染出来不是我们想要的效果。</li></ul><p>第一步：在App组件中，给NavBar2组件标签传递自定义属性，只不过这一次我们传递的是JSX，代码如下：</p><p><img src="'+m0+'" alt="image-20240801230337033"></p><p>第二步：在子组件NavBar2中，通过props属性接收并使用。代码和效果如下：</p><p><img src="'+c0+'" alt="image-20240801230512343"></p><h4 id="c-作用域插槽" tabindex="-1"><a class="header-anchor" href="#c-作用域插槽" aria-hidden="true">#</a> C）作用域插槽</h4><p>我们想实现vue中类似作用域插槽的效果，我们在子组件标签上通过自定义属性中传入模板(jsx)，又想在传入的模板中使用子组件中的数据。该如何实现？代码如下：</p><p>第一步：分析我们之前实现的效果和代码如下：</p><p><img src="'+o0+'" alt="image-20240801233343674"></p><p>第二步：向TabControl组件中传递模板内容，实现动态渲染tab项。代码如下：</p><p><img src="'+d0+'" alt="image-20240801234011804"></p><p>第三步：在子组件标签上通过自定义属性传入一个函数，而不是一个jsx元素。我们在函数中通过参数可以获取到子组件中的传递过来的数据。</p><p><img src="'+_0+'" alt="image-20240801234438086"></p><p>第四步：我们还可以根据不同条件，渲染不同的元素。代码和效果如下：</p><p><img src="'+l0+'" alt="image-20240801235639839"></p><h3 id="_8-非父子组件通信" tabindex="-1"><a class="header-anchor" href="#_8-非父子组件通信" aria-hidden="true">#</a> 8，非父子组件通信</h3><h4 id="a-context应用场景" tabindex="-1"><a class="header-anchor" href="#a-context应用场景" aria-hidden="true">#</a> A）Context应用场景</h4><p><img src="'+h0+'" alt="image-20240802080718639"></p><h4 id="b-context使用" tabindex="-1"><a class="header-anchor" href="#b-context使用" aria-hidden="true">#</a> B）Context使用</h4><p><img src="'+x0+'" alt="image-20240802080804273"></p><p><img src="'+j0+'" alt="image-20240802080830049"></p><p>额外知识补充，如果我们不想将一个对象中的所有属性通过自定义属性key=value的形式传递给子组件，那么我们可以使用属性展开。代码如下：</p><p><img src="'+b0+'" alt="image-20240802083257702"></p><p>使用Context给后代组件传递数据，不需要一层层传递，可以实现跨组件传递。代码和效果如下：</p><p>第一步：创建context/theme-context.js文件，在此文件中创建一个Context，代码如下：</p><p><img src="'+f0+'" alt="image-20240802084826693"></p><p>第二步：在App组件中导入ThemContext并使用，通过ThemeContext中的provider中的value属性为后代提供数据。代码如下：</p><p><img src="'+u0+'" alt="image-20240802085350452"></p><p>第三步，在后代组件HomeInfo中，通过this.context使用祖先组件传递过来的数据，代码和效果如下：</p><p><img src="'+S0+'" alt="image-20240802085908112"></p><p>因为可以有多个Context向后代组件提供数据，因此我们需要手动指定是哪一个Context，代码和效果如下：</p><p><img src="'+C0+'" alt="image-20240802090321547"></p><p>到此我们就实现使用Context向后代组件传递数据。</p><p>如果我们使用多个Context共享多个数据，该怎么做？</p><p>第一步：创建context/user-context.js文件，代码如下：</p><p><img src="'+R0+'" alt="image-20240802101915476"></p><p>第二步：在组件HomeInfo中引入UserContext，通过UserContext.consumer中传入匿名函数，就可以获取多个context传递的数据。代码如下：</p><p><img src="'+v0+'" alt="image-20240802102813097"></p><p>查看效果：</p><p><img src="'+M0+'" alt="image-20240802102941598"></p><h4 id="c-context-函数式组件" tabindex="-1"><a class="header-anchor" href="#c-context-函数式组件" aria-hidden="true">#</a> C）Context-函数式组件</h4><p><img src="'+A0+'" alt="image-20240802080858492"></p><p>现在有一个问题，在React函数式组件中，是没有this的，我们该如何使用context？使用ThemeContext.Consumer组件，然后通过匿名回调函数获取到ThemeContext.provider传递过来的数据。代码和效果如下：</p><p><img src="'+B0+'" alt="image-20240802101525370"></p><p>在函数式组件中，就只能通过ThemeContext.Consumer中带匿名回调函数的方式，使用通过Context向后代传递过来的数据。</p><p>Context用起来很麻烦，在开发中我们通常使用Redux实现数据共享。</p><h4 id="d-context默认值" tabindex="-1"><a class="header-anchor" href="#d-context默认值" aria-hidden="true">#</a> D）context默认值</h4><p>什么时候使用默认值defaultValue呢？如果我们将一个组件放到Context.Provider组件外面，我们不能获取遇到Context传递的数据。代码和效果如下：</p><p><img src="'+k0+'" alt="image-20240802104246875"></p><p>第一步：在ThemeContext创建时，传入默认数据。代码如下：</p><p><img src="'+D0+'" alt="image-20240802104514371"></p><p>第二步：指定contextType，并通过this.context使用传递过来的数据，代码和效果如下：</p><p><img src="'+y0+'" alt="image-20240802104902165"></p><h4 id="f-事件总线" tabindex="-1"><a class="header-anchor" href="#f-事件总线" aria-hidden="true">#</a> F）事件总线</h4><p>之前我们通过context可以实现跨组件通信，但是不能做到兄弟组件之间的通信。我们可以使用事件总线实现任意两个组件之间的通信。</p><p>第一步：搭建案例结构，代码如下：</p><p><img src="'+O0+'" alt="image-20240802112133588"></p><p>效果如下：</p><p><img src="'+J0+'" alt="image-20240802112159179"></p><p>第二步：安装之前封装好的事件总线库：hy-event-bus。</p><p>1）安装hy-event-bus，操作如下：</p><p><img src="'+H0+'" alt="image-20240802112852225"></p><p>2）创建utils/event-bus.js文件，创建eventBus实例。代码如下：</p><p><img src="'+T0+'" alt="image-20240802113208500"></p><p>第三步：在组件Home组件中，监听事件，代码如下：</p><p><img src="'+X0+'" alt="image-20240802121749985"></p><p>当组件卸载时，我们也需要解绑事件，但是因为off方法的第二个参数，需要传入解绑的事件。因此我们需要将绑定的事件处理函数进行抽离。代码和效果如下：</p><p><img src="'+w0+'" alt="image-20240802123255792"></p><p>我们该如何解决事件处理函数中this指向undefined的问题？有三种方式。</p><p>解决方式一：使用bind函数进显式绑定this，代码如下：</p><p><img src="'+N0+'" alt="image-20240802123621499"></p><p>解决方式二：定义事件处理函数时，使用箭头函数，代码和效果如下：</p><p><img src="'+P0+'" alt="image-20240802124312271"></p><p>解决方式三：在封装hy-event-store库时，on和off方法接收三个参数，用于绑定事件处理函数中的this。代码和效果如下：</p><p><img src="'+W0+'" alt="image-20240802125119791"></p><p>第四步：在组件HomeBanner中，给按钮绑定点击事件，代码如下：</p><p><img src="'+E0+'" alt="image-20240802125335695"></p><h2 id="五-setstate使用" tabindex="-1"><a class="header-anchor" href="#五-setstate使用" aria-hidden="true">#</a> 五，setState使用</h2><h3 id="_1-为什么使用setstate" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用setstate" aria-hidden="true">#</a> 1，为什么使用setState</h3><p><img src="'+U0+'" alt="image-20240802183119546"></p><p><img src="'+I0+'" alt="Vue和React数据管理和渲染流程对比"></p><h3 id="_2-setstate基本使用" tabindex="-1"><a class="header-anchor" href="#_2-setstate基本使用" aria-hidden="true">#</a> 2, setState基本使用</h3><h4 id="a-基本使用-对象" tabindex="-1"><a class="header-anchor" href="#a-基本使用-对象" aria-hidden="true">#</a> A）基本使用-对象</h4><p>向setState传入一个对象，代码和效果如下：</p><p><img src="'+V0+'" alt="image-20240802190441123"></p><h4 id="b-方式二-传入回调函数" tabindex="-1"><a class="header-anchor" href="#b-方式二-传入回调函数" aria-hidden="true">#</a> B）方式二-传入回调函数</h4><p>我们在调用this.setState修改数据时，传入一个对象。还可以传入一个回调函数，代码和效果如下：</p><p><img src="'+F0+'" alt="image-20240802191002161"></p><p>那么这样做有两个好处。</p><p>好处一：可以在回调函数中编写新的state的逻辑。</p><p>好处二：当前的回调函数会将之前的state和prop传递进来。代码和效果如下：</p><p><img src="'+L0+'" alt="image-20240802191955021"></p><h3 id="_3-如何获取异步结果" tabindex="-1"><a class="header-anchor" href="#_3-如何获取异步结果" aria-hidden="true">#</a> 3，如何获取异步结果</h3><p><img src="'+Y0+'" alt="image-20240802201205757"></p><p>我们可以在this.setState中传入一个函数，从而修改状态使页面刷新。但是状态合并是异步的，代码和效果如下：</p><p><img src="'+G0+'" alt="image-20240802194113143"></p><p>如果我们希望在状态更新之后(数据合并)，获取到对于的结果执行一些逻辑代码。那么可以在setState中传入第二个参数：callback。代码和效果如下：</p><p><img src="'+q0+'" alt="image-20240802194848755"></p><h3 id="_4-setstate为什么是异步更新" tabindex="-1"><a class="header-anchor" href="#_4-setstate为什么是异步更新" aria-hidden="true">#</a> 4，setState为什么是异步更新</h3><p><img src="'+z0+'" alt="image-20240802201313815"></p><p>https://github.com/facebook/react/issues/11527#issuecomment-360199710</p><p>为什么setState合并状态要定义成异步的？</p><p>原因一：setState设计为异步，可以显著的提升性能。</p><p>如果每次调用 setState都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的。最好的办法应该是获取到多个更新，之后进行批量更新。</p><p>原因二：如果同步更新了state，但是还没有执行render函数，那么state和props不能保持同步。state和props不能保持一致性，会在开发中产生很多的问题。</p><p>个人理解原因二：如果setState是同步更新，那么父组件中更新了state，render函数(父组件中的)不会立即执行。由于子组件中用到了父组件的state，此时子组件中的props和父组件中的state不同步，这在开发中就造成了很多问题。</p><h3 id="_5-setstate一定是异步的吗" tabindex="-1"><a class="header-anchor" href="#_5-setstate一定是异步的吗" aria-hidden="true">#</a> 5，setState一定是异步的吗</h3><p><img src="'+K0+'" alt="image-20240802201335577"></p><p><img src="'+Q0+'" alt="image-20240802214543778"></p><p>在React18之前，setState只在React事件中(例如：onClick等)是批处理，而在promise中的回调，setTimeout中的回调，原生事件的监听，这些东西依然是同步的。</p><p>在React18之后，所有的setState都是批处理，也就是说都是异步的。</p><p>但是我们仍然希望调用this.setState后，立即能获取到最新的状态。我们应该怎么做？</p><p><img src="'+Z0+'" alt="image-20240802220925381"></p><h3 id="_6-setstate默认是异步的" tabindex="-1"><a class="header-anchor" href="#_6-setstate默认是异步的" aria-hidden="true">#</a> 6，setState默认是异步的</h3><p><img src="'+$0+'" alt="image-20240802201411114"></p><h2 id="六-react组件化开发-二" tabindex="-1"><a class="header-anchor" href="#六-react组件化开发-二" aria-hidden="true">#</a> 六，React组件化开发(二)</h2><h3 id="_1-react性能优化scu" tabindex="-1"><a class="header-anchor" href="#_1-react性能优化scu" aria-hidden="true">#</a> 1，React性能优化SCU</h3><h4 id="a-更新流程" tabindex="-1"><a class="header-anchor" href="#a-更新流程" aria-hidden="true">#</a> A）更新流程</h4><p><img src="'+as+'" alt="image-20240804152224506"></p><p><img src="'+is+'" alt="image-20240804152339304"></p><p><img src="'+ss+'" alt="image-20240804153821227"></p><h4 id="b-render函数被调用" tabindex="-1"><a class="header-anchor" href="#b-render函数被调用" aria-hidden="true">#</a> B）render函数被调用</h4><p><img src="'+es+'" alt="image-20240804155056156"></p><p>现象：App组件中的render函数重新执行，那么他的所有子组件都需要重新执行render函数，代码如下：</p><p><img src="'+ts+'" alt="image-20240804155949351"></p><p>效果如下：</p><p><img src="'+ps+'" alt="image-20240804160107091"></p><p>我们使用this.setState将相同的值赋给某个状态，所有render函数也还是会重新执行，代码和效果如下：</p><p><img src="'+gs+'" alt="image-20240804160440063"></p><p>优化一：针对在App组件中，使用setState给message赋上旧值，App组件render函数会重新执行的问题。代码和效果如下：</p><p><img src="'+ns+'" alt="image-20240804162343888"></p><p>优化二：对于没有使用父组件被修改的props或状态，子组件的render函数也不重新执行，代码和效果如下：</p><p><img src="'+rs+'" alt="image-20240804163325280"></p><p>效果如下：</p><p><img src="'+ms+'" alt="image-20240804163442404"></p><p>如果其他子组件使用父组件的状态，为了性能优化，我们同样需要在子组件的shouldComponentUpdate钩子函数中，书写判断逻辑，来控制子组件render函数是否重新执行，这样很麻烦。</p><h4 id="c-purecomponent" tabindex="-1"><a class="header-anchor" href="#c-purecomponent" aria-hidden="true">#</a> C）PureComponent</h4><p><img src="'+cs+'" alt="image-20240804163905787"></p><p>如果所有的类，我们都需要手动来实现 shouldComponentUpdate，那么会给我们开发者增加非常多的工作量。事实上React已经考虑到了这一点，所以React已经默认帮我们实现好了，如何实现呢？将class继承自PureComponent。代码如下：</p><p><img src="'+os+'" alt="image-20240804164525219"></p><h4 id="d-高阶组件memo" tabindex="-1"><a class="header-anchor" href="#d-高阶组件memo" aria-hidden="true">#</a> D）高阶组件memo</h4><p><img src="'+ds+'" alt="image-20240805091827402"></p><p>如果一个函数式组件在没有使用父组件中被修改的状态，那么该函数式组件的render函数依然会重新执行，代码如下：</p><p><img src="'+_s+'" alt="image-20240804184940325"></p><p>因此对于函数式组件，我们可以使用memo对其进行性能优化，代码和效果如下：</p><p><img src="'+ls+'" alt="image-20240804185705159"></p><h4 id="d-不可变的力量" tabindex="-1"><a class="header-anchor" href="#d-不可变的力量" aria-hidden="true">#</a> D）不可变的力量</h4><p><img src="'+hs+'" alt="image-20240805001558713"></p><p>用于不要去修改原来的状态。</p><p>案例：添加数据，使用push向数组中添加一个新的对象，然后将添加元素后的数组，赋值给之前的数组，这样界面不会刷新。代码和效果如下：</p><p><img src="'+xs+'" alt="image-20240805003752355"></p><p>因此，想在添加书籍后，界面发生更新，我们就需要对状态books进行一个浅拷贝，然后再添加新的书籍对象。代码和效果如下</p><p><img src="'+js+'" alt="image-20240805004611983"></p><p>接下来，我们点击对应图书的按钮，希望count值能+1，代码和效果如下：</p><p><img src="'+bs+'" alt="image-20240805090802415"></p><p>因此，我们需要将原来的状态books，先进行浅拷贝，再通过index对对象中的count进行修改，界面才会刷新。代码和效果如下：</p><p><img src="'+fs+'" alt="image-20240805091709267"></p><h3 id="_2-获取dom方式refs" tabindex="-1"><a class="header-anchor" href="#_2-获取dom方式refs" aria-hidden="true">#</a> 2，获取DOM方式refs</h3><h4 id="a-获取dom元素" tabindex="-1"><a class="header-anchor" href="#a-获取dom元素" aria-hidden="true">#</a> A）获取DOM元素</h4><p><img src="'+us+'" alt="image-20240805091933309"></p><p>在React的开发模式中，通常情况下不需要、也不建议直接操作DOM原生，但是某些特殊的情况，确实需要获取到DOM进行某些操作：</p><ul><li>管理焦点，文本选择或媒体播放；</li><li>触发强制动画；</li><li>集成第三方 DOM 库；</li><li>我们可以通过refs获取DOM；</li></ul><p>如何创建refs来获取对应的DOM呢？目前有三种方式。</p><p>方式一：传入字符串，使用时通过 this.refs.传入的字符串格式获取对应的元素。代码和效果如下：</p><p><img src="'+Ss+'" alt="image-20240805093131351"></p><p>方式二：传入一个对象，对象是通过 React.createRef() 方式创建出来的。使用时获取到创建的对象其中有一个current属性就是对应的元素。代码和效果如下：</p><p><img src="'+Cs+'" alt="image-20240805094039197"></p><p>方式三：传入一个函数，该函数会在DOM被挂载时进行回调，这个函数会传入一个 元素对象，我们可以自己保存，使用时，直接拿到之前保存的元素对象即可。代码和效果如下：</p><p><img src="'+Rs+'" alt="image-20240805094621228"></p><p>我们想自己控制DOM元素的获取(点击按钮后)，而不是在页面渲染完成后，直接调用回调函数并获取到DOM元素。代码和效果如下：</p><p><img src="'+vs+'" alt="image-20240805095305181"></p><h4 id="b-获取类组件实例" tabindex="-1"><a class="header-anchor" href="#b-获取类组件实例" aria-hidden="true">#</a> B）获取类组件实例</h4><p><img src="'+Ms+'" alt="image-20240805092013978"></p><p>使用ref获取组件实例，并调用子组件中的方法。带么和效果如下：</p><p><img src="'+As+'" alt="image-20240805101215050"></p><h4 id="c-获取函数式组件" tabindex="-1"><a class="header-anchor" href="#c-获取函数式组件" aria-hidden="true">#</a> C）获取函数式组件</h4><p><img src="'+Bs+'" alt="image-20240805110929852"></p><p>函数式组件是没有实例的，所以无法通过ref获取他们的实例。但是某些时候，我们可能想要获取函数式组件中的某个DOM元素。这个时候我们可以通过 React.forwardRef ，后面我们也会学习 hooks 中如何使用ref。</p><p><img src="'+ks+'" alt="image-20240805110721653"></p><p>我们有时候可能只是想获取函数式组件中的某个DOM元素，因此我们应该怎么做？使用forwardRef高阶函数，代码和效果如下：</p><p><img src="'+Ds+'" alt="image-20240805111729521"></p><h3 id="_3-受控和非受控组件" tabindex="-1"><a class="header-anchor" href="#_3-受控和非受控组件" aria-hidden="true">#</a> 3，受控和非受控组件</h3><p><img src="'+ys+'" alt="image-20240805092054012"></p><p>我们通过监听change事件，获取input框中输入的数据，代码和效果如下：</p><p><img src="'+Os+'" alt="image-20240805112930078"></p><p>一旦我们给一个表单元素绑定value属性，那么就不能在输入框中输入内容，因为此时该输入框为非受控组件。代码和效果如下：</p><p><img src="'+Js+'" alt="image-20240805114003238"></p><p>我们如何解决输入框中不能输入内容？监听onChange事件，使该输入框变成一个受控组件。代码和效果如下：</p><p><img src="'+Hs+'" alt="image-20240805114640532"></p><h3 id="_4-react的高阶组件" tabindex="-1"><a class="header-anchor" href="#_4-react的高阶组件" aria-hidden="true">#</a> 4，React的高阶组件</h3><h4 id="a-什么是高阶组件" tabindex="-1"><a class="header-anchor" href="#a-什么是高阶组件" aria-hidden="true">#</a> A）什么是高阶组件</h4><p><img src="'+Ts+'" alt="image-20240926233653117"></p><p><img src="'+Xs+'" alt="image-20240926233724253"></p><p>高阶组件的定义：</p><ul><li>高阶组件本身不是一个组件，而是一个函数。</li><li>特点： <ol><li>接收一个组件作为它的参数。</li><li>返回一个新的组件。</li></ol></li></ul><p>定义一个高阶组件并使用之，如下：</p><p><img src="'+ws+'" alt="image-20240927000133871"></p><h4 id="b-应用场景一-props的增强" tabindex="-1"><a class="header-anchor" href="#b-应用场景一-props的增强" aria-hidden="true">#</a> B）应用场景一: props的增强</h4><p><img src="'+Ns+'" alt="image-20240927072541917"></p><p>不修改原有代码的情况下，添加新的props。</p><p>第一步：定义一个高阶组件并注入数据，操作如下：</p><p><img src="'+Ps+'" alt="image-20240927080654788"></p><p>第二步：使用高阶组件(传入函数式组件)，并使用注入的数据。操作和效果如下：</p><p><img src="'+Ws+'" alt="image-20240927081029668"></p><p>第三步：使用高阶组件(传入类组件)，并使用注入的数据。操作入如下：</p><p><img src="'+Es+'" alt="image-20240927081919471"></p><p><img src="'+Us+'" alt="image-20240927082102825"></p><p>第四步：如果在使用高阶组件时，也通过自定义属性向参数组件传入了数据。那么如何获取并使用呢？操作如下：</p><p><img src="'+Is+'" alt="image-20240929230757562"></p><p><img src="'+Vs+'" alt="image-20240929230947746"></p><p><img src="'+Fs+'" alt="image-20240929231018994"></p><h4 id="b-应用常见二-context" tabindex="-1"><a class="header-anchor" href="#b-应用常见二-context" aria-hidden="true">#</a> B）应用常见二：Context</h4><p>通过Cotext可以实现在组件树中实现数据共享，但是每次获取Context提供的数据很麻烦。</p><p>第一步：获取Contex提供的数据。操作如下：</p><p><img src="'+Ls+'" alt="image-20240929233711660"></p><p>第二步：在Product组件中消费ThemContext提供的数据，操作如下：</p><p><img src="'+Ys+'" alt="image-20240929233948647"></p><p>第三步：编写一个高阶组件withTheme，在这个高阶组件中，通过Consumer组件获取数据，并通过自定义属性的方式向传入的组件传递数据。操作如下：</p><p><img src="'+Gs+'" alt="image-20240930000010753"></p><p>第四步：查看效果。</p><p><img src="'+qs+'" alt="image-20240930000027589"></p><h4 id="c-应用场景三-渲染判断鉴权" tabindex="-1"><a class="header-anchor" href="#c-应用场景三-渲染判断鉴权" aria-hidden="true">#</a> C）应用场景三：渲染判断鉴权</h4><p><img src="'+zs+'" alt="image-20240929231402478"></p><p>在开发中，我们可能遇到这样的场景：</p><ul><li>某些页面是必须用户登录成功才能进行进入；</li><li>如果用户没有登录成功，那么直接跳转到登录页面；</li></ul><p>这个时候，我们就可以使用高阶组件来完成鉴权操作。</p><p>第一步：创建Cart组件，在App组件中定义状态IsLogin来控制Cart组件的展示或隐藏。操作如下：</p><p><img src="'+Ks+'" alt="image-20240930001139434"></p><p>第二步：编写一个高阶组件。根据是否有token渲染不同内容。操作如下：</p><p><img src="'+Qs+'" alt="image-20240930003534210"></p><p>第三步：如果没有状态isLogin，在我们点击按钮存入token时，如何做到页面刷新？操作如下：</p><p><img src="'+Zs+'" alt="image-20240930074902337"></p><p>第四步：点击登录按钮查看效果，操作如下：</p><p><img src="'+$s+'" alt="image-20240930075145718"></p><h4 id="d-场景四-生命周期劫持" tabindex="-1"><a class="header-anchor" href="#d-场景四-生命周期劫持" aria-hidden="true">#</a> D）场景四-生命周期劫持</h4><p><img src="'+ae+'" alt="image-20240930075339991"></p><p>我们也可以利用高阶函数来劫持生命周期，在生命周期中完成自己的逻辑。</p><p>第一步：使用钩子函数我们可以知道一个页面的渲染时间，操作如下：</p><p><img src="'+ie+'" alt="image-20240930080839828"></p><p>第二步：由于其他页面可能也会使用到这个功能，因此我们可以封装一个高阶组件。操作如下：</p><p><img src="'+se+'" alt="image-20240930081557266"></p><p>第三步：如果一个组件想知道页面渲染所花费的时间，我们导入并使用。代码和效果如下：</p><p><img src="'+ee+'" alt="image-20240930081805732"></p><p>第四步：额外知识补充，就像匿名函数一样，class关键字后的类名可以省略。并且无论是类组件还是函数式组件都可以通过类名/函数名.name属性获取到组件名称。操作如下：</p><p><img src="'+te+'" alt="image-20240930082634270"></p><h4 id="e-高阶组件-函数-的意义" tabindex="-1"><a class="header-anchor" href="#e-高阶组件-函数-的意义" aria-hidden="true">#</a> E）高阶组件(函数)的意义</h4><p><img src="'+pe+'" alt="image-20240930082811327"></p><ul><li>我们会发现利用高阶组件可以针对某些React代码进行更加优雅的处理。</li><li>其实早期的React有提供组件之间的一种复用方式是mixin，目前已经不再建议使用： <ul><li>Mixin 可能会相互依赖，相互耦合，不利于代码维护；</li><li>不同的Mixin中的方法可能会相互冲突；</li></ul></li><li>当然，HOC也有自己的一些缺陷： <ul><li>HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难；</li><li>HOC可以劫持props，在不遵守约定的情况下也可能造成冲突；</li></ul></li><li>Hooks的出现，是开创性的，它解决了很多React之前的存在的问题 <ul><li>比如this指向问题、比如hoc的嵌套复杂度问题等等；</li></ul></li></ul><h3 id="_5-portals和fragment" tabindex="-1"><a class="header-anchor" href="#_5-portals和fragment" aria-hidden="true">#</a> 5，portals和fragment</h3><h4 id="a-portals的使用" tabindex="-1"><a class="header-anchor" href="#a-portals的使用" aria-hidden="true">#</a> A）Portals的使用</h4><p><img src="'+ge+'" alt="image-20240930110718051"></p><p>第一步：我们在根组件App中书写的jsx，默认是被渲染在#root中的。操作如下：</p><p><img src="'+ne+'" alt="image-20240930112314593"></p><p>第二步：通过React提供的portals，我们可以将jsx渲染到任意位置。操作如下：</p><p><img src="'+re+'" alt="image-20240930112806858"></p><p>第三步：查看效果如下：</p><p><img src="'+me+'" alt="image-20240930112926128"></p><h4 id="b-portals案例" tabindex="-1"><a class="header-anchor" href="#b-portals案例" aria-hidden="true">#</a> B）Portals案例</h4><p><img src="'+ce+'" alt="image-20240930113457730"></p><p>封装一个Modal组件，所有传递给Modal标签内的子元素，会被渲染到指定位置。</p><p>第一步：封装Modal组件，在App组件中导入并使用。操作如下：</p><p><img src="'+oe+'" alt="image-20240930115045193"></p><p><img src="'+de+'" alt="image-20240930115136818"></p><p>第二步：查看效果如下：</p><p><img src="'+_e+'" alt="image-20240930115237791"></p><h4 id="c-fragment" tabindex="-1"><a class="header-anchor" href="#c-fragment" aria-hidden="true">#</a> C）fragment</h4><p><img src="'+le+'" alt="image-20240930115402391"></p><p>第一步：在组件的render函数returnjsx时，必须要有一个根元素，否则会报错。因此我们会使用一个多余的div元素进行包裹。操作如下：</p><p><img src="'+he+'" alt="image-20240930120146908"></p><p>第二步：想让代码不报错，且根元素不被渲染在页面上，我们可以使用Fragment。操作如下：</p><p><img src="'+xe+'" alt="image-20240930120622925"></p><p>第三步：Fragment还有一种语法糖的写法，使用空标签。操作如下：</p><p><img src="'+je+'" alt="image-20240930121120020"></p><p>第四步：注意特殊情况不能使用Fragment的语法糖。操作如下：</p><p><img src="'+be+'" alt="image-20240930122001156"></p><p><img src="'+fe+'" alt="image-20240930122131007"></p><h3 id="_6-strictmode严格模式" tabindex="-1"><a class="header-anchor" href="#_6-strictmode严格模式" aria-hidden="true">#</a> 6，StrictMode严格模式</h3><h4 id="a-什么时严格模式" tabindex="-1"><a class="header-anchor" href="#a-什么时严格模式" aria-hidden="true">#</a> A）什么时严格模式？</h4><p><img src="'+ue+'" alt="image-20240930122934984"></p><h4 id="b-严格模式检查什么" tabindex="-1"><a class="header-anchor" href="#b-严格模式检查什么" aria-hidden="true">#</a> B）严格模式检查什么</h4><p><img src="'+Se+'" alt="image-20240930123812037"></p><p>局部开启严格模式，操作如下：</p><p><img src="'+Ce+'" alt="image-20240930124349421"></p><p>严格模式检测一：识别不安全的生命周期，操作如下：</p><p><img src="'+Re+'" alt="image-20240930124523030"></p><p>严格模式检测二：使用过时的ref API，操作如下：</p><p><img src="'+ve+'" alt="image-20240930124943535"></p><p><img src="'+Me+'" alt="image-20240930125406730"></p><p>严格模式检测三：检查意外的副作用。如下：</p><p><img src="'+Ae+'" alt="image-20240930135311739"></p><p>严格模式检测四：使用废弃的findDOMNode方法。操作如下：</p><p><img src="'+Be+'" alt="image-20240930135627417"></p><p>严格模式检测五：使用过时的Context API。</p><h2 id="七、react的过渡动画" tabindex="-1"><a class="header-anchor" href="#七、react的过渡动画" aria-hidden="true">#</a> 七、React的过渡动画</h2><h3 id="_1-react的过渡动画" tabindex="-1"><a class="header-anchor" href="#_1-react的过渡动画" aria-hidden="true">#</a> 1，React的过渡动画</h3><h4 id="a-react-transition-group介绍" tabindex="-1"><a class="header-anchor" href="#a-react-transition-group介绍" aria-hidden="true">#</a> A）react-transition-group介绍</h4><p><img src="'+ke+'" alt="image-20240930144054891"></p><ul><li>在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验。</li><li>当然，我们可以通过原生的CSS来实现这些过渡动画，但是React社区为我们提供了react-transition-group用来完成过渡动画。</li><li>React曾为开发者提供过动画插件 react-addons-css-transition-group，后由社区维护，形成了现在的 react-transition-group。</li></ul><p>第一步：安装react-transition-group。操作如下：</p><p><img src="'+De+'" alt="image-20240930144721231"></p><p>第二步：搭建基本结构，操作如下：</p><p><img src="'+ye+'" alt="image-20240930145702523"></p><h4 id="b-主要组件" tabindex="-1"><a class="header-anchor" href="#b-主要组件" aria-hidden="true">#</a> B）主要组件</h4><p><img src="'+Oe+'" alt="image-20240930144116663"></p><h3 id="_2-csstransition的使用" tabindex="-1"><a class="header-anchor" href="#_2-csstransition的使用" aria-hidden="true">#</a> 2，CSSTransition的使用</h3><p><img src="'+Je+'" alt="image-20240930144149304"></p><p>使用CSSTransition组件实现动画。</p><p>操作一：搭建基本结构，操作如下：</p><p><img src="'+He+'" alt="image-20240930155428394"></p><p>第二步：进入动画已经实现完成，点击按钮查看效果如下：</p><p><img src="'+Te+'" alt="image-20240930155732119"></p><p>第三步：添加离开动画的类名，实现元素离开时的动画效果。操作如下：</p><p><img src="'+Xe+'" alt="image-20240930160415538"></p><p>第四步：点击按钮使元素隐藏，查看离开动画效果如下：</p><p><img src="'+we+'" alt="image-20240930160640025"></p><p>第五步：如果组件CSSTransition的属性timeout时间和CSS的transition时间不一致会怎么样？</p><p><img src="'+Ne+'" alt="image-20240930161939728"></p><p>第六步：如果控制显示和隐藏的状态初始值为true，那么页面一上来进行展示不会有动画效果。如果我们希望页面一上来进行展示对应元素时，也有对应的动画效果，该怎么办？</p><p><img src="'+Pe+'" alt="image-20240930163410114"></p><p>第七步：如果我们希望初次渲染和进入时，保持一样的效果，我们可以使用并集选择器。操作如下：</p><p><img src="'+We+'" alt="image-20240930163714871"></p><h3 id="_3-常见的属性设置" tabindex="-1"><a class="header-anchor" href="#_3-常见的属性设置" aria-hidden="true">#</a> 3，常见的属性设置</h3><p><img src="'+Ee+'" alt="image-20240930160737205"></p><p><img src="'+Ue+'" alt="image-20240930164737546"></p><h3 id="_4-switchtransition" tabindex="-1"><a class="header-anchor" href="#_4-switchtransition" aria-hidden="true">#</a> 4，SwitchTransition</h3><p><img src="'+Ie+'" alt="image-20240930163815898"></p><p>使用SwitchTransition组件可以做到一个组件展示，另一个组件隐藏的动画效果。</p><p>第一步：搭建基本结构，可以看到在我们点击按钮，按钮的内容发生了变化。但是并没有动画效果，操作如下：</p><p><img src="'+Ve+'" alt="image-20240930220941039"></p><p>第二步：定义进入动画和离开动画的类名</p><p><img src="'+Fe+'" alt="image-20240930222904589"></p><p>第三步：使用SwitchTransition和CSSTransition组件实现动画效果。操作如下：</p><p><img src="'+Le+'" alt="image-20240930223429369"></p><p>第四步：点击按钮，查看动画效果。操作如下：</p><p><img src="'+Ye+'" alt="image-20240930223649884"></p><h3 id="_5-transitiongroup" tabindex="-1"><a class="header-anchor" href="#_5-transitiongroup" aria-hidden="true">#</a> 5，TransitionGroup</h3><p><img src="'+Ge+'" alt="image-20240930163845890"></p><p>需求：根据状态books动态渲染书籍列表，我们希望点击按钮新增书籍信息，并且有动画效果。</p><p>第一步：搭建基本结构，操作如下：</p><p><img src="'+qe+'" alt="image-20240930225643748"></p><p>第二步：引入TransitionGroup组件，并用其包裹渲染的列表数据。操作如下：</p><p><img src="'+ze+'" alt="image-20240930230241831"></p><p><img src="'+Ke+'" alt="image-20240930230626594"></p><p>第三步：导入CSSTransition组件，定义动画类名并添加做动画必要的属性。操作如下：</p><p><img src="'+Qe+'" alt="image-20240930231452733"></p><p>第四步：点击按钮添加新的书籍，查看动画效果。操作如下：</p><p><img src="'+Ze+'" alt="image-20240930231611085"></p><p>我们希望每一条书籍信息后面有一个删除按钮，点击按钮删除该条书籍信息的同时有动画效果。</p><p>第一步：修改之间的代码并添加删除书籍的点击事件，操作如下：</p><p><img src="'+$e+'" alt="image-20240930233507018"></p><p>第二步：定义离开动画的类名，操作如下：</p><p><img src="'+at+'" alt="image-20240930233840751"></p><p>第三步：点击删除按钮，查看动画效果。操作如下：</p><p><img src="'+it+'" alt="image-20240930234021312"></p><h2 id="八-react中编写css" tabindex="-1"><a class="header-anchor" href="#八-react中编写css" aria-hidden="true">#</a> 八，React中编写CSS</h2><h3 id="_1-react中css概述" tabindex="-1"><a class="header-anchor" href="#_1-react中css概述" aria-hidden="true">#</a> 1，React中CSS概述</h3><p><img src="'+st+'" alt="image-20241001155557563"></p><p><img src="'+et+'" alt="image-20241001155630874"></p><h3 id="_2-内联样式css写法" tabindex="-1"><a class="header-anchor" href="#_2-内联样式css写法" aria-hidden="true">#</a> 2，内联样式CSS写法</h3><p><img src="'+tt+'" alt="image-20241001164458728"></p><p>内联样式的优点：</p><ol><li>内联样式, 样式之间不会有冲突</li><li>可以动态获取当前state中的状态</li></ol><p>内联样式的缺点：</p><ol><li>写法上都需要使用驼峰标识</li><li>某些样式没有提示</li><li>大量的样式, 代码混乱</li><li>某些样式无法编写(比如伪类/伪元素)</li></ol><p>在React中使用内联样式编写CSS，操作如下：</p><p><img src="'+pt+'" alt="image-20241001175244456"></p><h3 id="_3-普通css文件写法" tabindex="-1"><a class="header-anchor" href="#_3-普通css文件写法" aria-hidden="true">#</a> 3，普通CSS文件写法</h3><p><img src="'+gt+'" alt="image-20241001175319859"></p><ul><li>普通的css我们通常会编写到一个单独的文件，之后再进行引入。</li><li>这样的编写方式和普通的网页开发中编写方式是一致的：</li><li>这种编写方式最大的问题是样式之间会相互层叠掉；</li></ul><h3 id="_4-css-module写法" tabindex="-1"><a class="header-anchor" href="#_4-css-module写法" aria-hidden="true">#</a> 4，CSS Module写法</h3><p><img src="'+nt+'" alt="image-20241001180351914"></p><p>CSS Modules的缺点：</p><ul><li>引用的类名，不能使用连接符(.home-title)，在JavaScript中是不识别的；</li><li>所有的className都必须使用{style.className} 的形式来编写；</li><li>不方便动态来修改某些样式，依然需要使用内联样式的方式；</li></ul><p>在React中使用CSS Module编写CSS样式，操作如下：</p><p><img src="'+rt+'" alt="image-20241001181545577"></p><h3 id="_5-react中使用less" tabindex="-1"><a class="header-anchor" href="#_5-react中使用less" aria-hidden="true">#</a> 5，React中使用Less</h3><p>第一步；搭建基本结构，书写less代码并引入。操作如下：</p><p><img src="'+mt+'" alt="image-20241001224415613"></p><p><img src="'+ct+'" alt="image-20241001224548670"></p><p>第二步：我们需要修改项目的webpack配置，需要使用到一个包craco。安装如下：</p><p><img src="'+ot+'" alt="image-20241001225323869"></p><p>第三步：在项目根目录创建一个craco.config.js配置文件，粘贴配合代码。并安装craco-less。操作如下：</p><p><img src="'+dt+'" alt="image-20241001233249747"></p><p><img src="'+_t+'" alt="image-20241001233431381"></p><p>第四步：修改启动脚本，查看效果。操作如下：</p><p><img src="'+lt+'" alt="image-20241001233600981"></p><p><img src="'+ht+'" alt="image-20241001233633355"></p><h3 id="_6-css-in-js解决方案" tabindex="-1"><a class="header-anchor" href="#_6-css-in-js解决方案" aria-hidden="true">#</a> 6，CSS in JS解决方案</h3><p><img src="'+xt+'" alt="image-20241001181607134"></p><p><img src="'+jt+'" alt="image-20241001235437860"></p><h4 id="a-基本使用" tabindex="-1"><a class="header-anchor" href="#a-基本使用" aria-hidden="true">#</a> A）基本使用</h4><p><img src="'+bt+'" alt="image-20241002075039608"></p><p>第一步：安装styled-components，操作如下：</p><p><img src="'+ft+'" alt="image-20241001235953833"></p><p>第二步：搭建基本结构，操作如下：</p><p><img src="'+ut+'" alt="image-20241002000802607"></p><p>第三步：使用styled-components，操作如下：</p><p><img src="'+St+'" alt="image-20241002002926331"></p><p>第四步：打开浏览器查看效果，如下：</p><p><img src="'+Ct+'" alt="image-20241002003139831"> 第五步：为了方式样式嵌套过深，我们可以将子元素的样式单独抽取到一个样式组件中，操作如下：</p><p><img src="'+Rt+'" alt="image-20241002104429767"></p><p><img src="'+vt+'" alt="image-20241002104459992"></p><h4 id="b-props、attrs属性" tabindex="-1"><a class="header-anchor" href="#b-props、attrs属性" aria-hidden="true">#</a> B）props、attrs属性</h4><p><img src="'+Mt+'" alt="image-20241002092002146"></p><p>与less和CSS Module不同的是，我们可以通过js使用state中的变量。</p><p>第一步：定义控制字体大小和文字颜色的状态，传递给样式组件并在样式中引入。操作如下：</p><p><img src="'+At+'" alt="image-20241002113131609"></p><p>第二步：打开页面查看效果，操作如下：</p><p><img src="'+Bt+'" alt="image-20241002113228287"></p><p>第三步：添加一个按钮，可以动态控制文字颜色。操作如下：</p><p><img src="'+kt+'" alt="image-20241002114506790"></p><p>第四步：我们可以给样式组件的某个自定义属性一个默认值，这样在没有传递数据时，可以使用默认值作为css属性的值。操作如下：</p><p><img src="'+Dt+'" alt="image-20241002115642648"></p><p><img src="'+yt+'" alt="image-20241002115904812"></p><p>第五步：我们还可以给样式组件的某个自定义属性设置默认值。操作如下：</p><p><img src="'+Ot+'" alt="image-20241002155528409"></p><p>第六步：查看效果，操作如下：</p><p><img src="'+Jt+'" alt="image-20241002160109385"></p><h4 id="c-styled中使用变量" tabindex="-1"><a class="header-anchor" href="#c-styled中使用变量" aria-hidden="true">#</a> C）styled中使用变量</h4><p>我们可以在项目根目录创建/style/variablesjs文件，用于存储控制样式的变量。我们可以在其中定义一些全局的的css样式。例如：主题颜色、字体大小等。</p><p>第一步：创建variables.js文件，并定义一下用于控制CSS属性的变量。操作如下：</p><p><img src="'+Ht+'" alt="image-20241002132148101"></p><p>第二步：打开浏览器查看效果如下：</p><p><img src="'+Tt+'" alt="image-20241002132429644"></p><h4 id="c-styled高级特性" tabindex="-1"><a class="header-anchor" href="#c-styled高级特性" aria-hidden="true">#</a> C）styled高级特性</h4><p><img src="'+Xt+'" alt="image-20241002130951211"></p><p>我们还可以通过styled-components设置主题。</p><p>第一步：使用ThemeProvider组件，通过自定义属性提供数据。操作如下：</p><p><img src="'+wt+'" alt="image-20241002151102643"></p><p>第二步：创建Home文件夹，并在该文件夹下创建index.jsx和style.js并搭建基本结构。操作如下:</p><p><img src="'+Nt+'" alt="image-20241002151537147"></p><p>第三步：在App组件中引入Home组件，并打开浏览器查看效果。操作如下：</p><p><img src="'+Pt+'" alt="image-20241002151818667"></p><p>我们还可以使用styled-component实现继承。</p><p>第一步：使用styled(HYButton)继承HYButton的样式。操作如下：</p><p><img src="'+Wt+'" alt="image-20241002161049690"></p><p>第二步：在Home组件中使用HYButtonWrapper样式组件，并查看效果。操作如下：</p><p><img src="'+Et+'" alt="image-20241002161322104"></p><h3 id="_6-classnames库使用" tabindex="-1"><a class="header-anchor" href="#_6-classnames库使用" aria-hidden="true">#</a> 6，classnames库使用</h3><p><img src="'+Ut+'" alt="image-20241002161407248"></p><p><img src="'+It+'" alt="image-20241002161434505"></p><p>我们如果需要动态控制是否添加类名可以使用三元运算符，操作如下：</p><p><img src="'+Vt+'" alt="image-20241002162316502"></p><p><img src="'+Ft+'" alt="image-20241002162643492"></p><p><img src="'+Lt+'" alt="image-20241002163224632"></p><p>我们可以借助一个库classnames，来帮我们管理类名。</p><p>第一步：安装classnames，操作如下：</p><p><img src="'+Yt+'" alt="image-20241002163824546"></p><p>第二步：导入classnames并使用，操作如下：</p><p><img src="'+Gt+'" alt="image-20241002171842701"></p><h2 id="九-react-hook解析" tabindex="-1"><a class="header-anchor" href="#九-react-hook解析" aria-hidden="true">#</a> 九，React Hook解析</h2><h3 id="_1-认识和体验hooks" tabindex="-1"><a class="header-anchor" href="#_1-认识和体验hooks" aria-hidden="true">#</a> 1，认识和体验Hooks</h3><p><img src="'+qt+'" alt="image-20240805201809118"></p><p><img src="'+zt+'" alt="image-20240805201844036"></p><p><img src="'+Kt+'" alt="image-20240805201902265"></p><p><img src="'+Qt+'" alt="image-20240805201925411"></p><h3 id="_2-state和effect" tabindex="-1"><a class="header-anchor" href="#_2-state和effect" aria-hidden="true">#</a> 2，State和Effect</h3><h3 id="_3-context和reducer" tabindex="-1"><a class="header-anchor" href="#_3-context和reducer" aria-hidden="true">#</a> 3，Context和Reducer</h3><h3 id="_4-callback和memo" tabindex="-1"><a class="header-anchor" href="#_4-callback和memo" aria-hidden="true">#</a> 4，Callback和Memo</h3><h3 id="_5-ref和layouteffect" tabindex="-1"><a class="header-anchor" href="#_5-ref和layouteffect" aria-hidden="true">#</a> 5，Ref和LayoutEffect</h3><h3 id="_6-自定义hooks使用" tabindex="-1"><a class="header-anchor" href="#_6-自定义hooks使用" aria-hidden="true">#</a> 6，自定义Hooks使用</h3>',957),ap=[$t];function ip(sp,ep){return i(),s("div",null,ap)}const pp=a(Zt,[["render",ip],["__file","20.html.vue"]]);export{pp as default};
