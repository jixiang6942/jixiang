import{_ as t,r as g,o as n,c as r,b as i,d as a,e as p,a as s}from"./app-382cdfb3.js";const m="/jixiang/assets/image-20240221151400904-eab0884d.png",c="/jixiang/assets/image-20240221151432190-d47785df.png",o="/jixiang/assets/image-20240221151502231-c37e5ca0.png",d="/jixiang/assets/image-20240221151532883-12dc23d9.png",_="/jixiang/assets/image-20240221151603407-1c66d406.png",h="/jixiang/assets/image-20240221151633802-cd8f5f4a.png",l="/jixiang/assets/image-20240221151656752-ec62b98b.png",x="/jixiang/assets/image-20240221151747988-f9a6be16.png",b="/jixiang/assets/image-20240221151820990-8dcc0ce5.png",j="/jixiang/assets/image-20240221151905873-69ad67b4.png",f="/jixiang/assets/image-20240221151938685-f5dacac4.png",u="/jixiang/assets/image-20240221152016329-6aaf4c4c.png",y="/jixiang/assets/image-20240723201851292-803706bf.png",T="/jixiang/assets/image-20240723202104964-f7c54278.png",S="/jixiang/assets/image-20240723202547399-65dba931.png",k="/jixiang/assets/image-20240723202634108-f44437e6.png",v="/jixiang/assets/image-20240221152040797-046ce4ce.png",w="/jixiang/assets/image-20240221152102809-79b4f634.png",B="/jixiang/assets/image-20240723212734514-68c69254.png",A="/jixiang/assets/image-20240723213010693-0ac592d1.png",C="/jixiang/assets/image-20240221152122443-b0b31bfb.png",E="/jixiang/assets/image-20240221152339864-d97fcde8.png",R="/jixiang/assets/image-20230904082746501-69506b2a.jpeg",J="/jixiang/assets/image-20240221153110696-aef88c44.png",D="/jixiang/assets/image-20240723214433493-635b419c.png",I="/jixiang/assets/image-20240221153600538-ac46a157.png",P="/jixiang/assets/image-20240221153704828-32671f15.png",N="/jixiang/assets/image-20240221153759122-6e542f80.png",q="/jixiang/assets/image-20240221153852719-4cfc0d45.png",M="/jixiang/assets/image-20240221153938623-3a37bd24.png",K="/jixiang/assets/image-20240723215446227-73f81b32.png",V="/jixiang/assets/image-20240723215904353-40d46657.png",L="/jixiang/assets/image-20240221154209698-db4acb4a.png",O="/jixiang/assets/image-20240723220514191-521bb1f3.png",U="/jixiang/assets/image-20240221154337947-44b7a1b5.png",F="/jixiang/assets/image-20240221154435570-641f674e.png",H="/jixiang/assets/image-20240221154528763-5806b9e2.png",z="/jixiang/assets/image-20240723221651491-937dcbb8.png",G="/jixiang/assets/image-20240723224003277-3b9d7885.png",W="/jixiang/assets/image-20240221154637678-118a97d5.png",Q="/jixiang/assets/image-20230904102852066-23d3ba1a.jpeg",X="/jixiang/assets/image-20230904101947474-8cf312ea.jpeg",Y="/jixiang/assets/image-20240221154858066-5581514f.png",Z="/jixiang/assets/image-20240723224632265-a934e624.png",$="/jixiang/assets/image-20230904124859991-e93ca946.jpeg",a2="/jixiang/assets/image-20240221155053835-fdd1e0df.png",i2="/jixiang/assets/image-20240723225437906-8dfd6e12.png",s2="/jixiang/assets/image-20240221155200142-dbb348f0.png",e2="/jixiang/assets/image-20230904130231339-3a781a94.jpeg",p2="/jixiang/assets/image-20240221155532043-ded4dec7.png",t2="/jixiang/assets/image-20240723225909308-3e15a46b.png",g2="/jixiang/assets/image-20240723230448512-b6b9df53.png",n2="/jixiang/assets/image-20240221155816584-4e7da4fd.png",r2="/jixiang/assets/image-20240723231047267-97e69f1b.png",m2="/jixiang/assets/image-20240723231446290-f7a466a9.png",c2="/jixiang/assets/image-20240221155905527-2558372d.png",o2="/jixiang/assets/image-20240723232104685-62108f62.png",d2="/jixiang/assets/image-20240723232310451-bbdb19e4.png",_2="/jixiang/assets/image-20240723234215917-38dea8b3.png",h2="/jixiang/assets/image-20240723235047497-825ff307.png",l2="/jixiang/assets/image-20240221160020601-1ade3a95.png",x2="/jixiang/assets/image-20240724081503018-622c0f05.png",b2="/jixiang/assets/image-20240724081948089-f26d7fd3.png",j2="/jixiang/assets/image-20240724084552671-76a2d569.png",f2="/jixiang/assets/image-20240221160134335-c11b615c.png",u2="/jixiang/assets/image-20240724120540395-2f95d811.png",y2="/jixiang/assets/image-20240221160212740-952eee2a.png",T2="/jixiang/assets/image-20240724200355472-2c41b10b.png",S2="/jixiang/assets/image-20230904181505657-e57c08db.jpeg",k2="/jixiang/assets/image-20240221163604369-b9edb334.png",v2="/jixiang/assets/image-20240221163720520-260dc3ea.png",w2="/jixiang/assets/image-20240724201204426-07dcc327.png",B2="/jixiang/assets/image-20240724201503047-05bc46a8.png",A2="/jixiang/assets/image-20240221164024302-4a7a5e58.png",C2="/jixiang/assets/image-20240724202102160-7689d705.png",E2="/jixiang/assets/image-20240724202331714-6d3b901e.png",R2="/jixiang/assets/image-20240221164241530-b23a5879.png",J2="/jixiang/assets/image-20240724203708583-1598120a.png",D2="/jixiang/assets/image-20240221164412327-64a6a78e.png",I2="/jixiang/assets/image-20240724204245855-f80ba5ef.png",P2="/jixiang/assets/image-20240724214403075-f20a81ca.png",N2="/jixiang/assets/image-20240724214559244-d160ea3b.png",q2="/jixiang/assets/image-20240724214800164-719c08c2.png",M2="/jixiang/assets/image-20240724214948870-afa10da3.png",K2="/jixiang/assets/image-20240221163900629-c3e8b056.png",V2="/jixiang/assets/image-20240221164727839-1f8376b2.png",L2="/jixiang/assets/image-20240724215547289-3f470cf8.png",O2="/jixiang/assets/image-20240724215812408-b612bafe.png",U2="/jixiang/assets/image-20240221164939075-cb43b344.png",F2="/jixiang/assets/image-20240724220542336-2d3ce4f5.png",H2="/jixiang/assets/image-20240724220929125-87de8731.png",z2="/jixiang/assets/image-20240724221412265-4e8d95ec.png",G2="/jixiang/assets/image-20240724221637732-d055e1e2.png",W2="/jixiang/assets/image-20240221165034267-1385ad2c.png",Q2="/jixiang/assets/image-20240724222339362-3e5c2a9d.png",X2="/jixiang/assets/image-20240724222525353-9e2af14d.png",Y2="/jixiang/assets/image-20240724222839571-771f9cd7.png",Z2="/jixiang/assets/image-20240221165152939-6ddc2369.png",$2="/jixiang/assets/image-20240724223313584-a5c7c2fe.png",aa="/jixiang/assets/image-20240724223939375-6bd77ca9.png",ia="/jixiang/assets/image-20240724224255536-4ed07109.png",sa="/jixiang/assets/image-20230904234613495-97bd3ed5.jpeg",ea="/jixiang/assets/image-20240221165329680-84f66701.png",pa="/jixiang/assets/image-20240724232437689-4926321e.png",ta="/jixiang/assets/image-20240724234348084-0a6079da.png",ga="/jixiang/assets/image-20240724234656364-26adeb3b.png",na="/jixiang/assets/image-20240725000258120-19cac2b0.png",ra="/jixiang/assets/image-20240221165445629-bce9eea4.png",ma="/jixiang/assets/image-20240221165549370-95c8ccad.png",ca="/jixiang/assets/image-20240725001218800-6da9403b.png",oa="/jixiang/assets/image-20240221165745273-2526b032.png",da="/jixiang/assets/image-20240725001459263-79f092eb.png",_a="/jixiang/assets/image-20230905073926149-68b5b46d.jpeg",ha="/jixiang/assets/image-20240221165901503-390ac612.png",la="/jixiang/assets/image-20240725001909650-595c4471.png",xa="/jixiang/assets/image-20240221170008043-8ec81d1a.png",ba="/jixiang/assets/image-20240725002608363-3d3c402d.png",ja="/jixiang/assets/image-20240221170424524-0d8f8e09.png",fa="/jixiang/assets/image-20240221170528801-f33d58df.png",ua="/jixiang/assets/image-20240725075636204-993577fb.png",ya="/jixiang/assets/image-20240725080353810-03319553.png",Ta="/jixiang/assets/image-20240725080601799-37d9ca1b.png",Sa="/jixiang/assets/image-20240725092843288-e10bd760.png",ka="/jixiang/assets/image-20240725093111058-0eb332b7.png",va="/jixiang/assets/image-20240725093335178-3b7d777f.png",wa="/jixiang/assets/image-20240221170717489-eb56856f.png",Ba="/jixiang/assets/image-20240725101234112-535de028.png",Aa="/jixiang/assets/image-20240725102106056-82598c89.png",Ca="/jixiang/assets/image-20240222143837199-819b6ee8.png",Ea="/jixiang/assets/image-20240725103609624-fc5dea25.png",Ra="/jixiang/assets/image-20240725130303394-967cb39c.png",Ja="/jixiang/assets/image-20240221170953033-cd372070.png",Da="/jixiang/assets/image-20240726075027581-27f11f7b.png",Ia="/jixiang/assets/image-20240221171129278-39f6b140.png",Pa="/jixiang/assets/image-20240726075426733-94df39a3.png",Na="/jixiang/assets/image-20240726075827456-76e21207.png",qa="/jixiang/assets/image-20240221171324520-a3f4d96c.png",Ma="/jixiang/assets/image-20240726081840262-121dd5fb.png",Ka="/jixiang/assets/image-20240221171425361-b0c0fa48.png",Va="/jixiang/assets/image-20240726092156981-f516b221.png",La="/jixiang/assets/image-20240221171531964-9e6ceb96.png",Oa="/jixiang/assets/image-20240726092553690-332ecc87.png",Ua="/jixiang/assets/image-20240726092815799-b6f19879.png",Fa="/jixiang/assets/image-20240726093037554-004c5e03.png",Ha="/jixiang/assets/image-20240726093657253-18467ad6.png",za="/jixiang/assets/image-20240221171703389-82e405e3.png",Ga="/jixiang/assets/image-20240726094251694-f962fac6.png",Wa="/jixiang/assets/image-20240726094516064-689ed142.png",Qa="/jixiang/assets/image-20240726094721705-74217858.png",Xa="/jixiang/assets/image-20240221172055563-3d1c5621.png",Ya="/jixiang/assets/image-20240726105322924-80afc01b.png",Za="/jixiang/assets/image-20240726105633325-94370bd6.png",$a="/jixiang/assets/image-20240726110338645-878ccd52.png",ai="/jixiang/assets/image-20240221172603424-e5d805eb.png",ii="/jixiang/assets/image-20240726111106324-b0d44c40.png",si="/jixiang/assets/image-20240726111547259-03004ae7.png",ei="/jixiang/assets/image-20240726112104408-7cf88cd6.png",pi="/jixiang/assets/image-20240726112326911-d97e2cb9.png",ti="/jixiang/assets/image-20240221172900254-5f9a7e0d.png",gi="/jixiang/assets/image-20240726112718843-c61db3cf.png",ni="/jixiang/assets/image-20240726114309247-25b13067.png",ri="/jixiang/assets/image-20240221173106559-947899db.png",mi="/jixiang/assets/image-20240726115227223-5ded5b53.png",ci="/jixiang/assets/image-20240726115640742-b1539332.png",oi="/jixiang/assets/image-20240726215339348-a1d6ba03.png",di="/jixiang/assets/image-20240726215720485-da7da1d3.png",_i="/jixiang/assets/image-20240726220112949-ab036bad.png",hi="/jixiang/assets/image-20240726220509866-7f787ac0.png",li="/jixiang/assets/image-20240726221302958-164155ba.png",xi="/jixiang/assets/image-20240222121030764-0366e988.png",bi="/jixiang/assets/image-20240222121354279-021854ec.png",ji="/jixiang/assets/image-20240726223014933-ce1435f6.png",fi="/jixiang/assets/image-20240726223608516-652aa848.png",ui="/jixiang/assets/image-20240726224118281-c92b3d22.png",yi="/jixiang/assets/image-20240726224630423-54ea3364.png",Ti="/jixiang/assets/image-20240726224810041-a26103a5.png",Si="/jixiang/assets/image-20240726225454365-ca0a8786.png",ki="/jixiang/assets/image-20240222121446235-a465a50c.png",vi="/jixiang/assets/image-20240222121654000-8d4eec7b.png",wi="/jixiang/assets/image-20240728232610912-6415c58f.png",Bi="/jixiang/assets/image-20240728233317817-164439db.png",Ai="/jixiang/assets/image-20240728233801230-a4575f9b.png",Ci="/jixiang/assets/image-20240728234550333-a99b082e.png",Ei="/jixiang/assets/image-20240222121831499-78e98b36.png",Ri="/jixiang/assets/image-20240730115558460-8955a1d8.png",Ji="/jixiang/assets/image-20240222122147913-fb3df226.png",Di="/jixiang/assets/image-20240730120323718-59df3125.png",Ii="/jixiang/assets/image-20240730121159365-3fe5dfdd.png",Pi="/jixiang/assets/image-20240222122255141-e3626ef4.png",Ni="/jixiang/assets/image-20240730122151664-93d2c049.png",qi="/jixiang/assets/image-20240222123933659-977c5876.png",Mi="/jixiang/assets/image-20240222124046861-4a2d5794.png",Ki="/jixiang/assets/image-20240730232658402-c8c10ba0.png",Vi="/jixiang/assets/image-20240730234403655-9006869c.png",Li="/jixiang/assets/image-20240731000933584-96aa9833.png",Oi="/jixiang/assets/image-20240731002358730-160127fd.png",Ui="/jixiang/assets/image-20240222124315378-28219c64.png",Fi="/jixiang/assets/image-20240731092017330-d4c04e60.png",Hi="/jixiang/assets/image-20240222124439450-de854f79.png",zi="/jixiang/assets/image-20240731080212881-57b893d5.png",Gi="/jixiang/assets/image-20240222133139002-81b17122.png",Wi="/jixiang/assets/image-20240731125231721-380366b6.png",Qi="/jixiang/assets/image-20240731183827677-ff98b92b.png",Xi="/jixiang/assets/image-20240731183657011-3a1fdf75.png",Yi="/jixiang/assets/image-20240731184253735-fef33c5a.png",Zi="/jixiang/assets/image-20240731185541719-6ecdbe04.png",$i="/jixiang/assets/image-20240731184742375-360d2f3f.png",a0="/jixiang/assets/image-20240731190210462-a916849d.png",i0="/jixiang/assets/image-20240731190530036-a78976f4.png",s0="/jixiang/assets/image-20240731191235444-f15e9060.png",e0="/jixiang/assets/image-20240731191627660-24c05499.png",p0="/jixiang/assets/image-20240731191911312-ed6acb1d.png",t0="/jixiang/assets/image-20240731195750772-12fa2e46.png",g0="/jixiang/assets/image-20240731200534998-7c1dc535.png",n0="/jixiang/assets/image-20240731202330995-feb506e0.png",r0="/jixiang/assets/image-20240222133252724-7b94f186.png",m0="/jixiang/assets/image-20240731094409508-da87d528.png",c0="/jixiang/assets/image-20240222133402009-70b93538.png",o0="/jixiang/assets/image-20240731095534388-da04027c.png",d0="/jixiang/assets/image-20240731100226936-181155f4.png",_0="/jixiang/assets/image-20240802231650490-11a91739.png",h0="/jixiang/assets/接口和抽象类的区别-6b9ff94f.png",l0="/jixiang/assets/image-20240222133504023-58be9e2d.png",x0="/jixiang/assets/image-20240731121150963-345728ee.png",b0="/jixiang/assets/image-20240731121830862-6aa53933.png",j0="/jixiang/assets/image-20240222133535468-1525b03d.png",f0="/jixiang/assets/image-20240731124124980-41f513c8.png",u0="/jixiang/assets/image-20240222133635541-3aaa4d49.png",y0="/jixiang/assets/image-20240802232939469-18fa2f5c.png",T0="/jixiang/assets/image-20240222133706510-63f538a8.png",S0="/jixiang/assets/image-20240802233438480-675127b3.png",k0="/jixiang/assets/image-20240802233819719-9a0ff117.png",v0="/jixiang/assets/image-20240802234039333-2d97a2fd.png",w0="/jixiang/assets/image-20240802235046019-dc093386.png",B0="/jixiang/assets/image-20240222135806351-8cef47bf.png",A0="/jixiang/assets/image-20240222135848758-20fa51d7.png",C0="/jixiang/assets/image-20240803080224849-57a5295b.png",E0="/jixiang/assets/image-20240803080728902-6dde086b.png",R0="/jixiang/assets/image-20240803081137846-48081fe8.png",J0="/jixiang/assets/image-20240803081822916-fd5fcded.png",D0="/jixiang/assets/image-20240803092238120-1cec6146.png",I0="/jixiang/assets/image-20240803093345006-1c1b0f27.png",P0="/jixiang/assets/image-20240222140031235-8943cff2.png",N0="/jixiang/assets/image-20240803094414417-6bcb7664.png",q0="/jixiang/assets/image-20240803094640490-4e13c2b2.png",M0="/jixiang/assets/image-20240222140131656-128685c9.png",K0="/jixiang/assets/image-20240803101317915-a011ff36.png",V0="/jixiang/assets/image-20240803102008890-c9760fc3.png",L0="/jixiang/assets/image-20240222140313503-47503a29.png",O0="/jixiang/assets/image-20240803102602006-98b02761.png",U0="/jixiang/assets/image-20240222140404466-9cbdb6f2.png",F0="/jixiang/assets/image-20240803113131204-53246f1e.png",H0="/jixiang/assets/image-20240803113824868-9fea9d8f.png",z0="/jixiang/assets/image-20240803121253938-c2af960e.png",G0="/jixiang/assets/image-20240222140638781-d11d218d.png",W0="/jixiang/assets/image-20240803142215305-91c932ae.png",Q0="/jixiang/assets/image-20240803143023599-c5939966.png",X0="/jixiang/assets/image-20240803143657718-42136b39.png",Y0="/jixiang/assets/image-20240222140841417-7cc28b55.png",Z0="/jixiang/assets/image-20240803175643290-5bf30d36.png",$0="/jixiang/assets/image-20240222141027619-62c1c0b9.png",as="/jixiang/assets/image-20240803184135159-c8216406.png",is="/jixiang/assets/image-20240803190340151-92bc4843.png",ss="/jixiang/assets/image-20240806132047427-0e86619a.png",es="/jixiang/assets/image-20240806132711263-51959d82.png",ps="/jixiang/assets/image-20240806134109690-44f85bbd.png",ts="/jixiang/assets/image-20240806135041786-1822f312.png",gs="/jixiang/assets/image-20240806135355511-67fd36fb.png",ns="/jixiang/assets/image-20240806135844241-9a34dcac.png",rs="/jixiang/assets/image-20240806140735702-6bc7c67f.png",ms="/jixiang/assets/image-20240806152236172-2aa92885.png",cs="/jixiang/assets/image-20240806154549237-573ceb1e.png",os="/jixiang/assets/image-20240806154805127-5a693381.png",ds="/jixiang/assets/image-20240806155837631-2a0984c2.png",_s="/jixiang/assets/image-20240806160133490-7fd2fd7c.png",hs="/jixiang/assets/image-20240806160436979-84347334.png",ls="/jixiang/assets/image-20240806161439766-7dbba0a4.png",xs="/jixiang/assets/image-20240806163059546-7fb3f553.png",bs="/jixiang/assets/image-20240806165453549-1d00eb07.png",js="/jixiang/assets/image-20240806165921484-9eeae1a6.png",fs="/jixiang/assets/image-20240806170222033-fe6a2755.png",us="/jixiang/assets/image-20240806171651616-64f8d01d.png",ys="/jixiang/assets/image-20240222141335413-e202f44a.png",Ts="/jixiang/assets/image-20240806172326111-b6433852.png",Ss="/jixiang/assets/image-20240806172708917-1a4586d8.png",ks="/jixiang/assets/image-20240806172752106-f39b945d.png",vs="/jixiang/assets/image-20240806172954388-8fdca70d.png",ws="/jixiang/assets/image-20240806173202344-7dcab9da.png",Bs="/jixiang/assets/image-20240806173304039-f6ca8e09.png",As="/jixiang/assets/image-20240806173432871-f2f2ae53.png",Cs="/jixiang/assets/image-20240806173636395-1b25ac0b.png",Es="/jixiang/assets/image-20240806173803528-3fb429ea.png",Rs="/jixiang/assets/image-20240806185539956-6cd6ffcb.png",Js="/jixiang/assets/image-20240806185702373-862230bd.png",Ds="/jixiang/assets/image-20240806233102626-bb50ef48.png",Is="/jixiang/assets/image-20240806233750291-90f0a1a9.png",Ps="/jixiang/assets/image-20240806233914323-931bd4ad.png",Ns="/jixiang/assets/image-20240806234500005-f8d389aa.png",qs="/jixiang/assets/image-20240806234914753-140bbcdc.png",Ms="/jixiang/assets/image-20240806235023620-7d0470be.png",Ks="/jixiang/assets/image-20240806235323621-8d0deb08.png",Vs="/jixiang/assets/image-20240807000753238-15ef6bf7.png",Ls="/jixiang/assets/image-20240807123530469-c4b9a3b4.png",Os="/jixiang/assets/image-20240807123716095-1d7e11ff.png",Us="/jixiang/assets/image-20240807124523670-9ecef488.png",Fs="/jixiang/assets/image-20240807124646835-87b77bc1.png",Hs="/jixiang/assets/image-20240807124847598-69d64713.png",zs="/jixiang/assets/image-20240807125113849-9c6738d3.png",Gs="/jixiang/assets/image-20240807125326740-6c7927f0.png",Ws="/jixiang/assets/image-20240807125442580-5c5c3439.png",Qs="/jixiang/assets/image-20240807125742438-71c8ba3d.png",Xs="/jixiang/assets/image-20240807130224882-9103d285.png",Ys="/jixiang/assets/image-20240807130501178-56d529b4.png",Zs="/jixiang/assets/image-20240807130551962-21410c4b.png",$s="/jixiang/assets/image-20240807143047189-974626a8.png",ae="/jixiang/assets/image-20240807150305177-12ad4e97.png",ie="/jixiang/assets/image-20240807150553052-20148b3e.png",se="/jixiang/assets/image-20240807151321625-21a9653c.png",ee="/jixiang/assets/image-20240807151909938-03c8d09f.png",pe="/jixiang/assets/image-20240807152207180-4ccffa03.png",te="/jixiang/assets/image-20240807153441310-27c4ec4e.png",ge="/jixiang/assets/image-20240222141952495-59a62679.png",ne="/jixiang/assets/image-20240805205514001-c0e16223.png",re="/jixiang/assets/image-20240222142017207-54c32905.png",me="/jixiang/assets/image-20240222142035294-2505d892.png",ce="/jixiang/assets/image-20240805210148878-d08e69ca.png",oe="/jixiang/assets/image-20240805211324839-8f63cccb.png",de="/jixiang/assets/image-20240222142119180-947bf24e.png",_e="/jixiang/assets/image-20240805212740836-25e3b252.png",he="/jixiang/assets/image-20240805213845187-695bc382.png",le="/jixiang/assets/image-20240805214157751-2ef73c77.png",xe="/jixiang/assets/image-20240222142254869-6d274027.png",be="/jixiang/assets/image-20240805222814440-19996f9a.png",je="/jixiang/assets/image-20240222142343368-787bad51.png",fe="/jixiang/assets/image-20240805223711311-a136c79e.png",ue="/jixiang/assets/image-20240805224140421-3865c656.png",ye="/jixiang/assets/image-20240222142433505-fa476951.png",Te="/jixiang/assets/image-20240805225640362-36a5b0e3.png",Se="/jixiang/assets/image-20240805230548600-fcc94e49.png",ke="/jixiang/assets/image-20240805232252134-d3c9e1ae.png",ve="/jixiang/assets/image-20240805232415082-b13cf5c1.png",we="/jixiang/assets/image-20240805232912394-d8bc72c5.png",Be="/jixiang/assets/image-20240805233529480-1384e0dd.png",Ae="/jixiang/assets/image-20240805233707023-b3220042.png",Ce="/jixiang/assets/image-20240805234149284-fde082df.png",Ee="/jixiang/assets/image-20240805234328215-f10cb519.png",Re="/jixiang/assets/image-20240805234559249-b688bdbc.png",Je="/jixiang/assets/image-20240805234841269-17976341.png",De="/jixiang/assets/image-20240805235030742-10df812f.png",Ie="/jixiang/assets/image-20240806001125434-05161f23.png",Pe="/jixiang/assets/image-20240806074209346-dbb57b5a.png",Ne="/jixiang/assets/image-20240806074835309-9d3cbbd2.png",qe="/jixiang/assets/image-20240222142537269-f4a00c90.png",Me="/jixiang/assets/image-20240806082758487-80486202.png",Ke="/jixiang/assets/image-20240806093705736-443e3c14.png",Ve="/jixiang/assets/image-20240806094126086-882b2dbc.png",Le="/jixiang/assets/image-20240222142623695-47b71fa3.png",Oe="/jixiang/assets/image-20240806101110310-af1e2659.png",Ue="/jixiang/assets/image-20240806095213769-727e7cb6.png",Fe="/jixiang/assets/image-20240806100137304-29ff1c85.png",He="/jixiang/assets/image-20240806100551544-d79fdc38.png",ze="/jixiang/assets/image-20240806100826408-109e3f69.png",Ge="/jixiang/assets/image-20240806110321232-162a0048.png",We="/jixiang/assets/image-20240806111100335-a284fa9e.png",Qe="/jixiang/assets/image-20240806111408238-726155e4.png",Xe="/jixiang/assets/image-20240806111500395-370aca7b.png",Ye="/jixiang/assets/image-20240806111913736-477ef9fe.png",Ze="/jixiang/assets/image-20240806112341868-8b57a398.png",$e="/jixiang/assets/image-20240222143006500-7cfdd0e4.png",ap="/jixiang/assets/image-20240806113611448-71399271.png",ip="/jixiang/assets/image-20240806113912213-19c4deef.png",sp="/jixiang/assets/image-20240806114246265-c404fcdc.png",ep="/jixiang/assets/image-20240806114548119-1384e432.png",pp="/jixiang/assets/image-20240806115521891-af5e69e8.png",tp="/jixiang/assets/image-20240806115906584-977761e5.png",gp="/jixiang/assets/image-20240806120529919-50f17ffe.png",np="/jixiang/assets/image-20240806120805323-c8b4cd14.png",rp="/jixiang/assets/image-20240222143218402-4f195b51.png",mp="/jixiang/assets/image-20240806121218775-085cf2ab.png",cp="/jixiang/assets/image-20240806131217137-b7ac4542.png",op="/jixiang/assets/image-20240806131256570-66f6b0c8.png",dp="/jixiang/assets/image-20240222143304941-c76506aa.png",_p="/jixiang/assets/image-20240222143333675-429ee892.png",hp="/jixiang/assets/image-20240222143408870-bd9e2483.png",lp="/jixiang/assets/image-20231001171716424-d49f65de.png",xp="/jixiang/assets/image-20231001171906758-26177ee4.png",bp="/jixiang/assets/image-20240222143534047-9a941b18.png",jp="/jixiang/assets/image-20240222143607909-466e8e63.png",fp="/jixiang/assets/image-20231001204144716-dda794cb.png",up={},yp=s('<h2 id="一、邂逅-typescript-语法" tabindex="-1"><a class="header-anchor" href="#一、邂逅-typescript-语法" aria-hidden="true">#</a> 一、邂逅 TypeScript 语法</h2><h3 id="_1-js类型缺失" tabindex="-1"><a class="header-anchor" href="#_1-js类型缺失" aria-hidden="true">#</a> 1. JS类型缺失</h3><p><img src="'+m+'" alt="image-20240221151400904"></p><p><img src="'+c+'" alt="image-20240221151432190"></p><p><img src="'+o+'" alt="image-20240221151502231"></p><p><img src="'+d+'" alt="image-20240221151532883"></p><p><img src="'+_+'" alt="image-20240221151603407"></p><p><img src="'+h+'" alt="image-20240221151633802"></p><h3 id="_2-邂逅ts" tabindex="-1"><a class="header-anchor" href="#_2-邂逅ts" aria-hidden="true">#</a> 2. 邂逅TS</h3><p><img src="'+l+'" alt="image-20240221151656752"></p><p><img src="'+x+'" alt="image-20240221151747988"></p><p><img src="'+b+'" alt="image-20240221151820990"></p><p><img src="'+j+'" alt="image-20240221151905873"></p><p><img src="'+f+'" alt="image-20240221151938685"></p><h3 id="_3-ts的运行环境" tabindex="-1"><a class="header-anchor" href="#_3-ts的运行环境" aria-hidden="true">#</a> 3. TS的运行环境</h3><h4 id="a-编译环境" tabindex="-1"><a class="header-anchor" href="#a-编译环境" aria-hidden="true">#</a> A）编译环境</h4><p><img src="'+u+'" alt="image-20240221152016329"></p><p>第一步：安装typescript，可以通过TS的Compiler将其编译成JS。操作如下：</p><p><img src="'+y+'" alt="image-20240723201851292"></p><p>第二步：书写TS代码，如下：</p><p><img src="'+T+'" alt="image-20240723202104964"></p><p>第三步：cd到根目录，tsc编译对应的.ts文件，然后根目录生成对应的js文件。代码和效果如下：</p><p><img src="'+S+'" alt="image-20240723202547399"></p><p>第四步：浏览器中查看效果，如下：</p><p><img src="'+k+'" alt="image-20240723202634108"></p><h4 id="b-运行环境" tabindex="-1"><a class="header-anchor" href="#b-运行环境" aria-hidden="true">#</a> B）运行环境</h4><p><img src="'+v+'" alt="image-20240221152040797"></p><p><img src="'+w+'" alt="image-20240221152102809"></p><p>上述操作，我们需要先将ts代码编译成js代码，再到浏览器中运行。我们如何直接运行ts并查看结果？</p>',29),Tp={href:"https://mp.weixin.qq.com/s/wnL1l-ERjTDykWM76l4Ajw",target:"_blank",rel:"noopener noreferrer"},Sp=s('<p>方式二：在webpack环境中运行。方式二：安装ts-node，因为它为TS代码提供了执行环境。</p><p>步骤一：安装ts-node，操作如下：</p><p><img src="'+B+'" alt="image-20240723212734514"></p><p>步骤二：使用ts-node命令，运行对应的ts文件。如下：</p><p><img src="'+A+'" alt="image-20240723213010693"></p><h2 id="二-ts变量声明" tabindex="-1"><a class="header-anchor" href="#二-ts变量声明" aria-hidden="true">#</a> 二，TS变量声明</h2><h3 id="_1-声明变量" tabindex="-1"><a class="header-anchor" href="#_1-声明变量" aria-hidden="true">#</a> 1. 声明变量</h3><p><img src="'+C+'" alt="image-20240221152122443"></p><p><img src="'+E+'" alt="image-20240221152339864"></p><p><img src="'+R+'" alt="img"></p><h3 id="_2-类型推导" tabindex="-1"><a class="header-anchor" href="#_2-类型推导" aria-hidden="true">#</a> 2. 类型推导</h3><p><img src="'+J+'" alt="image-20240221153110696"></p><p>开发中，初始化变量时，不需要添加类型注解，因为会根据赋值会自动推导出类型。let声明的变量推导为通用类型，而const声明的变量推导为字面量类型。代码如下：</p><p><img src="'+D+'" alt="image-20240723214433493"></p><h2 id="三-js类型" tabindex="-1"><a class="header-anchor" href="#三-js类型" aria-hidden="true">#</a> 三，JS类型</h2><h3 id="_1-js和ts的数据类型" tabindex="-1"><a class="header-anchor" href="#_1-js和ts的数据类型" aria-hidden="true">#</a> 1. JS和TS的数据类型</h3><p><img src="'+I+'" alt="image-20240221153600538"></p><h3 id="_2-number类型" tabindex="-1"><a class="header-anchor" href="#_2-number类型" aria-hidden="true">#</a> 2. number类型</h3><p><img src="'+P+'" alt="image-20240221153704828"></p><h3 id="_3-boolean类型" tabindex="-1"><a class="header-anchor" href="#_3-boolean类型" aria-hidden="true">#</a> 3. Boolean类型</h3><p><img src="'+N+'" alt="image-20240221153759122"></p><h3 id="_4-string类型" tabindex="-1"><a class="header-anchor" href="#_4-string类型" aria-hidden="true">#</a> 4. string类型</h3><p><img src="'+q+'" alt="image-20240221153852719"></p><h3 id="_5-array类型" tabindex="-1"><a class="header-anchor" href="#_5-array类型" aria-hidden="true">#</a> 5. Array类型</h3><p><img src="'+M+'" alt="image-20240221153938623"></p><p>在ts中，数组一般用来存储一组类型相同的元素，如果我们不使用类型推导，要手动书写出数组的类型注解，格式如下：</p><p><img src="'+K+'" alt="image-20240723215446227"></p><p>数组类型写法二(不推荐)：代码如下：</p><p><img src="'+V+'" alt="image-20240723215904353"></p><h3 id="_6-object类型" tabindex="-1"><a class="header-anchor" href="#_6-object类型" aria-hidden="true">#</a> 6. object类型</h3><p><img src="'+L+'" alt="image-20240221154209698"></p><p>在ts中，不要给一个对象添加objet类型，因为object表示空对象，后续再对这个对象进行操作时，会报错。代码如下：</p><p><img src="'+O+'" alt="image-20240723220514191"></p><h3 id="_7-symbol类型" tabindex="-1"><a class="header-anchor" href="#_7-symbol类型" aria-hidden="true">#</a> 7. Symbol类型</h3><p><img src="'+U+'" alt="image-20240221154337947"></p><h3 id="_8-null和undefin类型" tabindex="-1"><a class="header-anchor" href="#_8-null和undefin类型" aria-hidden="true">#</a> 8. null和undefin类型</h3><p><img src="'+F+'" alt="image-20240221154435570"></p><h3 id="_9-函数的参数类型" tabindex="-1"><a class="header-anchor" href="#_9-函数的参数类型" aria-hidden="true">#</a> 9. 函数的参数类型</h3><p><img src="'+H+'" alt="image-20240221154528763"></p><p>在ts中，函数的参数类型默认为any，这样是不安全的，因此我们需要给参数添加类型，代码如下：</p><p><img src="'+z+'" alt="image-20240723221651491"></p><p>封装一个解析歌词解析的函数，代码如下：</p><p><img src="'+G+'" alt="image-20240723224003277"></p><h3 id="_10-函数的返回值类型" tabindex="-1"><a class="header-anchor" href="#_10-函数的返回值类型" aria-hidden="true">#</a> 10. 函数的返回值类型</h3><p><img src="'+W+'" alt="image-20240221154637678"></p><p><img src="'+Q+'" alt="img"></p><p><img src="'+X+'" alt="img"></p><h3 id="_11-匿名函数的参数" tabindex="-1"><a class="header-anchor" href="#_11-匿名函数的参数" aria-hidden="true">#</a> 11. 匿名函数的参数</h3><p><img src="'+Y+'" alt="image-20240221154858066"></p><p>在TS中，匿名函数的参数最好不要添加类型注解，因为我们不确定数组中每一项是什么类型，并且可以根据上下文自动推导出来。代码如下：</p><p><img src="'+Z+'" alt="image-20240723224632265"></p><p><img src="'+$+'" alt="img"></p><h3 id="_12-对象类型" tabindex="-1"><a class="header-anchor" href="#_12-对象类型" aria-hidden="true">#</a> 12. 对象类型</h3><p><img src="'+a2+'" alt="image-20240221155053835"></p><p>在TS中，我们可以将对象类型和函数结合使用，代码如下：</p><p><img src="'+i2+'" alt="image-20240723225437906"></p><h3 id="_13-可选类型" tabindex="-1"><a class="header-anchor" href="#_13-可选类型" aria-hidden="true">#</a> 13. 可选类型</h3><p><img src="'+s2+'" alt="image-20240221155200142"></p><p><img src="'+e2+'" alt="img"></p><h2 id="四-ts类型" tabindex="-1"><a class="header-anchor" href="#四-ts类型" aria-hidden="true">#</a> 四，TS类型</h2><h3 id="_1-any类型" tabindex="-1"><a class="header-anchor" href="#_1-any类型" aria-hidden="true">#</a> 1. any类型</h3><p><img src="'+p2+'" alt="image-20240221155532043"></p><p>如果有一些变量，我们实在不能确定它具体的类型，我们可以给它添加any类型。如下：</p><p><img src="'+t2+'" alt="image-20240723225909308"></p><p>当我们从服务器中获取到某些数据，这些数据过于复杂，我们不方便给它添加类型。我们也可以使用any类型，如下：</p><p><img src="'+g2+'" alt="image-20240723230448512"></p><p>还有一种情况，在使用某些丢失类型注解的第三方库时，我们也可以使用any。</p><h3 id="_2-ts-unknown类型" tabindex="-1"><a class="header-anchor" href="#_2-ts-unknown类型" aria-hidden="true">#</a> 2. TS-unknown类型</h3><p><img src="'+n2+'" alt="image-20240221155816584"></p><p>在TS中，对于unknown类型操作的任何操作都属于不合法的，如下：</p><p><img src="'+r2+'" alt="image-20240723231047267"></p><p>因此我们想操作unknown类型，我们需要先对其进行校验，代码如下：</p><p><img src="'+m2+'" alt="image-20240723231446290"></p><h3 id="_3-ts-void类型" tabindex="-1"><a class="header-anchor" href="#_3-ts-void类型" aria-hidden="true">#</a> 3. TS-void类型</h3><p><img src="'+c2+'" alt="image-20240221155905527"></p><p>关键点一：在ts中，void类型通常用来指定一个函数是没有返回值的。代码如下：</p><p><img src="'+o2+'" alt="image-20240723232104685"></p><p>关键点二：如果一个函数的返回值为void类型，我们也可以返回undefined。代码如下：</p><p><img src="'+d2+'" alt="image-20240723232310451"></p><p>关键点三：当一个函数作为类型时，并且返回值为空。那么就可以使用void。代码如下：</p><p><img src="'+_2+'" alt="image-20240723234215917"></p><p>关键点四：当基于上下文推导出返回类型为void的匿名函数时，并不会强制函数一定不能返回内容。代码如下：</p><p><img src="'+h2+'" alt="image-20240723235047497"></p><h3 id="_4-ts-never类型" tabindex="-1"><a class="header-anchor" href="#_4-ts-never类型" aria-hidden="true">#</a> 4. TS-never类型</h3><p><img src="'+l2+'" alt="image-20240221160020601"></p><p>在ts中，很少主动使用never类型。会自动推导出neverl类型，有以下几种情况。</p><p>情况一：当一个函数出现死循环或抛出异常时，才会自动推导为never。代码如下：</p><p><img src="'+x2+'" alt="image-20240724081503018"></p><p>情况二：当一个函数返回一个空数组时，那么这个函数的返回值类型为never[ ]。代码如下：</p><p><img src="'+b2+'" alt="image-20240724081948089"></p><p>情况三：当我们扩展工具的时候，对于一些没有处理的case，可以直接报错。代码如下：</p><p><img src="'+j2+'" alt="image-20240724084552671"></p><h3 id="_5-ts-tuple类型" tabindex="-1"><a class="header-anchor" href="#_5-ts-tuple类型" aria-hidden="true">#</a> 5. TS-tuple类型</h3><h4 id="a-基本使用" tabindex="-1"><a class="header-anchor" href="#a-基本使用" aria-hidden="true">#</a> A）基本使用</h4><p><img src="'+f2+'" alt="image-20240221160134335"></p><p>在ts中，如果我们想在数组中存储不同类型的数据，并且每个位置类型明确，那么我们就可以使用元组类型。代码如下：</p><p><img src="'+u2+'" alt="image-20240724120540395"></p><h4 id="b-使用场景" tabindex="-1"><a class="header-anchor" href="#b-使用场景" aria-hidden="true">#</a> B）使用场景</h4><p><img src="'+y2+'" alt="image-20240221160212740"></p><p>在函数值使用元组类型是最多的(函数的返回值)，我们可以通过元组类型，实现react中的useState函数。代码如下：</p><p><img src="'+T2+'" alt="image-20240724200355472"></p><p><img src="'+S2+'" alt="img"></p><h2 id="五、ts-语法细节" tabindex="-1"><a class="header-anchor" href="#五、ts-语法细节" aria-hidden="true">#</a> 五、TS 语法细节</h2><h3 id="_1-联合类型" tabindex="-1"><a class="header-anchor" href="#_1-联合类型" aria-hidden="true">#</a> 1. 联合类型</h3><p><img src="'+k2+'" alt="image-20240221163604369"></p><p><img src="'+v2+'" alt="image-20240221163720520"></p><p>TypeScript的类型系统允许我们使用多种运算符，从现有类型中构建新类型。我们来使用第一种组合类型的方法：联合类型（Union Type）</p><p><img src="'+w2+'" alt="image-20240724201204426"></p><p>封装一个打印id的函数，函数的参数id既有可能是数字类型，也可能是字符串类型，此时使用联合类型。代码如下：</p><p><img src="'+B2+'" alt="image-20240724201503047"></p><h3 id="_2-类型别名" tabindex="-1"><a class="header-anchor" href="#_2-类型别名" aria-hidden="true">#</a> 2. 类型别名</h3><p><img src="'+A2+'" alt="image-20240221164024302"></p><p>对于同一个联合类型，如果在多个地方使用，那么书写将非常不方便。因此我们可以给联合类型起一个别名，代码如下：</p><p><img src="'+C2+'" alt="image-20240724202102160"></p><p>打印坐标案例中，使用类型别名可以增加函数参数的阅读性。代码如下：</p><p><img src="'+E2+'" alt="image-20240724202331714"></p><h3 id="_3-接口的声明" tabindex="-1"><a class="header-anchor" href="#_3-接口的声明" aria-hidden="true">#</a> 3. 接口的声明</h3><p><img src="'+R2+'" alt="image-20240221164241530"></p><p>在前面我们通过type可以用来声明一个对象类型，对象的另外一种声明方式就是通过接口来声明。代码如下：</p><p><img src="'+J2+'" alt="image-20240724203708583"></p><h3 id="_4-interface和type区别" tabindex="-1"><a class="header-anchor" href="#_4-interface和type区别" aria-hidden="true">#</a> 4. interface和type区别</h3><p><img src="'+D2+'" alt="image-20240221164412327"></p><p>类型别名和接口有什么区别？</p><p>区别一：type类型使用范围更广，接口类型只能用于声明对象。代码如下：</p><p><img src="'+I2+'" alt="image-20240724204245855"></p><p>区别二：在声明对象时，interface可以多次声明。代码如下：</p><p><img src="'+P2+'" alt="image-20240724214403075"></p><p><img src="'+N2+'" alt="image-20240724214559244"></p><p>区别三：interface支持继承，而type不支持。代码如下：</p><p><img src="'+q2+'" alt="image-20240724214800164"></p><p>区别四：interface可以被类实现，而type不可以。代码如下：</p><p><img src="'+M2+'" alt="image-20240724214948870"></p><p>总结：对于是非对象类型的定义使用type，如果是对象类型的声明那么使用interface。</p><h3 id="_5-交叉类型" tabindex="-1"><a class="header-anchor" href="#_5-交叉类型" aria-hidden="true">#</a> 5. 交叉类型</h3><p><img src="'+K2+'" alt="image-20240221163900629"></p><p><img src="'+V2+'" alt="image-20240221164727839"></p><p>在开发中，我们进行交叉时，通常是对对象类型进行交叉的。代码如下：</p><p><img src="'+L2+'" alt="image-20240724215547289"></p><p>如果觉得交叉类型名称太长，可以使用类型别名。代码如下：</p><p><img src="'+O2+'" alt="image-20240724215812408"></p><h3 id="_6-类型断言-as" tabindex="-1"><a class="header-anchor" href="#_6-类型断言-as" aria-hidden="true">#</a> 6. 类型断言 as</h3><p><img src="'+U2+'" alt="image-20240221164939075"></p><p>有时候TypeScript无法获取具体的类型信息，这个我们需要使用类型断言（Type Assertions）。</p><p>比如我们通过 document.getElementById，TypeScript只知道该函数会返回 HTMLElement ，但并不知道它具体的类型。</p><h4 id="a-基本使用-1" tabindex="-1"><a class="header-anchor" href="#a-基本使用-1" aria-hidden="true">#</a> A）基本使用</h4><p>通过类名直接获取到对应的dom元素，不一定是img元素，因此TS在编译时会报错。代码如下：</p><p><img src="'+F2+'" alt="image-20240724220542336"></p><p>如果我们确定拿到的一定是img元素， 那么就可以使用类型断言。代码如下：</p><p><img src="'+H2+'" alt="image-20240724220929125"></p><h4 id="b-断言的规则" tabindex="-1"><a class="header-anchor" href="#b-断言的规则" aria-hidden="true">#</a> B）断言的规则</h4><p>类型断言的规则：断言只能断言成更加具体的类型，或者不太具体的类型(any/unknown)类型。代码如下：</p><p><img src="'+z2+'" alt="image-20240724221412265"></p><p>如果将一个number类型断言成宽泛的any类型，再将any类型断言成string类型。虽然ts类型检测来说是正确的。但是代码本身不正确，可能会造成安全隐患，因此不建议这么做。如下：</p><p><img src="'+G2+'" alt="image-20240724221637732"></p><h3 id="_7-非空类型断言" tabindex="-1"><a class="header-anchor" href="#_7-非空类型断言" aria-hidden="true">#</a> 7. 非空类型断言!</h3><p><img src="'+W2+'" alt="image-20240221165034267"></p><p>在给一个可能不存在的对象的属性赋值时，会报错。赋值时，不能使用可选链。代码如下：</p><p><img src="'+Q2+'" alt="image-20240724222339362"></p><p>解决方式一：类型缩小，代码如下：</p><p><img src="'+X2+'" alt="image-20240724222525353"></p><p>解决方式二：使用非空类型断言，跳过ts在编译阶段对它的检测。代码如下：</p><p><img src="'+Y2+'" alt="image-20240724222839571"></p><h3 id="_8-字面量类型" tabindex="-1"><a class="header-anchor" href="#_8-字面量类型" aria-hidden="true">#</a> 8. 字面量类型</h3><p><img src="'+Z2+'" alt="image-20240221165152939"></p><p>字面量类型就是将一个具体的值(字符串或数字)作为类型，那么这样做有什么意义呢？ 默认情况下这么做是没有太大的意义的，但是我们可以将多个类型联合在一起。代码如下:</p><p><img src="'+$2+'" alt="image-20240724223313584"></p><p>应用场景：封装请求方法</p><p><img src="'+aa+'" alt="image-20240724223939375"></p><p>我们可以使用字面量和联合类型对传入的请求方法，加以限制。代码如下：</p><p><img src="'+ia+'" alt="image-20240724224255536"></p><p><img src="'+sa+'" alt="img"></p><h3 id="_9-字面量推理" tabindex="-1"><a class="header-anchor" href="#_9-字面量推理" aria-hidden="true">#</a> 9. 字面量推理</h3><p><img src="'+ea+'" alt="image-20240221165329680"></p><p>如果我们将将method参数以info.method形式传递，那么会认为传递进去的是一个string类型，因此会报错。代码如下：</p><p><img src="'+pa+'" alt="image-20240724232437689"></p><p>解决方案一：使用类型断言，代码如下：</p><p><img src="'+ta+'" alt="image-20240724234348084"></p><p>解决方案二：直接让info对象类型是一个字面量类型，代码如下：</p><p><img src="'+ga+'" alt="image-20240724234656364"></p><p>但是上面的写法要写一大串，非常麻烦。我们对其进行简化，使用as cont将对象类型中的属性类型直接断言为字面量类型。代码如下：</p><p><img src="'+na+'" alt="image-20240725000258120"></p><h3 id="_10-类型缩小" tabindex="-1"><a class="header-anchor" href="#_10-类型缩小" aria-hidden="true">#</a> 10. 类型缩小</h3><p><img src="'+ra+'" alt="image-20240221165445629"></p><p>类型缩小意味将一个更加宽泛的类型缩小为更加具体的类型来使用。类型缩小有很多种方式。</p><h4 id="a-typeof" tabindex="-1"><a class="header-anchor" href="#a-typeof" aria-hidden="true">#</a> A）typeof</h4><p><img src="'+ma+'" alt="image-20240221165549370"></p><p>使用typeof进行类型缩小，代码如下：</p><p><img src="'+ca+'" alt="image-20240725001218800"></p><h4 id="b-平等缩小" tabindex="-1"><a class="header-anchor" href="#b-平等缩小" aria-hidden="true">#</a> B）平等缩小</h4><p><img src="'+oa+'" alt="image-20240221165745273"></p><p>我们可以使用switch语句，进行平的缩小。代码如下：</p><p><img src="'+da+'" alt="image-20240725001459263"></p><p><img src="'+_a+'" alt="img"></p><h4 id="c-instanceof" tabindex="-1"><a class="header-anchor" href="#c-instanceof" aria-hidden="true">#</a> C）instanceof</h4><p><img src="'+ha+'" alt="image-20240221165901503"></p><p>使用instanceof判断传入的是时间字符串还是日期对象，代码如下：</p><p><img src="'+la+'" alt="image-20240725001909650"></p><h4 id="d-in操作符" tabindex="-1"><a class="header-anchor" href="#d-in操作符" aria-hidden="true">#</a> D）in操作符</h4><p><img src="'+xa+'" alt="image-20240221170008043"></p><p>使用in操作符，判断某个属性是否在对象中。代码如下：</p><p><img src="'+ba+'" alt="image-20240725002608363"></p><h2 id="六-ts函数类型和函数签名" tabindex="-1"><a class="header-anchor" href="#六-ts函数类型和函数签名" aria-hidden="true">#</a> 六，TS函数类型和函数签名</h2><p><img src="'+ja+'" alt="image-20240221170424524"></p><h3 id="_1-函数类型表达式" tabindex="-1"><a class="header-anchor" href="#_1-函数类型表达式" aria-hidden="true">#</a> 1. 函数类型表达式</h3><p><img src="'+fa+'" alt="image-20240221170528801"></p><p>函数本身也是一个对象，应该也有自己的类型，那么我们应该如何表示函数的类型？</p><p>方式一：函数类型表达式，代码如下：</p><p><img src="'+ua+'" alt="image-20240725075636204"></p><p>函数类型表达式案例练习，代码如下：</p><p><img src="'+ya+'" alt="image-20240725080353810"></p><p>匿名函数作为参数时，匿名函数的参数可以不添加类型。代码如下：</p><p><img src="'+Ta+'" alt="image-20240725080601799"></p><p>TS中，对我们传入的函数类型的参数个数不进行检测，代码如下：</p><p><img src="'+Sa+'" alt="image-20240725092843288"></p><p>TS对于很多类型的监测是否报错，取决于它的内部规则。代码如下：</p><p><img src="'+ka+'" alt="image-20240725093111058"></p><p><img src="'+va+'" alt="image-20240725093335178"></p><h3 id="_2-函数调用签名" tabindex="-1"><a class="header-anchor" href="#_2-函数调用签名" aria-hidden="true">#</a> 2. 函数调用签名</h3><p><img src="'+wa+'" alt="image-20240221170717489"></p><p>从对象的角度来看函数，也可以有其他属性，调用签名就是表示如何调用这个函数。代码如下：</p><p><img src="'+Ba+'" alt="image-20240725101234112"></p><p>在开发中，到底使用函数类型表达式还是函数调用签名呢？代码如下：</p><p><img src="'+Aa+'" alt="image-20240725102106056"></p><h3 id="_3-构造签名-construct-signatures" tabindex="-1"><a class="header-anchor" href="#_3-构造签名-construct-signatures" aria-hidden="true">#</a> 3. 构造签名(Construct Signatures)</h3><p><img src="'+Ca+'" alt="image-20240222143837199"></p><p>在TS中，我们可以直接通过new调用一个函数，但是返回的对象类型为any，代码如下：</p><p><img src="'+Ea+'" alt="image-20240725103609624"></p><p>我们希望返回的对象的类型不是any，此时我们需要使用函数的构造签名。代码如下:</p><p><img src="'+Ra+'" alt="image-20240725130303394"></p><h3 id="_4-参数的可选类型" tabindex="-1"><a class="header-anchor" href="#_4-参数的可选类型" aria-hidden="true">#</a> 4. 参数的可选类型</h3><p><img src="'+Ja+'" alt="image-20240221170953033"></p><p>函数的可选参数的类型是联合类型，使用时需要进行类型缩小。代码如下：</p><p><img src="'+Da+'" alt="image-20240726075027581"></p><p>另外可选类型需要在必传参数的后面。</p><h3 id="_5-默认参数" tabindex="-1"><a class="header-anchor" href="#_5-默认参数" aria-hidden="true">#</a> 5. 默认参数</h3><p><img src="'+Ia+'" alt="image-20240221171129278"></p><p>函数的参数可以有默认值，有默认值的参数，类型可以省略。代码如下：</p><p><img src="'+Pa+'" alt="image-20240726075426733"></p><p>有默认值的参数，是可以接收一个undefined的值。代码如下：</p><p><img src="'+Na+'" alt="image-20240726075827456"></p><h3 id="_6-剩余参数" tabindex="-1"><a class="header-anchor" href="#_6-剩余参数" aria-hidden="true">#</a> 6. 剩余参数</h3><p><img src="'+qa+'" alt="image-20240221171324520"></p><p>在TS中，函数的剩余参数也可以指定类型。代码如下：</p><p><img src="'+Ma+'" alt="image-20240726081840262"></p><h2 id="七-函数的重载和this类型" tabindex="-1"><a class="header-anchor" href="#七-函数的重载和this类型" aria-hidden="true">#</a> 七，函数的重载和this类型</h2><h3 id="_1-函数的重载-了解" tabindex="-1"><a class="header-anchor" href="#_1-函数的重载-了解" aria-hidden="true">#</a> 1. 函数的重载(了解)</h3><p><img src="'+Ka+'" alt="image-20240221171425361"></p><p>在TypeScript中，如果我们编写了一个add函数，希望可以对字符串和数字类型进行相加，应该如何编写呢？</p><p>使用any类型，代码如下：</p><p><img src="'+Va+'" alt="image-20240726092156981"></p><h4 id="a-案例-sum函数的重载" tabindex="-1"><a class="header-anchor" href="#a-案例-sum函数的重载" aria-hidden="true">#</a> A）案例：sum函数的重载</h4><p><img src="'+La+'" alt="image-20240221171531964"></p><p>在TypeScript中，如果我们编写了一个add函数，希望可以对字符串和数字类型进行相加，应该如何编写呢？</p><p>方式一：函数的参数使用any类型，代码如下：</p><p><img src="'+Oa+'" alt="image-20240726092553690"></p><p>方式二：编写两个不同逻辑的函数，代码如下：</p><p><img src="'+Ua+'" alt="image-20240726092815799"></p><p>方式三(错误做法)：参数使用联合类型，代码如下:</p><p><img src="'+Fa+'" alt="image-20240726093037554"></p><p>方式四：编写两个或者以上的重载签名，再去编写一个通用的函数以及实现。代码如下：</p><p><img src="'+Ha+'" alt="image-20240726093657253"></p><p>函数重载在业务开发中很少使用，在第三方框架或者库中可能会使用。</p><h3 id="_2-联合类型和重载" tabindex="-1"><a class="header-anchor" href="#_2-联合类型和重载" aria-hidden="true">#</a> 2. 联合类型和重载</h3><p><img src="'+za+'" alt="image-20240221171703389"></p><p>我们现在有一个需求：定义一个函数，可以传入字符串或者数组，获取它们的长度。</p><p>方式一：使用函数的重载，代码如下：</p><p><img src="'+Ga+'" alt="image-20240726094251694"></p><p>方式二：使用联合类型，代码如下：</p><p><img src="'+Wa+'" alt="image-20240726094516064"></p><p>方式三：使用对象类来实现，代码如下：</p><p><img src="'+Qa+'" alt="image-20240726094721705"></p><h3 id="_3-可推导的-this-类型" tabindex="-1"><a class="header-anchor" href="#_3-可推导的-this-类型" aria-hidden="true">#</a> 3. 可推导的 this 类型</h3><p><img src="'+Xa+'" alt="image-20240221172055563"></p><p>在没有对TS进行特殊配置的情况下，this是any类型。</p><p>情况一：对象方法中this的类型为any，代码如下：</p><p><img src="'+Ya+'" alt="image-20240726105322924"></p><p>情况二：普通函数中的this也为any类型，代码如下：</p><p><img src="'+Za+'" alt="image-20240726105633325"></p><p>在this没有类型的情况下，可能会存在安全隐患。代码如下：</p><p><img src="'+$a+'" alt="image-20240726110338645"></p><h3 id="_4-this的编译选项" tabindex="-1"><a class="header-anchor" href="#_4-this的编译选项" aria-hidden="true">#</a> 4. this的编译选项</h3><p><img src="'+ai+'" alt="image-20240221172603424"></p><p>VSCode在检测我们的TypeScript代码时，默认情况下运行不确定的this按照any类型去使用。但是我们可以创建一个tsconfig.json文件，并且在其中告知VSCodethis必须明确执行（不能是隐式的）。</p><p>步骤一：初始化TS配置文件。操作如下：</p><p><img src="'+ii+'" alt="image-20240726111106324"></p><p>查看TS配置文件中，关于this选项，如下：</p><p><img src="'+si+'" alt="image-20240726111547259"></p><p>再返回使用this的TS文件，会发现使用this报错。如下：</p><p><img src="'+ei+'" alt="image-20240726112104408"></p><p>那么如果我们想解决this没有指定类型会报错问题呢？在TS配置文件中，打开模糊this，操作如下：</p><p><img src="'+pi+'" alt="image-20240726112326911"></p><h3 id="_5-指定this的类型" tabindex="-1"><a class="header-anchor" href="#_5-指定this的类型" aria-hidden="true">#</a> 5. 指定this的类型</h3><p><img src="'+ti+'" alt="image-20240221172900254"></p><p>在设置了noImplicitThis为true时， TypeScript会根据上下文推导this，但是在不能正确推导时，就会报错，需要我们明确 的指定this。</p><p><img src="'+gi+'" alt="image-20240726112718843"></p><p>在this类型不能根据上下文进行推导时，我们需要手动指定this类型。函数的第一个参数我们可以根据该函数之后被调用的情况，用于声明this的类型（名字必须叫this）。在后续调用函数传入参数时，从第二个参数开始传递的，this参数会在编译后被抹除；</p><p><img src="'+ni+'" alt="image-20240726114309247"></p><h3 id="_6-this内置工具" tabindex="-1"><a class="header-anchor" href="#_6-this内置工具" aria-hidden="true">#</a> 6. this内置工具</h3><p><img src="'+ri+'" alt="image-20240221173106559"></p><p>通过ThisParameterType工具可以提取函数类型中this的类型。代码如下：</p><p><img src="'+mi+'" alt="image-20240726115227223"></p><p>使用OmitThisParameter工具，可以删除this类型，获取剩余的函数类型。代码如下：</p><p><img src="'+ci+'" alt="image-20240726115640742"></p><h3 id="_6-this-相关的内置工具-thistype" tabindex="-1"><a class="header-anchor" href="#_6-this-相关的内置工具-thistype" aria-hidden="true">#</a> 6. this 相关的内置工具 - thisType</h3><p><img src="'+oi+'" alt="image-20240726215339348"></p><p>看下面这样一个案例，代码如下：</p><p><img src="'+di+'" alt="image-20240726215720485"></p><p>当我们通过call调用store的eating方法，并且将this绑定为store.state，这样eating方法中的this就是store.state。但是依然报错。代码如下：</p><p><img src="'+_i+'" alt="image-20240726220112949"></p><p>因此我们需要显式指定eating函数中的this，添加this参数，并指定类型。代码如下：</p><p><img src="'+hi+'" alt="image-20240726220509866"></p><p>因此我们需要使用ThisType工具，给store的函数中绑定上下文this。代码如下：</p><p><img src="'+li+'" alt="image-20240726221302958"></p><h2 id="八-ts面向对象" tabindex="-1"><a class="header-anchor" href="#八-ts面向对象" aria-hidden="true">#</a> 八，TS面向对象</h2><h3 id="_1-ts类的使用" tabindex="-1"><a class="header-anchor" href="#_1-ts类的使用" aria-hidden="true">#</a> 1. TS类的使用</h3><p><img src="'+xi+'" alt="image-20240222121030764"></p><h4 id="a-类的定义" tabindex="-1"><a class="header-anchor" href="#a-类的定义" aria-hidden="true">#</a> A）类的定义</h4><p><img src="'+bi+'" alt="image-20240222121354279"></p><p>在TS的类中，定义成员属性时，必须要先在类中声明成员属性，否则会报错。代码如下：</p><p><img src="'+ji+'" alt="image-20240726223014933"></p><p>如果我们在类中声明成员属性时，可以给一个初始化值，就可以省略类型，让TS自动推导。代码如下：</p><p><img src="'+fi+'" alt="image-20240726223608516"></p><p>此外，在默认的strictPropertyInitialization模式下面我们的属性是必须 初始化的，如果没有初始化，那么编译时就会报错。如下：</p><p><img src="'+ui+'" alt="image-20240726224118281"></p><p>初始化方式一：代码如下：</p><p><img src="'+yi+'" alt="image-20240726224630423"></p><p>初始化方式二：代码如下：</p><p><img src="'+Ti+'" alt="image-20240726224810041"></p><p>如果在严格属性初始化为true的情况下，我们确实不想进行初始化。我们应该怎么办？代码如下：</p><p><img src="'+Si+'" alt="image-20240726225454365"></p><h4 id="b-类的继承" tabindex="-1"><a class="header-anchor" href="#b-类的继承" aria-hidden="true">#</a> B）类的继承</h4><p><img src="'+ki+'" alt="image-20240222121446235"></p><p>TS中的继承和JS中一样，这里就不再做过多叙述。</p><h4 id="c-类的成员修饰符" tabindex="-1"><a class="header-anchor" href="#c-类的成员修饰符" aria-hidden="true">#</a> C）类的成员修饰符</h4><p><img src="'+vi+'" alt="image-20240222121654000"></p><p>在TypeScript中，类的属性和方法支持三种修饰符： public、private、protected。</p><p>修饰符一：public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是public的。代码和效果如下：</p><p><img src="'+wi+'" alt="image-20240728232610912"></p><p>修饰符二：private 修饰的是仅在同一类中可见、私有的属性或方法。代码和操作如下：</p><p><img src="'+Bi+'" alt="image-20240728233317817"></p><p>private修饰的属性或方法，只有在类内部才能访问。代码和效果如下：</p><p><img src="'+Ai+'" alt="image-20240728233801230"></p><p>修饰符三：protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法。代码如下：</p><p><img src="'+Ci+'" alt="image-20240728234550333"></p><h4 id="d-只读属性readonly" tabindex="-1"><a class="header-anchor" href="#d-只读属性readonly" aria-hidden="true">#</a> D）只读属性readonly</h4><p><img src="'+Ei+'" alt="image-20240222121831499"></p><p>如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用readonly。</p><p><img src="'+Ri+'" alt="image-20240730115558460"></p><h4 id="e-getters-setters" tabindex="-1"><a class="header-anchor" href="#e-getters-setters" aria-hidden="true">#</a> E）getters/ setters</h4><p><img src="'+Ji+'" alt="image-20240222122147913"></p><p>在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取(getter)和设置(setter)的过程，这个时候我们 可以使用存取器。</p><p><img src="'+Di+'" alt="image-20240730120323718"></p><p>已经将某个属性设置成私有的，还要设置setter或getter方法进行读取或修改。这不是多此一举吗？</p><p>其实在有setter和getter方法的情况下，我们可以加以限制。代码如下：</p><p><img src="'+Ii+'" alt="image-20240730121159365"></p><p>在Java中，甚至每一个属性都是私有的，都要加上setter和getter。还有一些库专门给私有属性添加setter和getter的。</p><h4 id="f-参数属性" tabindex="-1"><a class="header-anchor" href="#f-参数属性" aria-hidden="true">#</a> F）参数属性</h4><p><img src="'+Pi+'" alt="image-20240222122255141"></p><p>TypeScript 提供了特殊的语法，可以把一个构造函数参数转成一个同名同值的类属性。你可以通过在构造函数参数前添加一个可见性修饰符 public private protected 或者 readonly 来创建参数属性，最后这些类 属性字段也会得到这些修饰符。</p><p><img src="'+Ni+'" alt="image-20240730122151664"></p><h3 id="_2-ts中抽象类" tabindex="-1"><a class="header-anchor" href="#_2-ts中抽象类" aria-hidden="true">#</a> 2. TS中抽象类</h3><h4 id="a-是抽象类" tabindex="-1"><a class="header-anchor" href="#a-是抽象类" aria-hidden="true">#</a> A）是抽象类</h4><p><img src="'+qi+'" alt="image-20240222123933659"></p><p><img src="'+Mi+'" alt="image-20240222124046861"></p><p>目的：我们想编写一个通用接口(或称为函数)，来实现计算不同图形的面积，例如：三角形、矩形和圆。</p><p>代码如下：</p><p><img src="'+Ki+'" alt="image-20240730232658402"></p><p>但是现在我们应该给这个参数指定什么类型呢？</p><p>方式一：可以给参数添加联合类型，但是这样扩展性太差。后续我们又想计算其他图形的面积，又要在联合类型中添加其他类型。代码如下：</p><p><img src="'+Vi+'" alt="image-20240730234403655"></p><p>方式二：使用抽象类，注意：抽象类中的抽象方法只有声明没有实现体，实现体让子类自己实现。</p><ul><li>抽象类中的抽象方法只有声明，没有实现体。</li><li>抽象类中的抽象方法前面需要加abstract。</li><li>抽象方法必须出现在抽象类中，类前面也需要加abstract。</li><li>每个子类中必须实现抽象方法。</li><li>抽象类不能被实例化，new抽象类会报错。</li></ul><p>代码如下：</p><p><img src="'+Li+'" alt="image-20240731000933584"></p><h4 id="b-鸭子类型" tabindex="-1"><a class="header-anchor" href="#b-鸭子类型" aria-hidden="true">#</a> B）鸭子类型</h4><p>定义一个函数，参数类型必须是Person，这个类包含name和age属性。当我们传入字符串或数字时，会报错。但是我们传入一个通过字面量创建的有name和age属性的对象时，不会报错。这是为什么？代码如下：</p><p><img src="'+Oi+'" alt="image-20240731002358730"></p><p>TS对于类型监测时，使用的是鸭子类型。</p><p>鸭子类型：如果一只鸟，走起来像鸭子，游起来像鸭子，看起来像鸭子，那么你可以认为他就是一只鸭子。</p><p>鸭子类型，只关心属性和行为，不关心具体是不是对应的类型。</p><h3 id="_3-ts对象类型" tabindex="-1"><a class="header-anchor" href="#_3-ts对象类型" aria-hidden="true">#</a> 3. TS对象类型</h3><h4 id="a-类的类型" tabindex="-1"><a class="header-anchor" href="#a-类的类型" aria-hidden="true">#</a> A）类的类型</h4><p><img src="'+Ui+'" alt="image-20240222124315378"></p><p>类本身也是可以作为一种数据类型的。类的作用：</p><ul><li>可以创建类对应的实例对象。</li><li>类本身可以作为这个实例的类型。</li><li>类也可以当作有构造签名的函数。</li></ul><p><img src="'+Fi+'" alt="image-20240731092017330"></p><h4 id="b-对象类型的属性修饰符" tabindex="-1"><a class="header-anchor" href="#b-对象类型的属性修饰符" aria-hidden="true">#</a> B）对象类型的属性修饰符</h4><p><img src="'+Hi+'" alt="image-20240222124439450"></p><p>对象类型中的每个属性可以说明它的类型、属性是否可选、属性是否只读等信息。</p><ul><li>可选属性（Optional Properties），我们可以在属性名后面加一个 ? 标记表示这个属性是可选的。</li><li>只读属性（Readonly Properties），在 TypeScript 中，属性可以被标记为 readonly，这不会改变任何运行时的行为。</li></ul><p><img src="'+zi+'" alt="image-20240731080212881"></p><h4 id="c-索引签名" tabindex="-1"><a class="header-anchor" href="#c-索引签名" aria-hidden="true">#</a> C）索引签名</h4><p><img src="'+Gi+'" alt="image-20240222133139002"></p><p>有的时候，你不能提前知道一个类型里的所有属性的名字，但是你知道这些值的特征。这种情况，你就可以用一个索引签名 (index signature) 来描述可能的值的类型。一个索引签名的属性类型必须是 string 或者是 number。</p><p><img src="'+Wi+'" alt="image-20240731125231721"></p><p>索引签名有什么用？索引签名的理解，如下：</p><p><img src="'+Qi+'" alt="image-20240731183827677"></p><p>官方文档说明如下：</p><p><img src="'+Xi+'" alt="image-20240731183657011"></p><p>索引签名案例，定义一个函数，函数的参数接收一个可迭代对象，那么参数有可能是数组，也有可能是元组。代码如下：</p><p><img src="'+Yi+'" alt="image-20240731184253735"></p><p>注意点一：索引类型问题，索引签名的索引类型只能是number类型或string(官方文档有说明)，代码如下：</p><p><img src="'+Zi+'" alt="image-20240731185541719"></p><p>官方文档解释如下：</p><p><img src="'+$i+'" alt="image-20240731184742375"></p><p>注意点二：[index: string]: any，可以取出数组元素。因为例如：names[0]，数字零会被转换成字符串&#39;0&#39;，因此这也写也是正确的。代码如下：</p><p><img src="'+a0+'" alt="image-20240731190210462"></p><p>官方文档的说明如下：</p><p><img src="'+i0+'" alt="image-20240731190530036"></p><p>注意点三：当我属性为string类型，返回值为string类型时，为什么会报错？这是因为我们不只是可以通过字符串索引获取到数组内的字符串元素，我们还可以获取到函数等等一系列其他方法。代码如下：</p><p><img src="'+s0+'" alt="image-20240731191235444"></p><p>解决方式一：注意即使避免严格字面量赋值监测，也不能避免报错。代码如下：</p><p><img src="'+e0+'" alt="image-20240731191627660"></p><p>解决方式二：返回值使用any类型可以解决，代码如下:</p><p><img src="'+p0+'" alt="image-20240731191911312"></p><p>注意点四：一个接口中可以写多个索引签名，数字类型的索引签名的返回值代码如下：</p><p><img src="'+t0+'" alt="image-20240731195750772"></p><p>规则一：数字类型索引的返回值必须是字符串索引类型返回值的子类型。代码如下：</p><p><img src="'+g0+'" alt="image-20240731200534998"></p><p>规则二：如果索引签名中有定义其他属性，那么其他属性返回的类型，必须符合string类型返回的属性。代码如下：</p><p><img src="'+n0+'" alt="image-20240731202330995"></p><h3 id="_4-ts接口补充" tabindex="-1"><a class="header-anchor" href="#_4-ts接口补充" aria-hidden="true">#</a> 4. TS接口补充</h3><h4 id="a-接口继承" tabindex="-1"><a class="header-anchor" href="#a-接口继承" aria-hidden="true">#</a> A）接口继承</h4><p><img src="'+r0+'" alt="image-20240222133252724"></p><p>接口和类一样是可以进行继承的，也是使用extends关键字。 并且我们会发现，接口是支持多继承的（类不支持多继承）。代码如下：</p><p><img src="'+m0+'" alt="image-20240731094409508"></p><h4 id="b-接口的实现" tabindex="-1"><a class="header-anchor" href="#b-接口的实现" aria-hidden="true">#</a> B）接口的实现</h4><p><img src="'+c0+'" alt="image-20240222133402009"></p><p>接口和类型别名还有一个区别，就是接口可以被类实现。这样创建出来的每一个实例对象都是Ikun类型。代码如下：</p><p><img src="'+o0+'" alt="image-20240731095534388"></p><p>除此之外，类可以实现多个接口，每一个接口中的属性和方法都需要实现。代码如下：</p><p><img src="'+d0+'" alt="image-20240731100226936"></p><h4 id="c-抽象类和接口的区别" tabindex="-1"><a class="header-anchor" href="#c-抽象类和接口的区别" aria-hidden="true">#</a> C）抽象类和接口的区别</h4><p><img src="'+_0+'" alt="image-20240802231650490"></p><p>抽象类通常用于描述一系列关系紧密的类之间，接口只是用来描述一个类应该具有什么行为？</p><ul><li>抽象类是is a，接口是has a。</li><li>接口可以被多层实现，而抽象类只能单一继承。</li><li>抽象类中可以有实现体，接口中只能有函数的声明。</li></ul><p>例如：猫类和狗类，它们都是动物类，它们都实现跑的方法。但是猫类和汽车类，它们也都具有跑的方法，因此它们适用于接口。</p><p><img src="'+h0+'" alt="接口和抽象类的区别"></p><h3 id="_5-特殊-严格字面量检测" tabindex="-1"><a class="header-anchor" href="#_5-特殊-严格字面量检测" aria-hidden="true">#</a> 5. 特殊：严格字面量检测</h3><p><img src="'+l0+'" alt="image-20240222133504023"></p><p>奇怪的现象一：代码如下：</p><p><img src="'+x0+'" alt="image-20240731121150963"></p><p>奇怪的现象二：代码如下：</p><p><img src="'+b0+'" alt="image-20240731121830862"></p><p>为什么会出现上面这这些现象？</p><p><img src="'+j0+'" alt="image-20240222133535468"></p><p>每个对象字面量最初都被认为是“新鲜的（fresh）”。当一个新的对象字面量分配给一个变量或传递给一个非空目标类型的参数时，对象字面量指定目标类型中不存在的属性是错 误的。当类型断言或对象字面量的类型扩大时，新鲜度会消失。</p><p>解释一下这个现象：</p><ul><li>第一次创建的对象字面量，称之为fresh(新鲜)的。</li><li>对于新鲜的字面量，会进行严格的类型监测，必须完全满足类型的要求(不能有多余的属性)。</li></ul><p><img src="'+f0+'" alt="image-20240731124124980"></p><h3 id="_6-ts枚举类型" tabindex="-1"><a class="header-anchor" href="#_6-ts枚举类型" aria-hidden="true">#</a> 6. TS枚举类型</h3><h4 id="a-什么是枚举类型" tabindex="-1"><a class="header-anchor" href="#a-什么是枚举类型" aria-hidden="true">#</a> A）什么是枚举类型</h4><p><img src="'+u0+'" alt="image-20240222133635541"></p><p>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型。枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型。</p><p><img src="'+y0+'" alt="image-20240802232939469"></p><h4 id="b-枚举类型的值" tabindex="-1"><a class="header-anchor" href="#b-枚举类型的值" aria-hidden="true">#</a> B）枚举类型的值</h4><p><img src="'+T0+'" alt="image-20240222133706510"></p><p>枚举类型有默认值，默认值从0开始，代码如下：</p><p><img src="'+S0+'" alt="image-20240802233438480"></p><p>我们可以手动给枚举类型赋值，如果第一个值为100，后面会依次递增。代码如下：</p><p><img src="'+k0+'" alt="image-20240802233819719"></p><p>枚举类型也可以赋上字符串类型，代码如下：</p><p><img src="'+v0+'" alt="image-20240802234039333"></p><p>枚举类型的值还可以设置为，位运算。代码如下：</p><p><img src="'+w0+'" alt="image-20240802235046019"></p><h2 id="九-ts泛型编程" tabindex="-1"><a class="header-anchor" href="#九-ts泛型编程" aria-hidden="true">#</a> 九，TS泛型编程</h2><h3 id="_1-泛型语法的基本使用" tabindex="-1"><a class="header-anchor" href="#_1-泛型语法的基本使用" aria-hidden="true">#</a> 1. 泛型语法的基本使用</h3><h4 id="a-认识泛型" tabindex="-1"><a class="header-anchor" href="#a-认识泛型" aria-hidden="true">#</a> A）认识泛型</h4><p><img src="'+B0+'" alt="image-20240222135806351"></p><h4 id="b-泛型实现类型参数化" tabindex="-1"><a class="header-anchor" href="#b-泛型实现类型参数化" aria-hidden="true">#</a> B）泛型实现类型参数化</h4><p><img src="'+A0+'" alt="image-20240222135848758"></p><p>我们需要在函数中可以捕获到参数的类型是number，并且同时使用它来作为返回值的类型。</p><p>方式一：通过 &lt;类型&gt; 的方式将类型传递给函数。代码如下：</p><p><img src="'+C0+'" alt="image-20240803080224849"></p><p>方式二：通过类型推导（type argument inference），自动推到出我们传入变量的类型。代码如下：</p><p><img src="'+E0+'" alt="image-20240803080728902"></p><p>需要注意的时，当我们使用自动推导时，如果用的是const，那么推导出的类型是字面量类型，如果用的是let，推导出来的是string、number等类型。代码和效果如下：</p><p><img src="'+R0+'" alt="image-20240803081137846"></p><p>案例练习：实现useState。代码如下：</p><p><img src="'+J0+'" alt="image-20240803081822916"></p><p>因此我们可以使用泛型，让我们编写的useState类型更加通用。代码如下：</p><p><img src="'+D0+'" alt="image-20240803092238120"></p><p>当然，我们也可以使用类型推断，如果自动推导出来的类型不正确，我们可以手动传入类型。代码如下：</p><p><img src="'+I0+'" alt="image-20240803093345006"></p><h4 id="c-泛型的基本补充" tabindex="-1"><a class="header-anchor" href="#c-泛型的基本补充" aria-hidden="true">#</a> C）泛型的基本补充</h4><p><img src="'+P0+'" alt="image-20240222140031235"></p><p>泛型支持传入多个类型，代码如下：</p><p><img src="'+N0+'" alt="image-20240803094414417"></p><p>平时在开发中我们可能会看到一些常用的名称，这些都是简写。代码如下：</p><p><img src="'+q0+'" alt="image-20240803094640490"></p><h3 id="_2-泛型接口、类的使用" tabindex="-1"><a class="header-anchor" href="#_2-泛型接口、类的使用" aria-hidden="true">#</a> 2. 泛型接口、类的使用</h3><h4 id="a-泛型接口" tabindex="-1"><a class="header-anchor" href="#a-泛型接口" aria-hidden="true">#</a> A）泛型接口</h4><p><img src="'+M0+'" alt="image-20240222140131656"></p><p>在定义接口的时候我们也可以使用泛型，代码如下：</p><p><img src="'+K0+'" alt="image-20240803101317915"></p><p>我们在使用泛型接口时，每次都要传入类型很麻烦。我们也可以使用默认值，代码如下：</p><p><img src="'+V0+'" alt="image-20240803102008890"></p><h4 id="b-泛型类" tabindex="-1"><a class="header-anchor" href="#b-泛型类" aria-hidden="true">#</a> B）泛型类</h4><p><img src="'+L0+'" alt="image-20240222140313503"></p><p>我们也可以编写一个泛型类，使类中的属性参数化。代码如下：</p><p><img src="'+O0+'" alt="image-20240803102602006"></p><h3 id="_3-泛型约束和类型条件" tabindex="-1"><a class="header-anchor" href="#_3-泛型约束和类型条件" aria-hidden="true">#</a> 3. 泛型约束和类型条件</h3><h4 id="a-泛型约束" tabindex="-1"><a class="header-anchor" href="#a-泛型约束" aria-hidden="true">#</a> A）泛型约束</h4><p><img src="'+U0+'" alt="image-20240222140404466"></p><p>有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中。比如string和array都是有length的，或者某些对象也是会有length属性的。那么只要是拥有length的属性都可以作为我们的参数类型，那么应该如何操作呢？</p><p>看下面这样的以一个案例，传入字符串、数组和对象类型。经过getInfo函数原封不动返回，发现丢失原有的类型，都变成了ILength属性。代码如下：</p><p><img src="'+F0+'" alt="image-20240803113131204"></p><p>那么我们应该怎么解决呢？使用泛型解决。代码和效果如下：</p><p><img src="'+H0+'" alt="image-20240803113824868"></p><p>因此我们可以使用类型约束，意味着类型可以参数化，同时加以约束，使其必须具备某些特性。代码和效果如下：</p><p><img src="'+z0+'" alt="image-20240803121253938"></p><h4 id="b-类型条件" tabindex="-1"><a class="header-anchor" href="#b-类型条件" aria-hidden="true">#</a> B）类型条件</h4><p><img src="'+G0+'" alt="image-20240222140638781"></p><p>在泛型约束中使用类型参数，你可以声明一个类型参数，这个类型参数被其他类型参数约束。</p><p>举个栗子：我们希望获取一个对象给定属性名的值。</p><ul><li>我们需要确保我们不会获取 obj 上不存在的属性。</li><li>所以我们在两个类型之间建立一个约束。</li></ul><p>我们希望该函数的第二个参数，满足是info对象中key的其中一个。但是我们此时却可以传入address，不符合条件。代码如下：</p><p><img src="'+W0+'" alt="image-20240803142215305"></p><p>因此我们需要对泛型参数进行约束，因此我们可以使用keyof，我们先来了解一下什么是keyof，代码和效果如下：</p><p><img src="'+Q0+'" alt="image-20240803143023599"></p><p>因此我们可以使用keyof约束传递进来的第二个参数，该参数必须满足所有key构成的联合类型，代码如下：</p><p><img src="'+X0+'" alt="image-20240803143657718"></p><h3 id="_4-ts映射类型" tabindex="-1"><a class="header-anchor" href="#_4-ts映射类型" aria-hidden="true">#</a> 4. TS映射类型</h3><h4 id="a-映射类型" tabindex="-1"><a class="header-anchor" href="#a-映射类型" aria-hidden="true">#</a> A）映射类型</h4><p><img src="'+Y0+'" alt="image-20240222140841417"></p><p>有的时候，一个类型需要基于另外一个类型，但是你又不想拷贝一份，这个时候可以考虑使用映射类型。</p><p><img src="'+Z0+'" alt="image-20240803175643290"></p><h4 id="b-映射修饰符" tabindex="-1"><a class="header-anchor" href="#b-映射修饰符" aria-hidden="true">#</a> B）映射修饰符</h4><p><img src="'+$0+'" alt="image-20240222141027619"></p><p>我们通常在使用映射类型拷贝某一个类型时，还会用到一些修饰符，代码如下：</p><p><img src="'+as+'" alt="image-20240803184135159"></p><p>除了使用readonly修饰符和?可选修饰符，我们还可以在前面添加修饰符符号-+，代码如下：</p><p><img src="'+is+'" alt="image-20240803190340151"></p><h3 id="_5-ts条件类型" tabindex="-1"><a class="header-anchor" href="#_5-ts条件类型" aria-hidden="true">#</a> 5. TS条件类型</h3><p><img src="'+ss+'" alt="image-20240806132047427"></p><h4 id="a-条件类型基本使用" tabindex="-1"><a class="header-anchor" href="#a-条件类型基本使用" aria-hidden="true">#</a> A）条件类型基本使用</h4><p>条件类型（Conditional types）就是用来帮助我们描述输入类型和输出类型之间的关系。</p><p><img src="'+es+'" alt="image-20240806132711263"></p><h4 id="b-条件类型案例" tabindex="-1"><a class="header-anchor" href="#b-条件类型案例" aria-hidden="true">#</a> B）条件类型案例</h4><p>之前我们使用函数的重载，编写了两个数字或两个字符串相加的函数。现在我们使用条件类型将其改造。将两个重载签名的代码，改写为一行。代码如下：</p><p>第一步：回顾之前编写的函数重载，代码如下：</p><p><img src="'+ps+'" alt="image-20240806134109690"></p><p>第二步：对函数重载代码进行简化。</p><p>方式一：对参数和返回值使用联合类型。代码和效果如下：</p><p><img src="'+ts+'" alt="image-20240806135041786"></p><p>方式二：使用泛型。</p><p><img src="'+gs+'" alt="image-20240806135355511"></p><p>方式三：使用泛型约束，代码如下：</p><p><img src="'+ns+'" alt="image-20240806135844241"></p><p>第三步：使用泛型约束加条件类型，此时返回值不再是一个联合类型。代码和效果如下：</p><p><img src="'+rs+'" alt="image-20240806140735702"></p><h4 id="c-条件类型中infer" tabindex="-1"><a class="header-anchor" href="#c-条件类型中infer" aria-hidden="true">#</a> C）条件类型中infer</h4><p><img src="'+ms+'" alt="image-20240806152236172"></p><p>先来了解TS的一个内置工具，ReturnType。用来获取函数类型的返回值类型。代码和效果如下：</p><p><img src="'+cs+'" alt="image-20240806154549237"></p><p><img src="'+os+'" alt="image-20240806154805127"></p><p>后续React中的redux中，我们会用到ReturnType工具。</p><p>现在我们想自己实现一个ReturnType工具。</p><p>第一步：因为ReturnType工具可以接收一个类型，因此我们编写的工具也需要接收一个类型，所以使用泛型，代码如下：</p><p><img src="'+ds+'" alt="image-20240806155837631"></p><p>第二步：因为该工具只接受函数类型，因此我们需要使用泛型约束来限制条件。</p><p>1）使用泛型约束对传入的类型进行限制，代码如下：</p><p><img src="'+_s+'" alt="image-20240806160133490"></p><p><img src="'+hs+'" alt="image-20240806160436979"></p><p>2）但是MyReturnType工具的返回值仍然是any类型，我们需要对其进行处理。代码和效果如下：</p><p><img src="'+ls+'" alt="image-20240806161439766"></p><p>我们对上述代码进行改造，实现MyParameterType工具。以此返回函数类型的参数类型。代码如下：</p><p><img src="'+xs+'" alt="image-20240806163059546"></p><h4 id="d-分发条件类型" tabindex="-1"><a class="header-anchor" href="#d-分发条件类型" aria-hidden="true">#</a> D）分发条件类型</h4><p><img src="'+bs+'" alt="image-20240806165453549"></p><p>使用泛型，根据传入的类型，生产对应的数组类型。代码如下：</p><p><img src="'+js+'" alt="image-20240806165921484"></p><p>如果传入一个联合类型，那么返回的类型是可以存放字符串或数字的数组。代码如下：</p><p><img src="'+fs+'" alt="image-20240806170222033"></p><p>但是我们希望得到字符串类型数组联合数字类型数组(number[] | string[]）。我们应该怎么做？使用条件类型中的分发类型。</p><p>当在泛型中使用条件类型的时候，如果传入一个联合类型，就会变成分发的。代码和效果如下：</p><p><img src="'+us+'" alt="image-20240806171651616"></p><p>这个在我们做一些类型体操相关的东西时，才会有用。</p><h2 id="十-类型工具和类型体操" tabindex="-1"><a class="header-anchor" href="#十-类型工具和类型体操" aria-hidden="true">#</a> 十，类型工具和类型体操</h2><h3 id="_1-内置工具" tabindex="-1"><a class="header-anchor" href="#_1-内置工具" aria-hidden="true">#</a> 1，内置工具</h3><p><img src="'+ys+'" alt="image-20240222141335413"></p><h4 id="a-partial-type" tabindex="-1"><a class="header-anchor" href="#a-partial-type" aria-hidden="true">#</a> A）Partial&lt; Type &gt;</h4><p>用于构造一个Type下面的所有属性都设置为可选的类型，代码和效果如下：</p><p><img src="'+Ts+'" alt="image-20240806172326111"></p><p>类型体操：我们可以自己实现一个类似Partial的工具。代码和效果如下：</p><p><img src="'+Ss+'" alt="image-20240806172708917"></p><h4 id="b-required-type" tabindex="-1"><a class="header-anchor" href="#b-required-type" aria-hidden="true">#</a> B）Required&lt; Type &gt;</h4><p><img src="'+ks+'" alt="image-20240806172752106"></p><p>用于构造一个Type下面的所有属性全都设置为必填的类型，这个工具类型跟 Partial 相反。</p><p><img src="'+vs+'" alt="image-20240806172954388"></p><p>类型体操：自己手动实现类似Required工具效果如下：</p><p><img src="'+ws+'" alt="image-20240806173202344"></p><h4 id="c-readonly-type" tabindex="-1"><a class="header-anchor" href="#c-readonly-type" aria-hidden="true">#</a> C）Readonly&lt; Type &gt;</h4><p><img src="'+Bs+'" alt="image-20240806173304039"></p><p>用于构造一个Type下面的所有属性全都设置为只读的类型，意味着这个类型的所有的属性全都不可以重新赋值。</p><p><img src="'+As+'" alt="image-20240806173432871"></p><p>手动实现类似Readonly内置工具效果，代码如下：</p><p><img src="'+Cs+'" alt="image-20240806173636395"></p><h4 id="d-record-type" tabindex="-1"><a class="header-anchor" href="#d-record-type" aria-hidden="true">#</a> D）Record&lt; Type &gt;</h4><p><img src="'+Es+'" alt="image-20240806173803528"></p><p>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。</p><p><img src="'+Rs+'" alt="image-20240806185539956"></p><p>使用Record产生的新对象类型，代码如下：</p><p><img src="'+Js+'" alt="image-20240806185702373"></p><p>类型体操：手动实现Record工具。使用映射类型，in操作符后必须跟联合类型。代码如下：</p><p><img src="'+Ds+'" alt="image-20240806233102626"></p><p>现在报错，是因为我们没有强制要求传入的Keys必须是一个联合类型。代码如下：</p><p><img src="'+Is+'" alt="image-20240806233750291"></p><h4 id="e-pick-type-keys" tabindex="-1"><a class="header-anchor" href="#e-pick-type-keys" aria-hidden="true">#</a> E）Pick&lt; Type，Keys &gt;</h4><p><img src="'+Ps+'" alt="image-20240806233914323"></p><p>用于构造一个类型，它是从Type类型里面挑了一些属性Keys。代码如下：</p><p><img src="'+Ns+'" alt="image-20240806234500005"></p><p>类型体操：手动实现Pick工具，代码和效果如下：</p><p><img src="'+qs+'" alt="image-20240806234914753"></p><h4 id="f-omit-type-keys" tabindex="-1"><a class="header-anchor" href="#f-omit-type-keys" aria-hidden="true">#</a> F）Omit&lt; Type, Keys&gt;</h4><p><img src="'+Ms+'" alt="image-20240806235023620"></p><p>用于构造一个类型，它是从Type类型里面过滤了一些属性Keys。代码如下：</p><p><img src="'+Ks+'" alt="image-20240806235323621"></p><p>类型体操：手动实现Omit工具，代码如下：</p><p><img src="'+Vs+'" alt="image-20240807000753238"></p><h4 id="g-exclude-uniontype-excludedmembers" tabindex="-1"><a class="header-anchor" href="#g-exclude-uniontype-excludedmembers" aria-hidden="true">#</a> G）Exclude&lt; UnionType, ExcludedMembers &gt;</h4><p><img src="'+Ls+'" alt="image-20240807123530469"></p><p>用于构造一个类型，它是从UnionType联合类型里面排除了所有可以赋给ExcludedMembers的类型。代码如下：</p><p><img src="'+Os+'" alt="image-20240807123716095"></p><p>类型体操：手动实现Exclude工具，代码如下：</p><p><img src="'+Us+'" alt="image-20240807124523670"></p><h4 id="h-extract-type-union" tabindex="-1"><a class="header-anchor" href="#h-extract-type-union" aria-hidden="true">#</a> H）Extract&lt; Type, Union&gt;</h4><p><img src="'+Fs+'" alt="image-20240807124646835"></p><p>用于构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型。代码如下：</p><p><img src="'+Hs+'" alt="image-20240807124847598"></p><p>类型体操：手动实现Extract工具。代码如下：</p><p><img src="'+zs+'" alt="image-20240807125113849"></p><p><img src="'+Gs+'" alt="image-20240807125326740"></p><h4 id="i-nonnullable-type" tabindex="-1"><a class="header-anchor" href="#i-nonnullable-type" aria-hidden="true">#</a> I）NonNullable&lt; Type &gt;</h4><p><img src="'+Ws+'" alt="image-20240807125442580"></p><p>用于构造一个类型，这个类型从Type中排除了所有的null、undefined的类型。代码如下：</p><p><img src="'+Qs+'" alt="image-20240807125742438"></p><p>类型体操：手动实现NonNullable工具，代码如下：</p><p><img src="'+Xs+'" alt="image-20240807130224882"></p><h4 id="j-returntype-type" tabindex="-1"><a class="header-anchor" href="#j-returntype-type" aria-hidden="true">#</a> J）ReturnType&lt; Type &gt;</h4><p><img src="'+Ys+'" alt="image-20240807130501178"></p><p>用于构造一个含有Type函数的返回值的类型。</p><h4 id="k-instancetype-type" tabindex="-1"><a class="header-anchor" href="#k-instancetype-type" aria-hidden="true">#</a> K）InstanceType&lt; Type &gt;</h4><p><img src="'+Zs+'" alt="image-20240807130551962"></p><p>typeof Person: 构造函数具体的类型，InstanceType构造函数创建出来的实例对象的类型。代码如下：</p><p><img src="'+$s+'" alt="image-20240807143047189"></p><p>应用案例：编写一个工厂函数，参数接收一个构造函数。代码如下：</p><p>第一步：创建工厂函数，并接受构造函数作为参数。工厂函数内部对传进来的构造函数new调用，返回实例对象。代码如下：</p><p><img src="'+ae+'" alt="image-20240807150305177"></p><p><img src="'+ie+'" alt="image-20240807150553052"></p><p>第二步：使用泛型和泛型约束，代码如下：</p><p><img src="'+se+'" alt="image-20240807151321625"></p><p>第三步：返回值不要写T类型，代码和效果如下：</p><p><img src="'+ee+'" alt="image-20240807151909938"></p><p>第四步：返回值类型使用InstanceType工具，代码和效果如下：</p><p><img src="'+pe+'" alt="image-20240807152207180"></p><p>类型体操：如何实现InstanceType工具，代码如下：</p><p><img src="'+te+'" alt="image-20240807153441310"></p><h2 id="十一-ts知识扩展" tabindex="-1"><a class="header-anchor" href="#十一-ts知识扩展" aria-hidden="true">#</a> 十一，TS知识扩展</h2><h3 id="_1-ts模块化使用" tabindex="-1"><a class="header-anchor" href="#_1-ts模块化使用" aria-hidden="true">#</a> 1. TS模块化使用</h3><h4 id="a-基本使用-2" tabindex="-1"><a class="header-anchor" href="#a-基本使用-2" aria-hidden="true">#</a> A）基本使用</h4><p><img src="'+ge+'" alt="image-20240222141952495"></p><p>在TS中推荐使用ESMoudle，使用方式和在JS中一样。代码和效果如下：</p><p><img src="'+ne+'" alt="image-20240805205514001"></p><h4 id="b-非模块" tabindex="-1"><a class="header-anchor" href="#b-非模块" aria-hidden="true">#</a> B）非模块</h4><p><img src="'+re+'" alt="image-20240222142017207"></p><p>我们需要先理解 TypeScript 认为什么是一个模块。</p><ul><li>没有export的JS文件被认为是一个脚本，而不是模块。对于TS来说也是如此。</li><li>在一个脚本文件中，遍历和类型会被声明在共享的全局作用域。</li><li>如果你有一个文件，现在没有任何import或export，但是你希望它被当作模块处理，添加export {}</li><li>这会把文件改成一个没有导出任何内容的模块。</li></ul><h4 id="d-内置类型导入" tabindex="-1"><a class="header-anchor" href="#d-内置类型导入" aria-hidden="true">#</a> D）内置类型导入</h4><p><img src="'+me+'" alt="image-20240222142035294"></p><p>TS中的模块化和JS还有一些区别，TS中不仅可以导出变量和函数，还可以导出类型。代码和效果如下：</p><p><img src="'+ce+'" alt="image-20240805210148878"></p><p>一般在TS中导入的是类型，推荐在前面加上type关键字。那么这样做有什么好处？</p><ul><li>编译器比如 Babel、swc 或者 esbuild 知道什么样的导入可以被安全移除。因为我们编写的TS代码经过编译后会变成去除类型的JS代码。因此编译之后类型声明文件没有用，因此我们需要告诉编译器。</li></ul><p>此外，如果我们导入了多个类型，我们可以统一添加type关键字，代码如下：</p><p><img src="'+oe+'" alt="image-20240805211324839"></p><p>在开发中，我们可以使用babel编译TS，也可以使用typescript compiler编译TS。</p><h3 id="_2-ts命名空间" tabindex="-1"><a class="header-anchor" href="#_2-ts命名空间" aria-hidden="true">#</a> 2. TS命名空间</h3><p><img src="'+de+'" alt="image-20240222142119180"></p><p>TypeScript 有它自己的模块格式，名为 namespaces ，它在 ES 模块标准之前出现。</p><ul><li>命名空间在TS早期，称之为内部模块，它将一个模块内部再进行作用域划分，防止命名冲突。</li><li>虽然TS没有将命名空间废弃，但是ES模块已经拥有了命名空间的大部分特性。因此更推荐使用 ES 模块，这样才能与 JavaScript 的（发展）方向保持一致。</li></ul><p>早期在没有ES模块化的情况下，我们使用TS的命名空间解决变量名冲突。</p><p>用法一：使用命名空间的TS代码中，不使用export关键字，因此该文件中的东西为全局的。代码如下：</p><p><img src="'+_e+'" alt="image-20240805212740836"></p><p>用法二：开发中就算使用命名空间，最好也将其放入的独立的模块中。这样命名空间的名字也不会冲突。代码如下：</p><p><img src="'+he+'" alt="image-20240805213845187"></p><p>想使用命名空间声明的变量和函数，依然需要使用export关键字导出，代码如下：</p><p><img src="'+le+'" alt="image-20240805214157751"></p><h3 id="_3-内置声明文件的使用" tabindex="-1"><a class="header-anchor" href="#_3-内置声明文件的使用" aria-hidden="true">#</a> 3. 内置声明文件的使用</h3><h4 id="a-类型的查找" tabindex="-1"><a class="header-anchor" href="#a-类型的查找" aria-hidden="true">#</a> A）类型的查找</h4><p><img src="'+xe+'" alt="image-20240222142254869"></p><p>.d.ts 文件，它是用来做类型的声明(declare)，称之为类型声明（Type Declaration）或者类型定义（Type Definition）文件。</p><p><img src="'+be+'" alt="image-20240805222814440"></p><p>那么typescript会在哪里查找我们的类型声明呢？</p><ul><li>内置类型声明；</li><li>外部定义类型声明；</li><li>自己定义类型声明；</li></ul><h4 id="b-内置类型声明" tabindex="-1"><a class="header-anchor" href="#b-内置类型声明" aria-hidden="true">#</a> B）内置类型声明</h4><p><img src="'+je+'" alt="image-20240222142343368"></p><p>内置类型声明文件：在我们全局安装typescript时，自动就安装了内置类型声明文件，操作如下：</p><p><img src="'+fe+'" alt="image-20240805223711311"></p><p>对代码document，ctrl加鼠标左键点击后，跳转到DOM相关的内置类型文件。如下：</p><p><img src="'+ue+'" alt="image-20240805224140421"></p><h4 id="c-内置声明环境" tabindex="-1"><a class="header-anchor" href="#c-内置声明环境" aria-hidden="true">#</a> C）内置声明环境</h4><p><img src="'+ye+'" alt="image-20240222142433505"></p>',703),kp={href:"https://github.com/microsoft/TypeScript/tree/main/src/lib",target:"_blank",rel:"noopener noreferrer"},vp=s('<p><img src="'+Te+'" alt="image-20240805225640362"></p><p><img src="'+Se+'" alt="image-20240805230548600"></p><h3 id="_5-ts运行在webpack中" tabindex="-1"><a class="header-anchor" href="#_5-ts运行在webpack中" aria-hidden="true">#</a> 5, TS运行在webpack中</h3><p>第一步：使用npm init -y命令，初始化一个包管理配置文件。操作如下：</p><p><img src="'+ke+'" alt="image-20240805232252134"></p><p>第二步：安装对应的包(开发依赖)，操作如下：</p><p><img src="'+ve+'" alt="image-20240805232415082"></p><p>第三步：在项目根目录创建webpack.config.js，配置打包所需相关配置。</p><p>1）配置以.ts的文件规则，并以-D的形式安装ts-loader。操作和代码如下：</p><p><img src="'+we+'" alt="image-20240805232912394"></p><p>2）安装html-webpack-plugin包，创建index.html作为模板，并配置对应的插件。代码和操作如下：</p><p><img src="'+Be+'" alt="image-20240805233529480"></p><p>3）配置插件的规则。代码如下：</p><p><img src="'+Ae+'" alt="image-20240805233707023"></p><p>第四步：搭建本地服务，实时查看运行结果。</p><p>1）安装webpack-dev-server，操作如下：</p><p><img src="'+Ce+'" alt="image-20240805234149284"></p><p>2）修改脚本命令，代码如下：</p><p><img src="'+Ee+'" alt="image-20240805234328215"></p><p>3）启动本地服务并查看效果。报错如下：</p><p><img src="'+Re+'" alt="image-20240805234559249"></p><p>4）使用tsc --init命令在根目录创建tsconfig.json配置文件，操作和效果如下：</p><p><img src="'+Je+'" alt="image-20240805234841269"></p><p>5）再次使用npm run serve开启本地服务，编译成功效果如下：</p><p><img src="'+De+'" alt="image-20240805235030742"></p><p>第五步：书写测试代码，查看效果，webpack环境搭建成功。如下：</p><p><img src="'+Ie+'" alt="image-20240806001125434"></p><p>第六步：更改tsconfig.json的相关配置，代码和效果如下：</p><p><img src="'+Pe+'" alt="image-20240806074209346"></p><p><img src="'+Ne+'" alt="image-20240806074835309"></p><h3 id="_4-第三方库声明的文件" tabindex="-1"><a class="header-anchor" href="#_4-第三方库声明的文件" aria-hidden="true">#</a> 4. 第三方库声明的文件</h3><p><img src="'+qe+'" alt="image-20240222142537269"></p><p>在使用第三方库时，有一些库默认带有类型声明文件，例如：axios。而对于React，不带有类型声明文件。因此我们需要单独安装。代码和操作如下：</p><p><img src="'+Me+'" alt="image-20240806082758487"></p><p>我们可以在查找第三方包的对应类型声明文件，安装后即可在项目中使用第三方包。如下：</p><p><img src="'+Ke+'" alt="image-20240806093705736"></p><p><img src="'+Ve+'" alt="image-20240806094126086"></p><h3 id="_5-编写自定义声明文件" tabindex="-1"><a class="header-anchor" href="#_5-编写自定义声明文件" aria-hidden="true">#</a> 5. 编写自定义声明文件</h3><p><img src="'+Le+'" alt="image-20240222142623695"></p><h4 id="a-情况一-给第三方库添加" tabindex="-1"><a class="header-anchor" href="#a-情况一-给第三方库添加" aria-hidden="true">#</a> A）情况一：给第三方库添加</h4><p><img src="'+Oe+'" alt="image-20240806101110310"></p><p>我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash(早期)，因此我们需要自己声明。</p><p>第一步：在项目根目录创建types/why.d.ts文件，并声明模块lodash，代码和效果如下：</p><p><img src="'+Ue+'" alt="image-20240806095213769"></p><p>但是我们并没有告诉外界lodash模块中有什么东西，因此我们在使用该模块时，没有提示。</p><p><img src="'+Fe+'" alt="image-20240806100137304"></p><p>第二步：在lodash模块中导出方法的类型，没有方法的实现。代码如下：</p><p><img src="'+He+'" alt="image-20240806100551544"></p><p>第三步：修改webpack配置文件中的mode选项为development，启动项目效果。如下：</p><p><img src="'+ze+'" alt="image-20240806100826408"></p><h4 id="b-给自己的文件添加类型声明" tabindex="-1"><a class="header-anchor" href="#b-给自己的文件添加类型声明" aria-hidden="true">#</a> B）给自己的文件添加类型声明</h4><p>我们给自己的代码中声明一些类型，方便在其他地方直接进行使用。对于自己代码的类型声明不需要单独抽离，放在当前位置即可。</p><p><img src="'+Ge+'" alt="image-20240806110321232"></p><p>在index.html的script标签中定义一些变量，在打包好之后它们应该属于同一个全局作用域。但是在index.ts中不能直接访问。代码如下：</p><p><img src="'+We+'" alt="image-20240806111100335"></p><p>我们需要在类型声明文件中，对这些变量定义类型声明，代码和效果如下：</p><p><img src="'+Qe+'" alt="image-20240806111408238"></p><p>浏览器效果如下：</p><p><img src="'+Xe+'" alt="image-20240806111500395"></p><p>不仅可以为普通的变量添加类型声明，还可以给在index.html的script标签中声明的函数和类，添加类型声明。代码如下：</p><p><img src="'+Ye+'" alt="image-20240806111913736"></p><p><img src="'+Ze+'" alt="image-20240806112341868"></p><h4 id="c-declare声明文件" tabindex="-1"><a class="header-anchor" href="#c-declare声明文件" aria-hidden="true">#</a> C）declare声明文件</h4><p><img src="'+$e+'" alt="image-20240222143006500"></p><p>在开发中，我们使用jpg这类文件，默认TS是不支持的，也需要对其进行声明。代码和效果如下：</p><p>第一步：在index.ts中，引入图片并使用，报错。效果如下：</p><p><img src="'+ap+'" alt="image-20240806113611448"></p><p>第二步：对这类文件模块进行声明，代码和效果如下：</p><p><img src="'+ip+'" alt="image-20240806113912213"></p><p>第三步：使用图片文件时，代码报错。因为webpack环境没有对图片文件进行配置。效果如下：</p><p><img src="'+sp+'" alt="image-20240806114246265"></p><p><img src="'+ep+'" alt="image-20240806114548119"></p><p><img src="'+pp+'" alt="image-20240806115521891"></p><p><img src="'+tp+'" alt="image-20240806115906584"></p><p>在TS环境中，如何使用vue文件？</p><p>第一步：创建vue文件，直接引入会报错。代码如下：</p><p><img src="'+gp+'" alt="image-20240806120529919"></p><p>第二步：对vue文件进行声明，代码如下：</p><p><img src="'+np+'" alt="image-20240806120805323"></p><h4 id="d-declare命名空间" tabindex="-1"><a class="header-anchor" href="#d-declare命名空间" aria-hidden="true">#</a> D）declare命名空间</h4><p><img src="'+rp+'" alt="image-20240222143218402"></p><p>通过CDN引入一个包，如何在TS环境中使用？例如：通过CND的方式引入Jquery并使用。</p><p>第一步：引入JqueryCND，并使用。代码报错如下：</p><p><img src="'+mp+'" alt="image-20240806121218775"></p><p>第二步：</p><p>方式一：通过声明模块进行使用，但是我们通过CDN的方式使用Jquery时，并没有通过import xxxx from xxx的方式进行引入。因此这种方式不合适。</p><p>方式二：将其声明为命名空间，操作如下：</p><p><img src="'+cp+'" alt="image-20240806131217137"></p><p>查看效果如下：</p><p><img src="'+op+'" alt="image-20240806131256570"></p><h3 id="_6-tsconfig配置文件解析" tabindex="-1"><a class="header-anchor" href="#_6-tsconfig配置文件解析" aria-hidden="true">#</a> 6. tsconfig配置文件解析</h3><p><img src="'+dp+'" alt="image-20240222143304941"></p><p><img src="'+_p+'" alt="image-20240222143333675"></p><p><img src="'+hp+'" alt="image-20240222143408870"></p><p><img src="'+lp+'" alt="image-20231001171716424"></p><p><img src="'+xp+'" alt="image-20231001171906758"></p><p><img src="'+bp+'" alt="image-20240222143534047"></p><p><img src="'+jp+'" alt="image-20240222143607909"></p><h2 id="十二-axios-封装" tabindex="-1"><a class="header-anchor" href="#十二-axios-封装" aria-hidden="true">#</a> 十二， Axios 封装</h2><p><img src="'+fp+'" alt="image-20231001204144716"></p>',100);function wp(Bp,Ap){const e=g("ExternalLinkIcon");return n(),r("div",null,[yp,i("p",null,[a("方式一：在webpack中配置ts-loader，"),i("a",Tp,[a("微信公众平台 (qq.com)"),p(e)]),a("。")]),Sp,i("p",null,[a("那么我们怎么知道TS帮我们内置了哪些类型声明文件，我们可以在"),i("a",kp,[a("TypeScript/src/lib at main · microsoft/TypeScript (github.com)"),p(e)]),a("查看。")]),vp])}const Ep=t(up,[["render",wp],["__file","14.html.vue"]]);export{Ep as default};
