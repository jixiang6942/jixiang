import{_ as e,o as l,c as i,b as t,d as a,f as p,a as n}from"./app-382cdfb3.js";const o={},r=n(`<h2 id="一-css面试题" tabindex="-1"><a class="header-anchor" href="#一-css面试题" aria-hidden="true">#</a> 一，CSS面试题</h2><h3 id="_1-css水平垂直居中的方式" tabindex="-1"><a class="header-anchor" href="#_1-css水平垂直居中的方式" aria-hidden="true">#</a> 1，css水平垂直居中的方式？</h3><h3 id="_2-如何实现一个三角形" tabindex="-1"><a class="header-anchor" href="#_2-如何实现一个三角形" aria-hidden="true">#</a> 2，如何实现一个三角形？</h3><h3 id="_3-定位的方式有哪些-区别是什么" tabindex="-1"><a class="header-anchor" href="#_3-定位的方式有哪些-区别是什么" aria-hidden="true">#</a> 3，定位的方式有哪些？区别是什么？</h3><h3 id="_4-如何实现一个左边固定200px宽度-右边自适应的布局" tabindex="-1"><a class="header-anchor" href="#_4-如何实现一个左边固定200px宽度-右边自适应的布局" aria-hidden="true">#</a> 4，如何实现一个左边固定200px宽度，右边自适应的布局？</h3><h3 id="_5-整理出网页从编写到浏览器显示的整个过程-重要-。" tabindex="-1"><a class="header-anchor" href="#_5-整理出网页从编写到浏览器显示的整个过程-重要-。" aria-hidden="true">#</a> 5，整理出网页从编写到浏览器显示的整个过程（重要）。</h3><p>前端工程师：</p><ul><li>开发项目</li><li>打包、部署项目到服务器</li></ul><p>用户：</p><ul><li>输入网址</li><li>DNS解析</li><li>服务器返回静态资源</li><li>浏览器渲染引擎解析</li></ul><h3 id="_6-服务器是什么-说出你的理解" tabindex="-1"><a class="header-anchor" href="#_6-服务器是什么-说出你的理解" aria-hidden="true">#</a> 6，服务器是什么？说出你的理解</h3><ul><li>向外提供资源的电脑</li><li>类似于电脑</li><li>24小时不关机</li><li>没有显示器</li><li>装的Linux操作系统</li></ul><h3 id="_7-说说你对元素语义化的理解" tabindex="-1"><a class="header-anchor" href="#_7-说说你对元素语义化的理解" aria-hidden="true">#</a> 7，说说你对元素语义化的理解</h3><ul><li>方便代码维护</li><li>减少开发者之间的沟通成本</li><li>能让语音合成工具正确识别网页元素的用途，以便做出正确的反应</li><li>有利于SEO</li></ul><h3 id="_8-说说你对seo的理解" tabindex="-1"><a class="header-anchor" href="#_8-说说你对seo的理解" aria-hidden="true">#</a> 8，说说你对SEO的理解</h3><ul><li>搜索引擎优化</li><li>通过搜索引擎运作的规则来调整网站</li><li>以及提供网站在有关搜索引擎内排名的方式</li></ul><h3 id="_9-总结元素隐藏的方法-并且说出他们的区别" tabindex="-1"><a class="header-anchor" href="#_9-总结元素隐藏的方法-并且说出他们的区别" aria-hidden="true">#</a> 9，总结元素隐藏的方法，并且说出他们的区别</h3><ul><li><p>display:none</p><ul><li>元素不显示出来, 并且也不占据位置, 不占据任何空间</li></ul></li><li><p>visibility:hidden</p><ul><li>会占据元素应该占据的空间</li></ul></li><li><p>rgba设置颜色,将a的值设置为0</p><ul><li>rgba的a设置的是alpha值, 可以设置透明度, 不影响子元素</li></ul></li><li><p>opacity设置透明度, 设置为0</p><ul><li>设置整个元素的透明度, 会影响所有的子元素</li></ul></li></ul><h3 id="_10-说说你对margin的传递和折叠的理解" tabindex="-1"><a class="header-anchor" href="#_10-说说你对margin的传递和折叠的理解" aria-hidden="true">#</a> 10，说说你对margin的传递和折叠的理解</h3><p>margin的传递一般是父子块元素之间,有margin-top传递,margin-bottom传递.</p><ul><li>margin-top传递: 当块级元素的顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top值会传递给父元素</li><li>margin-bottom传递:当块级元素的底部线和父元素的底部线重叠，那么这个块级元素的margin-bottom值会传递给父元素</li></ul><p>折叠: 指的是 垂直方向上相邻的2个margin（margin-top、margin-bottom）有可能会合并为1个margin.</p><p>它有两个兄弟块级元素之间的上下margin的折叠,也有父子块元素之间的margin折叠</p><h3 id="_11-块级元素在设置padding-border的上下时-有什么特殊的地方" tabindex="-1"><a class="header-anchor" href="#_11-块级元素在设置padding-border的上下时-有什么特殊的地方" aria-hidden="true">#</a> 11，块级元素在设置padding/border的上下时，有什么特殊的地方？</h3><p>上下会被撑起来,但是不占空间</p><h3 id="_12-说出元素水平居中的方案以及对应的场景" tabindex="-1"><a class="header-anchor" href="#_12-说出元素水平居中的方案以及对应的场景" aria-hidden="true">#</a> 12，说出元素水平居中的方案以及对应的场景</h3><ul><li><p>行内块元素(包括inline-block元素)</p><ul><li>水平居中：在父元素中设置text-align: center</li></ul></li><li><p>块级元素</p><ul><li>水平居中:margin:0 auto;</li></ul></li></ul><h3 id="_13-说出表单元素什么情况下使用name和value" tabindex="-1"><a class="header-anchor" href="#_13-说出表单元素什么情况下使用name和value" aria-hidden="true">#</a> 13，说出表单元素什么情况下使用name和value？</h3><ul><li>name元素的作用是后台接收数据时使用的键值对中的键(key) 随着表单的提交而一起提交 表单中不可或缺的元素 一个form表单中该元素的名称对应不同类型的input是不同的</li><li>value是 后台接收数据时使用的键值对中的值(value) value可以有默认值</li></ul><h3 id="_14-总结绝对定位的相对元素以及常见的解决方案" tabindex="-1"><a class="header-anchor" href="#_14-总结绝对定位的相对元素以及常见的解决方案" aria-hidden="true">#</a> 14，总结绝对定位的相对元素以及常见的解决方案</h3><h3 id="_15-总结浮动常见的规则内容" tabindex="-1"><a class="header-anchor" href="#_15-总结浮动常见的规则内容" aria-hidden="true">#</a> 15，总结浮动常见的规则内容</h3><h3 id="_16-说出为什么需要清除浮动以及如何清除浮动" tabindex="-1"><a class="header-anchor" href="#_16-说出为什么需要清除浮动以及如何清除浮动" aria-hidden="true">#</a> 16，说出为什么需要清除浮动以及如何清除浮动</h3><h3 id="_17-说说你对bfc的理解-面试题" tabindex="-1"><a class="header-anchor" href="#_17-说说你对bfc的理解-面试题" aria-hidden="true">#</a> 17，说说你对BFC的理解（面试题）</h3><ul><li><p>block format context(块级格式化上下文)</p><ul><li>是页面的一块渲染区域 并且有一套渲染规则,决定了子元素如何定位 以及与其他元素之间的排列 布局之间的关系</li><li>BFC是一个独立的布局环境 相当于是一个容器 在其中按照一定的规则对块级元素进行摆放 ,并且不会影响其他的布局环境中的盒子,如果一个元素触发BFC则BFC中的元素布局不受外界的影响</li></ul></li><li><p>块级元素在标准流中的布局是属于BFC的</p></li><li><p>创建BFC的条件:</p><ul><li>根元素: body/:root</li><li>float left/right</li><li>position absolute/fixed</li><li>overflow: 除visible</li><li>display: inline-block/table-cell/table-caption ,flex/grid...</li></ul></li><li><p>特点</p><ul><li>垂直方向 自上而下排布</li><li>垂直方向的间距由margin决定</li><li>同一个BFC中 盒子之间的margin会折叠</li><li>BFC中 每个元素的左边缘紧挨着包含快的左边缘</li><li>计算 BFC 的高度时，需要计算浮动元素的高度</li><li>BFC内部不会影响外部元素</li><li>BFC区域不会与浮动的元素发生重叠</li></ul></li><li><p>作用</p><ul><li>解决margin折叠的问题</li><li>解决高度塌陷的问题 <ul><li>前提 :浮动的父级BFC高度为auto</li></ul></li><li>创建两栏布局 <ul><li>左边浮动 右边overflow:hidden</li></ul></li></ul></li></ul><h3 id="_18-总结函数头等公民、函数回调、匿名函数等概念的理解" tabindex="-1"><a class="header-anchor" href="#_18-总结函数头等公民、函数回调、匿名函数等概念的理解" aria-hidden="true">#</a> 18，总结函数头等公民、函数回调、匿名函数等概念的理解</h3><p>一等公民：函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中</p><p>回调函数：一个函数作为另外一个函数的参数，称之为回调函数，也称为高阶函数</p><p>匿名函数：如果在传入一个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，那么这个函数称之为匿名函数</p><h3 id="_19-整理new操作背后的原理" tabindex="-1"><a class="header-anchor" href="#_19-整理new操作背后的原理" aria-hidden="true">#</a> 19，整理new操作背后的原理</h3><ol><li>new 操作的原理</li></ol><ul><li>在内存中创建一个空对象 ----比如var moni={}</li><li>将构造函数的显示原型赋值给这个对象的隐式原型 ----moni.<strong>proto</strong>=Person.prototype</li><li>this指向创建出来的新对象 ---this=moni</li><li>执行函数体代码</li><li>如果构造函数没有返回非空对象,那自动返回创建出来的新对象 ---return moni</li></ul><ol start="2"><li>全局对象的作用</li></ol><ul><li>查找变量时,最终会找到window</li><li>将浏览器全局提供给我们的变量/函数/对象 ,放在window对象上面 ,比如alert,console等</li><li>使用var 定义的变量会添加到window上</li></ul><ol start="3"><li>函数也是对象</li></ol><h3 id="_20-整理number、math的常见操作" tabindex="-1"><a class="header-anchor" href="#_20-整理number、math的常见操作" aria-hidden="true">#</a> 20，整理Number、Math的常见操作</h3><p>Number类的操作</p><ul><li>类属性 <ul><li>Number.MAX_SAFE_INTEGER 最大安全整数</li><li>Number.MIN_SAFE_INTEGER 最小安全整数</li></ul></li><li>实例方法 <ul><li>toString(base)，将数字转成字符串，并且按照base进制进行转化</li><li>toFixed(digits)，格式化一个数字，保留digits位的小数,会四舍五入</li></ul></li><li>类方法 <ul><li>Number.parseInt(string[, radix])，将字符串解析成整数，也有对应的全局方法parseInt；</li><li>Number. parseFloat(string)，将字符串解析成浮点数，也有对应的全局方法parseFloat；</li></ul></li></ul><p>Math的常见操作</p><ul><li><p>属性</p><ul><li>Math.PI：圆周率</li></ul></li><li><p>常见的方法</p><ul><li>Math.floor：向下舍入取整</li><li>Math.ceil：向上舍入取整</li><li>Math.round：四舍五入取整</li><li>Math.random：生成0~1的随机数（包含0，不包含1）</li><li>Math.pow(x, y)：返回x的y次幂</li></ul></li><li><p>公式: [a,b)的随机数</p><ul><li>y=a,x=b-a, Math.floor(Math.random() * x) + y</li></ul></li></ul><h3 id="_21-整理string的常见操作" tabindex="-1"><a class="header-anchor" href="#_21-整理string的常见操作" aria-hidden="true">#</a> 21，整理String的常见操作</h3><ul><li><p>创建方式 new String()</p></li><li><p>属性</p><ul><li>length ---获取字符串的长度</li></ul></li><li><p>访问其中元素</p><ul><li>[0]</li><li>charAt(0)</li></ul></li><li><p>遍历</p><ul><li>普通的for循环</li><li>for..of方式 <ul><li>可迭代对象</li><li>字符串/数组</li></ul></li></ul></li><li><p>字符串不可变性</p></li><li><p>实例方法:</p><ul><li>toUpperCase() 将所有的字符转成大写；</li><li>toLowerCase() 将所有的字符转成小写；</li><li>indexOf 查找字符串位置</li><li>includes 是否包含字符串</li><li>startsWith 判断是否以xxx开头</li><li>endsWith 判断是否以xxx结尾</li><li>repace 替换字符串</li><li>slice/substring/substr 获取子字符串</li><li>concat 字符串拼接</li><li>trim 去除首尾空格</li><li>split 字符串分割,字符串---&gt;数组 <ul><li>join 数组--&gt;字符串</li></ul></li></ul><h3 id="_22-整理array的常见操作" tabindex="-1"><a class="header-anchor" href="#_22-整理array的常见操作" aria-hidden="true">#</a> 22， 整理Array的常见操作</h3><ul><li><p>创建数组</p><ul><li>[] 数组字面量</li><li>new Array() <ul><li>传1个数组,表示数组的长度</li></ul></li></ul></li><li><p>数组基本操作</p><ul><li>获取元素 <ul><li>[0]</li><li>at(0)</li></ul></li><li>修改元素 <ul><li><code>arr[1] = &quot;fff&quot;</code></li></ul></li><li>新增 <ul><li><code>arr[5]=&quot;123&quot;</code></li></ul></li><li>删除 <ul><li><code>delete arr[0]</code></li></ul></li></ul></li><li><p>在数组的尾部:</p><ul><li>push 尾部添加</li><li>pop 删除尾部的最后一个元素,返回被删除的元素</li></ul></li><li><p>在数组首部</p><ul><li>unshift 首部添加</li><li>shift 删除首部的第一个元素,返回被删除的元素</li></ul></li><li><p>利器</p><ul><li>splice 在任何位置添加/删除/替换元素 <ul><li>start 从什么位置开始操作元素</li><li>deleteCount 删除元素的个数 <ul><li>2 删除2个</li><li>0 添加元素</li></ul></li><li>item1/item2 添加或者替换的元素</li></ul></li></ul></li></ul></li></ul><h3 id="_22-说出对dom和document对象的理解" tabindex="-1"><a class="header-anchor" href="#_22-说出对dom和document对象的理解" aria-hidden="true">#</a> 22，说出对DOM和document对象的理解</h3><ul><li>DOM:<code>文档对象模型(Document Object Model)将页面所有的内容表示为可以修改的对象</code><ul><li>浏览器将我们编写在HTML中的每一个元素(Element)都抽象成了一个个对象</li><li>所有这些对象都可以通过JavaScript来对其进行访问，那么我们就可以通过JavaScript来操作页面;</li><li>所以，我们将这个抽象过程称之为 文档对象模型(Document Object Model)</li></ul></li><li>Document节点表示的整个载入的网页，它的实例是全局的document对象: <ul><li><code>对DOM的所有操作都是从 document 对象开始的</code></li><li>它是DOM的入口点，可以从document开始去访问任何节点元素;</li></ul></li></ul><h3 id="_23-整理节点、元素的导航有哪些" tabindex="-1"><a class="header-anchor" href="#_23-整理节点、元素的导航有哪些" aria-hidden="true">#</a> 23，整理节点、元素的导航有哪些？</h3><ul><li>节点之间的导航: <ul><li>父节点:parentNode</li><li>前兄弟节点:previousSibling</li><li>后兄弟节点:nextSibling</li><li>子节点:childNodes</li><li>第一个子节点:firstChild</li><li>第二个子节点:lastChild</li></ul></li><li>元素之间的导航: <ul><li>父元素:parentElement</li><li>前兄弟节点:previousElementSibling</li><li>后兄弟节点:nextElementSibling</li><li>子节点:children</li><li>第一个子节点:firstElementChild</li><li>第二个子节点:lastElementChild</li></ul></li></ul><h3 id="_24-说说节点常见的属性" tabindex="-1"><a class="header-anchor" href="#_24-说说节点常见的属性" aria-hidden="true">#</a> 24，说说节点常见的属性</h3><ul><li>nodeName:获取node节点的名字</li><li>tagName:获取元素的标签名词</li><li>innerHTML:将元素中的 HTML 获取为字符串形式;设置元素中的内容</li><li>outerHTML:包含了元素的完整 HTML;innerHTML 加上元素本身一样</li><li>textContent:仅仅获取元素中的文本内容</li><li>nodeValue:用于获取非元素节点的文本内容</li><li>hidden:可以用于设置元素隐藏</li></ul><h3 id="_25-说说attribute和property的区别和关系" tabindex="-1"><a class="header-anchor" href="#_25-说说attribute和property的区别和关系" aria-hidden="true">#</a> 25，说说attribute和Property的区别和关系</h3><p>attribute</p><ul><li>浏览器解析HTML元素时 会将对应的属性(attribute)放在对应的元素对象上</li><li>具体分为标准的属性和非标准的属性 <ul><li>标准属性: id class href type value等等</li><li>非标准属性(自定义) :abc age height</li></ul></li></ul><p>Property</p><ul><li>对于标准的attribute 会在DOM对象上创建对应的property属性</li><li>大多数情况下 他们是相互作用的 改变其中一个 另一个也会随之改变</li><li>大多数情况 推荐获取attribute 使用property方式 因为它默认是有类型的</li></ul><h3 id="_26-说说事件冒泡和事件捕获的理解" tabindex="-1"><a class="header-anchor" href="#_26-说说事件冒泡和事件捕获的理解" aria-hidden="true">#</a> 26，说说事件冒泡和事件捕获的理解</h3><p>事件冒泡: 从最内层的元素向外依次传递的顺序, 默认是事件冒泡</p><p>事件捕获: 从外层到内层依次传递的顺序 ,可以通过addEventListener(&quot;click&quot;,fn,true) 监听事件捕获</p><h3 id="_27-eventtarget的使用" tabindex="-1"><a class="header-anchor" href="#_27-eventtarget的使用" aria-hidden="true">#</a> 27，EventTarget的使用</h3><ul><li>addEventListener: 注册某个事件类型以及事件处理函数</li><li>removeEventListener : 移除某个事件类型以及事件处理函数</li><li>dispatchEvent : 派发某个事件类型到EventTarget上</li></ul><h3 id="_28-说说你对事件委托的理解" tabindex="-1"><a class="header-anchor" href="#_28-说说你对事件委托的理解" aria-hidden="true">#</a> 28，说说你对事件委托的理解</h3><p>利用事件的冒泡机制，以及事件对象中可以准确获知触发事件的元素机制(e.target)，将子元素事件委托给父元素处理的现象</p><h3 id="_30-整理常见的事件-并且说出mouseenter和mouseover的区别" tabindex="-1"><a class="header-anchor" href="#_30-整理常见的事件-并且说出mouseenter和mouseover的区别" aria-hidden="true">#</a> 30，整理常见的事件，并且说出mouseenter和mouseover的区别</h3><p>常见事件</p><ul><li>鼠标事件 <ul><li>click</li><li>contextmenu 鼠标右键</li><li>mouseenter</li><li>mouseleave</li><li>mouseover</li><li>mouseout</li><li>mousemove 鼠标移动</li></ul></li><li>键盘事件 <ul><li>keydown</li><li>keypress</li><li>keyup <ul><li>通过key和code区分</li></ul></li></ul></li><li>表单事件 <ul><li>change</li><li>input</li><li>focus</li><li>blur</li><li>reset</li><li>submit</li></ul></li></ul><p>mouseenter</p><ul><li>不会冒泡</li><li>进入子元素的时候不会有任何行为</li></ul><p>mouseover</p><ul><li>会进行冒泡行为</li><li>进入子元素 会先out父元素 在over子元素 在over父元素</li></ul><h3 id="_31-说说load和domcontentloaded的区别" tabindex="-1"><a class="header-anchor" href="#_31-说说load和domcontentloaded的区别" aria-hidden="true">#</a> 31，说说load和DOMContentLoaded的区别</h3><p>load</p><ul><li>浏览器加载完所有的HTML 还加载完所有的外部资源 样式 图片等</li></ul><p>DOMContentLoaded</p><ul><li>HTML文档所有资源都加载完成 并构建了DOM树 但是一些外部资源还没有加载完成 如图片的src</li></ul><h3 id="_32-整理json的相关用法和应用场景" tabindex="-1"><a class="header-anchor" href="#_32-整理json的相关用法和应用场景" aria-hidden="true">#</a> 32，整理JSON的相关用法和应用场景</h3><h2 id="整理json的相关用法和应用场景" tabindex="-1"><a class="header-anchor" href="#整理json的相关用法和应用场景" aria-hidden="true">#</a> 整理JSON的相关用法和应用场景</h2><p>三种用法</p><ul><li>简单值: 数字 字符串 布尔类型</li><li>对象值 key value组成 必须添加双引号 value 可以是简单值 对象值 数组值</li><li>数组值 内容可以是对象值 简单值 数组值</li></ul><p>应用场景</p><ul><li>网络传输的JSON数据</li><li>项目的某些配置文件</li><li>非关系型数据库将JSON作为存储文件</li></ul><h3 id="_33-localstorage和sessionstorage的区别" tabindex="-1"><a class="header-anchor" href="#_33-localstorage和sessionstorage的区别" aria-hidden="true">#</a> 33，localStorage和sessionStorage的区别</h3><p>localStorage：存在硬盘里，关闭浏览器还存在。</p><p>sessionStorage：关闭内存中，关闭浏览器不存在。</p><h3 id="_34-整理this的绑定规则" tabindex="-1"><a class="header-anchor" href="#_34-整理this的绑定规则" aria-hidden="true">#</a> 34，整理this的绑定规则</h3><ul><li><p>默认绑定：独立函数调用，函数没有被绑定到某个对象上进行调用</p></li><li><p>隐式绑定：通过某个对象发起的函数调用，在调用对象内部有一个对函数的引用。</p></li><li><p>显式绑定：明确this指向的对象，第一个参数相同并要求传入一个对象。</p><ul><li>apply/call</li><li>bind</li></ul></li><li><p>new绑定：</p><ul><li>创建一个全新对象</li><li>新对象被执行prototype链接</li><li>新对象绑定到函数调用的this</li><li>如果函数没有返回其他对象，表达式会返回这个对象</li></ul></li></ul><h3 id="_35-说出apply、call、bind函数的用法和区别" tabindex="-1"><a class="header-anchor" href="#_35-说出apply、call、bind函数的用法和区别" aria-hidden="true">#</a> 35，说出apply、call、bind函数的用法和区别</h3><p>用法：</p><ul><li><p>​ apply</p><p>​ 第一个参数: 绑定this</p><p>​ 第二个参数: 传入额外的实参, 以数组的形式</p></li><li><p>​ call</p><p>​ 第一个参数: 绑定this</p><p>​ 参数列表: 后续的参数以多参数的形式传递, 会作为实参</p></li><li><p>​ bind(不希望obj对象身上有函数)</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
​    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// this -&gt; obj</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>区别：</p></li><li><p>call、apply和bind都可以改变函数的this指向</p></li><li><p>call、apply和bind第一个参数的是this要指向的对象</p></li><li><p>call、apply和bind都可以后续为函数传参，apply是将参数并成一个数组，call和bind是将参数依次列出</p></li><li><p>call、apply都是直接调用，bind生成的this指向改变函数需要手动调用。</p></li></ul><h3 id="_36-说出浏览器输入一个url到页面显示的过程" tabindex="-1"><a class="header-anchor" href="#_36-说出浏览器输入一个url到页面显示的过程" aria-hidden="true">#</a> 36，说出浏览器输入一个URL到页面显示的过程</h3><ul><li>首先通过DNS服务器进行域名解析</li><li>解析出对应的IP地址 然后从ip地址对应的主机发送http请求 获取对应的静态资源</li><li>默认情况服务器会返回index.html文件</li><li>然后浏览器内核开始解析HTML</li><li>首先 会解析对应的html 生成DOM Tree</li><li>解析过程中 如果遇到css的link标签 则会下载对应的css文件 <ul><li>下载css文件和生成DOM树是同时进行</li></ul></li><li>下载完对应的css文件后会进行css解析 生成CSSOM( CSS object model)</li><li>当DOM Tree和CSSTree都解析完成之后 会进行合并用来生成Render Tree(渲染树)</li><li>初步生成的渲染树会显示节点以及部分样式 但是并不表示每个节点的尺寸 位置信息 于是进行Layout(布局)来生成渲染树中节点的宽度 高度位置信息</li><li>经过Layout之后 浏览器内核将布局时的每个frame转屏幕上的每个像素点 将每个节点绘制到屏幕上</li></ul><p><code>注意: 第一次确定节点的大小位置 称之为布局(Layout) 之后对节点大小位置改变后的重新计算称之为回流</code></p><p>引起回流的情况:</p><ul><li>DOM结构发生改变(节点的增删)</li><li>修改了节点的布局(宽度 高度 字体大小等)</li><li>修改窗口的尺寸</li><li>调用getComputedStyle获取位置信息</li></ul><p><code>第一次绘制节点 渲染到页面上称之为绘制(paint) 之后重新绘制 称之为重绘</code></p><p>引起重绘情况:</p><ul><li>修改背景色颜色 等</li></ul><p><code>回流一定会引起重绘 所以回流非常消耗性能</code></p><p>如何避免回流</p><ul><li>尽量一次性的修改样式 <ul><li>通过添加classList</li></ul></li><li>避免频繁的操作DOM</li><li>避免通过getComputedStyle获取尺寸位置信息等</li><li>对于某些元素使用position:absolute/fixed <ul><li>开销较小 不会对其他元素造成影响</li></ul></li></ul><h3 id="_37-说说async和defer的使用以及区别" tabindex="-1"><a class="header-anchor" href="#_37-说说async和defer的使用以及区别" aria-hidden="true">#</a> 37，说说async和defer的使用以及区别</h3><p>浏览器在解析构建DOM树的过程中 如果遇到script元素会停止构建DOM树 先下载JavaScript代码 执行对应的脚本</p><p>但是某些JavaScript代码中可能存在对某个节点的操作 如果等待DOM树构建完成 之后在进行对应的操作 则会造成大量的回流和重绘</p><p>同时在如果JavaScript 代码过多 则浏览器处理的时间会过长 则会造成页面的阻塞</p><p>为了解决这个问题 出现了两个属性 async defer</p><p>defer</p><ul><li>脚本的下载会与DOM树的构建同时进行</li><li>如果脚本提前下载好了 则会等到DOM树构建完成之后 在DOMContentLoaded事件之前执行defer中的代码</li><li>同时多个defer属性的script标签 则会按照顺序执行</li><li>推荐放到head标签中 可以早解析</li><li>对于script默认的内容 会忽略</li></ul><p>async</p><ul><li>脚本的下载会与DOM树的构建同时进行</li><li>让一个脚本完全独立 脚本的解析 运行于DOM的构建无关</li><li>多个async属性的脚本不保证运行顺序</li><li>通常用于独立的脚本 对于其他脚本 DOM没有依赖</li></ul><h3 id="_38-写出v8引擎执行代码的大致流程" tabindex="-1"><a class="header-anchor" href="#_38-写出v8引擎执行代码的大致流程" aria-hidden="true">#</a> 38，写出v8引擎执行代码的大致流程</h3><h3 id="_39-整理javascript的代码的执行流程" tabindex="-1"><a class="header-anchor" href="#_39-整理javascript的代码的执行流程" aria-hidden="true">#</a> 39，整理JavaScript的代码的执行流程</h3><ul><li>首先在执行前会现在堆内存中开辟一块空间(GO) 存放一些初始的值 如Number String等等</li><li>还有代码中定义的一些变量 函数(在parser转成AST树的过程中存放在GO中的 )并没有赋值</li><li>同时在执行代码时在执行上下文栈(ECS)中存放一个全局执行上下文(GEC) 用于执行代码 <ul><li>GO中对应的函数 也会在堆内存中开辟出空间 为 Function Object 初始一些数据(name length scope chain等)</li></ul></li><li>开始执行代码</li><li>每个EC中有着三个重要的内容(VO scope chain 以及this)</li><li>VO指向对应的作用域(全局作用域(GO) 函数作用域(AO))</li><li>...</li></ul><h3 id="_40-说说你对go-ao-vo的理解以及作用域和作用域链的理解" tabindex="-1"><a class="header-anchor" href="#_40-说说你对go-ao-vo的理解以及作用域和作用域链的理解" aria-hidden="true">#</a> 40，说说你对GO/AO/VO的理解以及作用域和作用域链的理解</h3><p>GO</p><ul><li>Global Object JS代码在执行前会现在堆内存中创建一个全局对象(GO)</li><li>用于存放一些定义好的变量方法等包含Date Array String Number setTimeout等</li><li>同时有一个window属性指向自己</li><li>同时在语法分析转成AST的过程中也会将一些变量 函数 存放在GO中 只是变量的初始值为undefined</li></ul><p>AO</p><ul><li>函数在执行前会先在堆内存中创建一个AO(Activation Object)对象 里面存放这arguments 对应函数的形参 以及在函数中定义的变量 初始值为undefined</li></ul><p>VO</p><ul><li>Variable Object 在执行函数时 会在执行上下文栈(ECS)中进入一个函数执行上下文(FEC)其中有三个核心 核心之一是VO 指向的是该函数在内存中解析时创建的AO 而在全局执行上下文中指向的是GO</li></ul><p>作用域,作用域链</p><ul><li>当进入到一个执行上下文时 执行上下文会关联一个作用域链</li><li>通常作用域链在解析时就被确定 因此 作用域链域函数的定义位置有关 而与它的调用位置无关</li></ul><h3 id="_41-五-你是如何理解闭包的-闭包到底是什么" tabindex="-1"><a class="header-anchor" href="#_41-五-你是如何理解闭包的-闭包到底是什么" aria-hidden="true">#</a> 41，五. 你是如何理解闭包的,闭包到底是什么?</h3><p>广义上讲 JavaScript的函数都是闭包</p><p>狭义上将 JavaScript中的函数如果访问了外层作用域中的变量 则称为闭包</p><p>实现上是一个函数与包含它的作用的引用绑定在了一起的组合</p><h3 id="_42-闭包为什么会产生内存泄露以及如何解决" tabindex="-1"><a class="header-anchor" href="#_42-闭包为什么会产生内存泄露以及如何解决" aria-hidden="true">#</a> 42，闭包为什么会产生内存泄露以及如何解决</h3><ul><li><p>闭包使得原本该销毁的作用域由于内部函数的引用没有销毁 始终存在在堆内存中 因此产生了内存泄露</p></li><li><p>解决</p><ul><li>将保存着上层作用域引用的函数在使用完之后置为null将它的引用销毁在GC的下一次检查中 对应的内存就会被销毁</li></ul></li></ul><h3 id="_43-理解纯函数以及编写自己的纯函数" tabindex="-1"><a class="header-anchor" href="#_43-理解纯函数以及编写自己的纯函数" aria-hidden="true">#</a> 43，理解纯函数以及编写自己的纯函数</h3><p>纯函数：纯函数一般具有以下的特点：</p><ul><li>确定的输入一定会有确定的输出（外部环境的任何变化不会影响函数内部的操作产生的结果）</li><li>纯函数的执行不会产生副作用。（函数内部的操作也不会对函数外部产生任何影响）</li></ul><p>纯函数在react和redux中应用比较多。</p><h3 id="_44-说说你对严格模式的理解" tabindex="-1"><a class="header-anchor" href="#_44-说说你对严格模式的理解" aria-hidden="true">#</a> 44，说说你对严格模式的理解</h3><p>严格模式是一种JavaScript的限制模式，因为种种历史原因，JavaScript语言在非严格模式下是比较松散的。在JavaScript不断优化和加入新特性的过程中，为了兼容早期的JavaScript，一些错误和不规范的写法也被保留了下来。这些错误也不会被抛出。在开启了严格模式后，js引擎会以一种更严格的规范执行JavaScript代码，一些不规范的写法和错误也会直接抛出。</p><p>开启严格模式的方法：</p><ul><li>对文件开启：在文件的开头写上&quot;use strict&quot;</li><li>对函数开启：在函数的开头写上&quot;use strict&quot;</li></ul><p>严格模式下的语法限制：</p><ul><li>不允许意外创建全局变量（不写var、let、const这种声明变量的关键字）</li><li>会对静默失败的赋值操作抛出异常</li><li>试图删除不可删除的属性</li><li>不允许函数参数有相同的名称</li><li>不允许只有0开头的八进制语法</li><li>不允许使用with</li><li>无法获取eval中定义的变量</li><li>this绑定不会默认转成对象</li></ul><h3 id="_45-什么是原型、原型链" tabindex="-1"><a class="header-anchor" href="#_45-什么是原型、原型链" aria-hidden="true">#</a> 45，什么是原型、原型链？</h3><p>原型：在JavaScript中，每一个对象都会有一个属性[[prototype]]，这个属性就是对象的原型，这个属性的值也是一个对象，是原对象的原型对象。访问对象中属性时，会先在对象自身进行查找，如果没有找到，那么会去对象的原型对象上查找。</p><p>原型链：每个对象都有自己的原型对象，原型对象也有自己的原型对象。在访问对象的属性时，会沿着对象自身=&gt;自身的原型对象=&gt;原型对象的原型对象......这样的链条一路查找上去，这条链式结构就叫做原型链。原型链的尽头是Object的原型对象的[[prototype]]属性，值为null。</p><h3 id="_46-如何通过原型链实现继承" tabindex="-1"><a class="header-anchor" href="#_46-如何通过原型链实现继承" aria-hidden="true">#</a> 46，如何通过原型链实现继承？</h3><h3 id="_47-继承的各个方案以及优缺点" tabindex="-1"><a class="header-anchor" href="#_47-继承的各个方案以及优缺点" aria-hidden="true">#</a> 47，继承的各个方案以及优缺点</h3><p>方案一：直接将父类的prototype赋值给子类的prototype，父类和子类共享原型对象</p><p>缺点：在子类原型对象上添加方法和属性会影响到父类</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Pesrson</span><span class="token punctuation">.</span>prototype
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方案二：通过new操作符创建一个新的对象，将这个对象作为子类的原型对象(显式原型)</p><p>缺点：</p><ul><li>子类的实例对象继承过来的属性是在原型上的，无法打印</li><li>没有完美的实现属性的继承（子类的实对象可以从父类继承属性，也可以拥有自己的属性）</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> p
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方案三：通过new操作符创建一个新的对象，将这个对象作为子类的原型对象(显式原型)，并且在子类的内部通过借用构造函数的方法实现属性的继承</p><p>缺点：父类构造函数会被调用两次，并且子类的实例对象总是有两份相同的属性，一份在自身，一份在其原型对象上</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">arg1<span class="token punctuation">,</span> arg2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> p
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方案四：让子类的原型对象(显式原型)的原型对象(隐式原型)指向父类的原型对象(显式原型)</p><p>缺点：存在兼容性问题,<code>__proto__</code>属性只有部分游览器支持</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方案五：寄生组合式继承(ES5中实现继承的最终方案)</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span><span class="token parameter">Subtype<span class="token punctuation">,</span> Supertype</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Subtype</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token class-name">Supertype</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Subtype</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">&quot;constructor&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> Subtype
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">inherit</span><span class="token punctuation">(</span>Student<span class="token punctuation">,</span> Person<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_48-最终es5实现继承的方案" tabindex="-1"><a class="header-anchor" href="#_48-最终es5实现继承的方案" aria-hidden="true">#</a> 48，最终ES5实现继承的方案</h3><p>寄生组合式继承</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span><span class="token parameter">Subtype<span class="token punctuation">,</span> Supertype</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Subtype</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token class-name">Supertype</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Subtype</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">&quot;constructor&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> Subtype
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">inherit</span><span class="token punctuation">(</span>Student<span class="token punctuation">,</span> Person<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_49-继承关系图中的各个关系" tabindex="-1"><a class="header-anchor" href="#_49-继承关系图中的各个关系" aria-hidden="true">#</a> 49，继承关系图中的各个关系</h3><ul><li><p>Function、Object、函数对象Foo的关系</p></li><li><p>普通对象、Foo创建出来的对象之间的关系</p></li><li><p>上面所有内容之间的关系</p></li><li><p>Function.<strong>proto</strong> === Function.prototype</p><ul><li>当 Function看做一个对象时</li></ul></li><li><p>Object.<strong>proto</strong> == Function.prototype</p><ul><li>把Object 当成 new Function 创建出来的对象</li></ul></li><li><p>Foo.prototype.<strong>proto</strong> === Object.prototype</p><ul><li>Foo.prototype是个对象,所以有隐式原型</li></ul></li><li><p>Function.prototype.<strong>proto</strong> === Object.prototype</p><ul><li>Function.prototype 是个对象</li></ul></li><li><p>Foo.<strong>proto</strong> === Function.prototype</p><ul><li>Foo 看成new Function创建出来的对象</li></ul></li></ul><h3 id="_50-说说你对面向对象多态的理解" tabindex="-1"><a class="header-anchor" href="#_50-说说你对面向对象多态的理解" aria-hidden="true">#</a> 50，说说你对面向对象多态的理解</h3><ul><li>当对不同的数据类型执行同一个操作时, 如果表现出来的行为(形态)不一样, 那么就是多态的体现</li><li>继承也是多态的前提</li></ul><h3 id="_51-说说let、const和var的区别" tabindex="-1"><a class="header-anchor" href="#_51-说说let、const和var的区别" aria-hidden="true">#</a> 51，说说let、const和var的区别</h3><ul><li><p>作用域提升</p><ul><li>var声明的变量是会进行作用域提升</li><li>let、const没有进行作用域提升，但是会在解析阶段被创建出来</li><li>let,const具有暂时性死区</li></ul></li><li><p>块级作用域</p><ul><li>var不存在块级作用域</li><li>let和const存在块级作用域</li></ul></li><li><p>重复声明</p><ul><li>var允许重复声明变量</li><li>let和const在同一作用域不允许重复声明变量</li></ul></li><li><p>修改声明的变量</p><ul><li>let,var 可以修改声明的变量</li><li>const它表示保存的数据一旦被赋值，就不能被修改,但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容</li></ul></li></ul><h3 id="_52-理解let的块级作用域以及作用" tabindex="-1"><a class="header-anchor" href="#_52-理解let的块级作用域以及作用" aria-hidden="true">#</a> 52，理解let的块级作用域以及作用</h3><ul><li>let/const/class/function会形成块级作用域</li><li>当点击按钮时,用let定义i,会具有块级作用域</li></ul><h3 id="_53-掌握引用赋值-浅拷贝-深拷内存情况" tabindex="-1"><a class="header-anchor" href="#_53-掌握引用赋值-浅拷贝-深拷内存情况" aria-hidden="true">#</a> 53，掌握引用赋值-浅拷贝-深拷内存情况</h3><p>引用赋值: 将一个变量中存储的对对象的引用地址赋值给另一个变量</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> obj1 <span class="token operator">=</span> obj
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>浅拷贝:</p><ul><li>使用...运算符展开一个对象时是一种浅拷贝,</li><li>只是将对像内的内容进行简单的复制,</li><li>如果对象中存储的内容为另一个对象时,并不是将另一个对象进行复制,</li><li>而是将外面对象内存储的对里面对象的引用进行复制</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;xhf&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;james&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>obj<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>深拷贝:</p><ul><li>完完全全的创建一个和原来的对象有相同结构的新的对象,</li><li>如果对象中存储的有其他的对象,在拷贝后的对象中也创建一个新的和里面对象除了内存地址不同,其他完全相同的对象</li><li>改变新对象中的任何内容,都不会对我们进行拷贝的对象造成任何影响</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;xhf&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;james&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_54-说出proxy和object-defineproperty的区别" tabindex="-1"><a class="header-anchor" href="#_54-说出proxy和object-defineproperty的区别" aria-hidden="true">#</a> 54，说出Proxy和Object.defineProperty的区别</h3><ul><li><p>Proxy的设计初衷就是监听对象的改变,并且提供了13中方法监听对象的操作,大大方便了和丰富了对对象的监听操作</p><ul><li>拦截和监视外部对对象的访问</li><li>可以直接监听数组的变化</li></ul></li><li><p>Object.defineProperty</p><ul><li><p>该属性设计初衷是定义对象的属性,所以有些监听操作是监听不到的</p></li><li><p>对于复杂的对象,层级很深的话,需要深度监听</p></li><li><p>删除属性,添加属性是不能被监听的</p></li><li><p>不能监听数组的变化</p><ul><li>本质上是数组的length属性的数据属性描述符:</li><li>configurable: false 意味着length属性不能被修改,不能将length属性修改为存取属性描述符</li><li>所以数组长度的变化的不能被监听的</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span></span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token string-property property">&#39;0&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    
  <span class="token string-property property">&#39;1&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    
  <span class="token string-property property">&#39;2&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    
  <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="_55-说说reflect的作用和为什么需要使用它" tabindex="-1"><a class="header-anchor" href="#_55-说说reflect的作用和为什么需要使用它" aria-hidden="true">#</a> 55，说说Reflect的作用和为什么需要使用它</h3><p>Reflect</p><ul><li>是一个对象</li><li>提供了多种方法方便我们统一管理对象,在对对象进行操作时有些方法会有返回值,操作对象变的更加规范</li><li>Object作为构造函数,操作对象的方法放在它身上不是很合适,早期的设计不规范导致的</li><li>在使用Proxy监听对象时,使用Reflect避免了对原对象的直接操作</li></ul><h3 id="_56-什么是迭代器-什么是可迭代对象" tabindex="-1"><a class="header-anchor" href="#_56-什么是迭代器-什么是可迭代对象" aria-hidden="true">#</a> 56，什么是迭代器？什么是可迭代对象？</h3><ul><li><p><strong>迭代器</strong></p><ul><li><p>迭代器是帮助我们对某个数据结构进行遍历的对象</p></li><li><p>迭代器也是一个具体的对象，这个对象需要符合迭代器<strong>协议</strong></p><ul><li>迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式</li><li>在<code>JavaScript</code>中这个标准就是一个特定的<code>next</code>方法</li></ul></li><li><p><code>next</code>方法的要求</p><ul><li>一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：</li><li><code>done</code>（<code>boolean</code>） <ul><li>如果迭代器可以产生序列中的下一个值，则为 <code>false</code>。（这等价于没有指定 <code>done </code>这个属性。）</li><li>如果迭代器已将序列迭代完毕，则为 <code>true</code>。这种情况下，<code>value </code>是可选的，如果它依然存在，即为迭代结束之后的默认返回值。</li></ul></li><li><code>value</code><ul><li>迭代器返回的任何 <code>JavaScript </code>值。<code>done </code>为 <code>true </code>时可省略</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 封装一个为数组创建迭代器的函数</span>
<span class="token keyword">function</span> <span class="token function">createArrayIterator</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>**可迭代对象 **</p><ul><li><p>和迭代器不是一个概念</p><ul><li>当一个对象实现了<code>iterable protocol</code>协议时，它就是一个可迭代对象；</li><li>这个对象的要求是必须实现 <code>@@iterator</code>方法，在代码中我们使用 <code>Symbol.iterator </code>访问该属性</li></ul></li><li><p>转成这样的好处</p><ul><li>当一个对象变成一个可迭代对象的时候，就可以进行某些迭代操作</li><li>比如 <code>for...of</code> 操作时，其实就会调用它的<code> @@iterator</code> 方法</li></ul></li><li><p>实现可迭代协议的原生对象</p><ul><li><code>String</code>、<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>arguments</code>对象、<code>NodeList</code>集合...</li></ul></li><li><p>可迭代对象的应用</p><ul><li>JavaScript中语法：<code>for ...of</code>、展开语法（<code>spread syntax</code>）、<code>yield*</code>、解构赋值（<code>Destructuring_assignment</code>）</li><li>创建一些对象时：<code>new Map([Iterable])、new WeakMap([iterable])、new Set([iterable])、new WeakSet([iterable])</code></li><li>一些方法的调用：<code>Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable)</code></li></ul></li><li><p>迭代器的中断</p><ul><li>比如遍历的过程中通过<code>break、return、throw</code>中断了循环操作</li><li>比如在解构的时候，没有解构所有的值</li></ul></li><li><p>自定义类的迭代实现</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> height<span class="token punctuation">,</span> friends</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
		<span class="token operator">...</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 实例方法</span>
      <span class="token function">running</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token operator">/</span>      <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">const</span> iterator <span class="token operator">=</span> <span class="token punctuation">{</span>
          <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>friends<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>friends<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
              <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> iterator
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="_57-什么是生成器-生成器和迭代器有什么关系" tabindex="-1"><a class="header-anchor" href="#_57-什么是生成器-生成器和迭代器有什么关系" aria-hidden="true">#</a> 57，什么是生成器？生成器和迭代器有什么关系？</h3><p><strong>生成器 (ES6新增)</strong></p><ul><li><p>生成器函数也是一个函数，但是和普通的函数有一些区别</p><ul><li>首先，生成器函数需要在function的后面加一个符号：*</li><li>其次，生成器函数可以通过yield关键字来控制函数的执行流程：</li><li>最后，生成器函数的返回值是一个（生成器） <ul><li>生成器事实上是一种特殊的迭代器</li></ul></li></ul></li><li><p>生成器函数</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">生成器函数</span><span class="token operator">:</span> 
<span class="token number">1</span><span class="token punctuation">.</span>function后面会跟上符号<span class="token operator">:</span> <span class="token operator">*</span>
<span class="token number">2.</span>代码的执行可以被<span class="token keyword">yield</span>控制
<span class="token number">3.</span>生成器函数默认在执行时<span class="token punctuation">,</span> 返回一个生成器对象
    <span class="token operator">*</span> 要想执行函数内部的代码<span class="token punctuation">,</span> 需要生成器对象<span class="token punctuation">,</span> 调用它的next操作
    <span class="token operator">*</span> 当遇到<span class="token keyword">yield</span>时<span class="token punctuation">,</span> 就会中断执行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>生成器传递参数 -- next函数</p><ul><li>调用next函数的时候，可以给它传递参数，那么这个参数会作为上一个yield语句的返回值</li><li>也就是说我们是为本次的函数代码块执行提供了一个值</li></ul></li><li><p>生成器提前结束</p><ul><li>return传值后这个生成器函数就会结束，之后调用next不会继续生成值</li></ul></li><li><p>生成器抛出异常 -- throw函数</p><ul><li>抛出异常后我们可以在生成器函数中捕获异常</li><li>但是在catch语句中不能继续yield新的值了，但是可以在catch语句外使用yield继续中断函数的执行</li></ul></li><li><p>生成器替代迭代器</p><ul><li>使用yield来生产一个可迭代对象</li><li>这个时候相当于是一种yield的语法糖，只不过会依次迭代这个可迭代对象，每次迭代其中的一个值</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">createArrayIterator</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span><span class="token operator">*</span> arr
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>自定义类迭代 -- 生成器实现</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 以Person为例  添加到实例方法</span>
<span class="token operator">*</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>friends
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_58-异步函数和普通函数的区别" tabindex="-1"><a class="header-anchor" href="#_58-异步函数和普通函数的区别" aria-hidden="true">#</a> 58， 异步函数和普通函数的区别</h3><p><strong>异步函数</strong></p><ul><li><p>使用<code>async</code>关键字声明的函数</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// async function foo() {}</span>

<span class="token comment">// const bar = async function() {}</span>

<span class="token comment">// const baz = async () =&gt; {}</span>

<span class="token comment">// class Person {</span>
<span class="token comment">//   async running() {}</span>
<span class="token comment">// }</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>异步函数的执行流程</p><ul><li>异步函数的内部代码执行过程和普通的函数是一致的，默认情况下也是会被同步执行</li><li>返回值和普通函数的区别 <ul><li>情况一：异步函数也可以有返回值，但是异步函数的返回值相当于被包裹到<code>Promise.resolve</code>中</li><li>情况二：如果我们的异步函数的返回值是<code>Promise</code>，状态由会由<code>Promise</code>决定；</li><li>情况三：如果我们的异步函数的返回值是一个对象并且实现了<code>thenable</code>，那么会由对象的方<code>then</code>法来决定</li></ul></li><li>如果在<code>async</code>函数中抛出异常 <ul><li>并不会报错, 而是作为<code>Promise</code>的<code>reject</code>来传递</li></ul></li></ul></li></ul><h3 id="_59-说说线程和进程的区别以及关系" tabindex="-1"><a class="header-anchor" href="#_59-说说线程和进程的区别以及关系" aria-hidden="true">#</a> 59，说说线程和进程的区别以及关系</h3><ul><li><p><strong>进程</strong></p><ul><li>是<code>cpu</code>分配资源的最小单位；（是能拥有资源和独立运行的最小单位）</li><li>计算机已经运行的程序，是操作系统管理程序的一种方式 (<strong>官方说法</strong>)</li><li>可以认为启动一个应用程序，就会默认启动一个进程（也可能是多个进程）<strong>(个人解释)</strong></li><li>也可以说进程是线程的容器</li></ul></li><li><p><strong>线程</strong></p><ul><li>是<code>cpu</code>调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li><li>操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中 <strong>(官方说法)</strong></li><li>每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称之为主线程</li></ul></li><li><p><strong>操作系统的工作方式</strong></p><ul><li>如何做到同时让多个进程同时工作? <ul><li>因为<code>CPU</code>的运算速度非常快, 可以快速的在多个进程之间迅速的切换</li><li>当进程中的线程获取到世间片时, 就可以快速执行我们编写的代码</li><li>由于<code>CPU</code>执行速度过于变态, 对于用户来说是感受不到这种快速切换的</li></ul></li></ul></li><li><p><strong>浏览器中<code>JavaScript</code>线程</strong></p><ul><li><p><strong><code>JavaScript</code>为什么是单线程的</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom;这决定了它只能是单线程，否则会带来很复杂的同步问题。举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>进程容器是浏览器或者<code>Node</code></li></ul></li><li><p><strong>浏览器是多进程的?</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//  放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。所以，浏览器是一个多进程的。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM.所以，这个新标准并没有改变JavaScript单线程的本质。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>目前多数浏览器都是多进程的, 打开一个<code>tab</code>页面就会开启一个新的进程, 防止因为一个页面的卡死导致浏览器的强制退出</li><li>每个进程中又有很多的线程，其中包括执行<code>JavaScript</code>代码的线程</li></ul></li><li><p>线程中<code>JavaScript</code>代码的执行</p><ul><li>它是在一个单独的线程中执行的, 意味着<code>JavaScript</code>代码在同一时刻只能做一件事</li><li>这<strong>非常耗时</strong>, 意味着当前线程会被阻塞</li></ul></li><li><p>所以耗时的操作并不是在<code>JavaScript</code>线程中执行的</p><ul><li>浏览器的每个进程是多线程的，那么其他线程可以来完成这个耗时的操作</li><li>比如网络请求、定时器，只需要在特性的时候执行应该有的回调即可</li></ul></li></ul></li></ul><h3 id="_60-说说你对事件队列、微任务、宏任务的理解" tabindex="-1"><a class="header-anchor" href="#_60-说说你对事件队列、微任务、宏任务的理解" aria-hidden="true">#</a> 60，说说你对事件队列、微任务、宏任务的理解</h3><ul><li><strong>事件队列</strong><ul><li>事件队列是一种数据结构，可以存放要执行的任务。它符合<strong>队列</strong>“<strong>先进先出</strong>”的特点</li></ul></li><li><strong>宏/微任务</strong><ul><li>首先它们都是异步任务</li><li>宏任务列队 <ul><li>用来保存待执行的宏任务（回调）</li><li>如: <code>pajax、setTimeout、setInterval、DOM</code>监听、<code>UI Rendering</code>等 会被加入到宏列队</li></ul></li><li>微任务列队 <ul><li>用来保存待执行的微任务（回调）</li><li>如: <code>Promise</code>的<code>then</code>回调、 <code>Mutation Observer API、queueMicrotask()</code>等 会被加入到微列队</li></ul></li><li><code>JS</code>执行时会区别这两个队列 <ul><li><code>JS</code>引擎首先必须先执行所有的初始化同步任务代码</li><li>每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个取出来执行，</li><li>也就是优先级比宏任务高，且与微任务所处的代码位置无关</li><li>也就是宏任务执行之前，必须保证微任务队列是空的；</li><li>如果不为空，那么就优先执行微任务队列中的任务（回调）</li></ul></li></ul></li></ul><h3 id="_61-掌握微任务、宏任务相关的面试题" tabindex="-1"><a class="header-anchor" href="#_61-掌握微任务、宏任务相关的面试题" aria-hidden="true">#</a> 61，掌握微任务、宏任务相关的面试题</h3><h3 id="_62-正则表达式常见的规则练习" tabindex="-1"><a class="header-anchor" href="#_62-正则表达式常见的规则练习" aria-hidden="true">#</a> 62，正则表达式常见的规则练习</h3><p>正则: 字符串匹配利器</p><p>创建正则</p><ul><li>new RegExp()</li><li>//</li></ul><p>使用方法</p><ul><li>正则实例的方法 <ul><li>test 匹配则返回true否则返回false</li><li>exec 返回一个数组 未找到返回null</li></ul></li><li>字符串方法 <ul><li>match 返回一个数组 未找到返回null</li><li>matchAll 返回迭代器 必须有修饰符g</li><li>search 返回匹配到的位置索引 失败时返回-1</li><li>replace/replaceAll 替换掉匹配掉的字符串</li><li>split 使用正则表达式(或固定字符串)分割一个字符串将分割后的字符串存到数组中返回</li></ul></li></ul><p>修饰符</p><ul><li>g (global)</li><li>i (ignore 不分大小写)</li><li>m(多行匹配)</li></ul><p>规则</p><ul><li><p>字符类</p><ul><li>/d /D <ul><li>/d =&gt; [0-9]</li><li>/D =&gt; [^0-9]</li></ul></li><li>/s /S <ul><li>/s 空格符号 [ ]</li><li>/S 除/s匹配的值之外 [^ ]</li></ul></li><li>/w /W <ul><li>/w =&gt; [a-zA-Z_0-9]</li><li>/W =&gt; [^a-zA-Z_0-9]</li></ul></li><li>. <ul><li>与除换行符之外的任意字符匹配</li></ul></li></ul></li><li><p>锚点</p><ul><li>^ 开头</li><li>$ 结尾</li><li>\\b 词边界</li></ul></li><li><p>转义字符串</p><ul><li>\\ 对特殊字符转义(如[] \\ ^ $ . ? * + ())</li></ul></li><li><p>集合(Sets) 范围(Ranges)</p><ul><li>[]</li><li>[2,]</li><li>[2,6]</li></ul></li><li><p>量词(Quantifiers)</p><ul><li>数量{n}</li></ul></li><li><p>贪婪模式/ 惰性模式</p><ul><li>贪婪模式 默认匹配规则会匹配到符合条件的最后一个内容</li><li>惰性模式 ? 匹配到第一个符合规则的正则就返回</li></ul></li><li><p>捕获组</p><ul><li>()</li><li>(?😃 希望该)()中的内容去匹配但是不希望括号中的内容出现在结果中时</li><li>起别名 <ul><li>(?^(别名))</li></ul></li><li>| 或 <ul><li>(23|45)</li></ul></li></ul></li><li><p>(?)</p></li></ul><h3 id="_62-localstorage和sessionstorage的区别" tabindex="-1"><a class="header-anchor" href="#_62-localstorage和sessionstorage的区别" aria-hidden="true">#</a> 62，LocalStorage和SessionStorage的区别</h3><ul><li>LocalStorage提供一种永久性存储的方法 在网页关闭打开时 依然保留</li><li>SessionStorage: 会话存储 再关闭该网页时 存储的内容被清除</li><li>区别: <ul><li>localStorage永久性存储 SessionStorage在关闭当前页面时存储的内容就会失效</li><li>SessionStorage只能被同一个窗口的同源页面共享 localStorage除非手动删除 否则一直存在</li></ul></li></ul><h3 id="_63-说说你对防抖、节流的理解-他们的区别-应用场景-面试" tabindex="-1"><a class="header-anchor" href="#_63-说说你对防抖、节流的理解-他们的区别-应用场景-面试" aria-hidden="true">#</a> 63，说说你对防抖、节流的理解，他们的区别，应用场景(面试)</h3><p>防抖: 将多次执行函数变成最后一次执行 等待固定时间还没有事件触发时执行的函数</p><ul><li><p>应用场景</p><ul><li>按钮的点击</li><li>屏幕滚动时的复杂计算</li><li>输入框输入时进行搜索</li><li>用户缩放浏览器的resize事件</li></ul></li><li><p>简单的防抖函数实现</p></li><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myDebounce</span><span class="token punctuation">(</span><span class="token parameter">execFn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token number">0</span>
     
     <span class="token keyword">function</span> <span class="token function">_debounce</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
       timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
         <span class="token function">execFn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
         timer <span class="token operator">=</span> <span class="token keyword">null</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
 
     <span class="token keyword">return</span> _debounce
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>节流: 按照固定的时间频率(间隔)来执行对应的函数</p><ul><li><p>应用场景:</p><ul><li>监听页面的滚动事件 通过节流来降低事件调用的频率</li><li>鼠标移动</li><li>用户频繁点击按钮的操作</li></ul></li><li><p>简单实现</p></li><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myThrottle</span><span class="token punctuation">(</span><span class="token parameter">execFn<span class="token punctuation">,</span> interval</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> initTime <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> nowTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">const</span> waitTime <span class="token operator">=</span> interval <span class="token operator">-</span> <span class="token punctuation">(</span>nowTime <span class="token operator">-</span> initTime<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>waitTime <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">execFn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        initTime <span class="token operator">=</span> nowTime
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> throttle
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_64-说说对象的引用赋值、浅拷贝、深拷贝的区别" tabindex="-1"><a class="header-anchor" href="#_64-说说对象的引用赋值、浅拷贝、深拷贝的区别" aria-hidden="true">#</a> 64， 说说对象的引用赋值、浅拷贝、深拷贝的区别</h3><p>day 13</p><h3 id="_65-事件总线的基本实现和使用-重点" tabindex="-1"><a class="header-anchor" href="#_65-事件总线的基本实现和使用-重点" aria-hidden="true">#</a> 65，事件总线的基本实现和使用(重点)</h3><p>day13</p><h3 id="_66-说说服务端渲染和前后端分离的区别" tabindex="-1"><a class="header-anchor" href="#_66-说说服务端渲染和前后端分离的区别" aria-hidden="true">#</a> 66，说说服务端渲染和前后端分离的区别</h3><p>SSR(server side rendering) 服务端渲染</p><ul><li>优点: <ul><li>更快的响应时间 不用等待所有的js加载完成 也能显示比较完整的页面</li><li>更好的SEO 可以将SEO的关键信息直接在后台渲染成html 保证了搜索引擎能爬取到关键数据</li><li>无需占用客户端资源 解析模板交给后端工作 对于客户端的资源占用更少</li></ul></li><li>缺点 <ul><li>占用服务器资源 一个小小的页面的改动 都需要请求一次完整的html页面 有悖于程序员的==&quot;DRY(Don\`t repeat yourself)&quot;==原则 如果短时间访问过多 对服务器造成一定的访问压力</li><li></li><li>一些常见的api需要先对运行环境判断再使用</li></ul></li></ul><p>前后端分离</p><ul><li>优点: <ul><li>前端专注于ui界面的开发 后端专注于api的开发 单一</li><li>体验更好</li></ul></li><li>缺点: <ul><li>第一次响应内容较慢 不如服务端渲染快</li><li>不利于SEO优化 只是记录一个页面 对于SEO较差</li></ul></li></ul><h3 id="_67-说说你对http协议的理解" tabindex="-1"><a class="header-anchor" href="#_67-说说你对http协议的理解" aria-hidden="true">#</a> 67， 说说你对HTTP协议的理解</h3><p>http</p><ul><li>HyperText Transfer Protocol 超文本传输协议</li><li>超文本传输协议是一种用于分布式协作式的应用层协议</li><li>定义了客户端和服务器之间交换报文的格式和方式 默认为80端口</li><li>使用tcp作为传输层协议 保证了数据的可靠性</li></ul><p>组成:<code>一个HTTP请求主要包括: 请求和响应</code></p><ul><li><p>请求</p><ul><li><p>主要包含: 请求行 请求头 请求体</p></li><li><p>请求行:</p><ul><li><p>请求方法字段</p></li><li><p>URL字段</p></li><li><p>HTTP协议版本字段</p></li><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token constant">GET</span><span class="token operator">/</span>index<span class="token punctuation">.</span>html <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>请求头:</p><ul><li>键值对组成</li><li>User-Agent: 对应展示的浏览器的类型</li><li>Content-type: 对应的请求内容的数据类型 <ul><li>application/x-www-form-urlencoded 数据以&amp;分割 的键值对 键值对用=分割</li><li>application/json json类型</li><li>application/xml xml类型</li><li>text/plain 文本类型</li><li>multipart/form-data 表示上传文件</li></ul></li><li>keep-alive</li></ul></li><li><p>请求体: get/post所带的内容</p></li></ul></li><li><p>响应</p><ul><li><p>响应行</p><ul><li><p>由协议版本 状态码 状态码的原因短语组成</p></li><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>响应头</p></li><li><p>响应体</p></li></ul></li></ul><p>请求方法</p><ul><li>get 向服务器获取数据</li><li>post 将响应实体交给指定的资源</li><li>head 请求一个与get请求响应相同的响应 没有实体</li><li>put 上传文件 用于替换目标资源的所有</li><li>patch 用于对资源的部分修改</li><li>delete 删除指定的资源</li><li>connect: 建立一个到目标资源标识的服务器的隧道 通常用于代理服务器</li><li>track: 回显服务器收到的请求 主要用于测试和诊断</li></ul><p>响应状态码</p><ul><li>200 表示请求被服务器端正常处理</li><li>201 post请求 创建新的资源</li><li>301 永久重定向 表示资源被分配了新的URI 并返回该URI</li><li>4xx 表示客户端发生错误 <ul><li>400 请求报文存在语法错误</li><li>401 未授权的错误 必须携带身份信息</li><li>403 没有权限访问</li><li>404 服务器找不到请求资源</li></ul></li><li>5xx 服务器错误 <ul><li>500</li><li>503 服务器不可用 处于维护或重载状态</li></ul></li></ul><h3 id="_67-封装xmlhttprequest网络请求" tabindex="-1"><a class="header-anchor" href="#_67-封装xmlhttprequest网络请求" aria-hidden="true">#</a> 67，封装XMLHttpRequest网络请求</h3><p>day 14</p><h3 id="_68-说说xmlhttprequest和fetch请求的异同" tabindex="-1"><a class="header-anchor" href="#_68-说说xmlhttprequest和fetch请求的异同" aria-hidden="true">#</a> 68，说说XMLHttpRequest和Fetch请求的异同</h3><p>Fecth提供了一种更加现代的处理方案</p><ul><li>比如返回一个值是<code>Promise</code><ul><li>在请求成功时调用resolve回调</li></ul></li><li>与XMLHttpRequest不同 不用把所有操作放在同一个对象上</li><li>语法简单 更加语义化</li><li>基于标准的promise实现 支持async/await</li><li>更加底层</li></ul><p>Fetch缺点</p><ul><li>不支持abort(超时取消请求) 不支持超时控制</li><li>没有办法检测请求进度 XHR可以</li><li>默认不会携带cookie</li></ul><p>ajax缺点</p><ul><li>使用起来比较繁琐</li></ul><h2 id="二-js面试题" tabindex="-1"><a class="header-anchor" href="#二-js面试题" aria-hidden="true">#</a> 二，JS面试题</h2><h3 id="_1-javascript的数据类型有哪些" tabindex="-1"><a class="header-anchor" href="#_1-javascript的数据类型有哪些" aria-hidden="true">#</a> 1，JavaScript的数据类型有哪些？</h3><h3 id="_2-什么是显示转换隐式转换" tabindex="-1"><a class="header-anchor" href="#_2-什么是显示转换隐式转换" aria-hidden="true">#</a> 2，什么是显示转换隐式转换？</h3><h3 id="_3-什么是js的dom事件流" tabindex="-1"><a class="header-anchor" href="#_3-什么是js的dom事件流" aria-hidden="true">#</a> 3，什么是JS的DOM事件流？</h3><h3 id="_4-什么是事件委托-有缺点有哪些" tabindex="-1"><a class="header-anchor" href="#_4-什么是事件委托-有缺点有哪些" aria-hidden="true">#</a> 4，什么是事件委托？有缺点有哪些？</h3><h3 id="_5-js关于数组的常用方法" tabindex="-1"><a class="header-anchor" href="#_5-js关于数组的常用方法" aria-hidden="true">#</a> 5，JS关于数组的常用方法？</h3><h3 id="_6-什么是闭包-大量使用闭包的缺点" tabindex="-1"><a class="header-anchor" href="#_6-什么是闭包-大量使用闭包的缺点" aria-hidden="true">#</a> 6，什么是闭包？大量使用闭包的缺点？</h3><h3 id="_7-导致内存泄漏的原因-如何解决" tabindex="-1"><a class="header-anchor" href="#_7-导致内存泄漏的原因-如何解决" aria-hidden="true">#</a> 7，导致内存泄漏的原因？如何解决？</h3><h3 id="_8-let和const跟var的区别" tabindex="-1"><a class="header-anchor" href="#_8-let和const跟var的区别" aria-hidden="true">#</a> 8，let和const跟var的区别？</h3><h3 id="_9-promise的特性" tabindex="-1"><a class="header-anchor" href="#_9-promise的特性" aria-hidden="true">#</a> 9，promise的特性？</h3><h3 id="_10-箭头函数和普通函数区别" tabindex="-1"><a class="header-anchor" href="#_10-箭头函数和普通函数区别" aria-hidden="true">#</a> 10，箭头函数和普通函数区别？</h3><h3 id="_11-数组去重的方法有哪些" tabindex="-1"><a class="header-anchor" href="#_11-数组去重的方法有哪些" aria-hidden="true">#</a> 11，数组去重的方法有哪些？</h3><h3 id="_12-什么是js的作用域" tabindex="-1"><a class="header-anchor" href="#_12-什么是js的作用域" aria-hidden="true">#</a> 12，什么是JS的作用域？</h3><h3 id="_13-什么是链式编程-如何实现链式编程" tabindex="-1"><a class="header-anchor" href="#_13-什么是链式编程-如何实现链式编程" aria-hidden="true">#</a> 13，什么是链式编程？如何实现链式编程？</h3><h3 id="_14-如何解决地狱回调的问题" tabindex="-1"><a class="header-anchor" href="#_14-如何解决地狱回调的问题" aria-hidden="true">#</a> 14，如何解决地狱回调的问题？</h3><h3 id="_15-如何获取一个对象所有的属性名-如何修改一个对象属性名" tabindex="-1"><a class="header-anchor" href="#_15-如何获取一个对象所有的属性名-如何修改一个对象属性名" aria-hidden="true">#</a> 15，如何获取一个对象所有的属性名?如何修改一个对象属性名?</h3><h3 id="_16-请大概讲一下js的执行机制" tabindex="-1"><a class="header-anchor" href="#_16-请大概讲一下js的执行机制" aria-hidden="true">#</a> 16，请大概讲一下JS的执行机制</h3><h3 id="_17-如何判断数据类型" tabindex="-1"><a class="header-anchor" href="#_17-如何判断数据类型" aria-hidden="true">#</a> 17，如何判断数据类型？</h3><ol><li>如何判断一个数据是不是数组?</li><li>如何判断一个数据是不是NaN？（除了isNaN）</li></ol><h3 id="_18-如何实现js继承" tabindex="-1"><a class="header-anchor" href="#_18-如何实现js继承" aria-hidden="true">#</a> 18，如何实现JS继承？</h3><h3 id="_19-什么是原型链" tabindex="-1"><a class="header-anchor" href="#_19-什么是原型链" aria-hidden="true">#</a> 19，什么是原型链？</h3><h2 id="三-vue面试题" tabindex="-1"><a class="header-anchor" href="#三-vue面试题" aria-hidden="true">#</a> 三，vue面试题</h2><h3 id="_1-v-for和v-if哪个先执行" tabindex="-1"><a class="header-anchor" href="#_1-v-for和v-if哪个先执行" aria-hidden="true">#</a> 1，v-for和v-if哪个先执行？</h3><ul><li>vue2: <strong>v-for要先于v-if被执行</strong></li><li>vue3: v-if<code>的优先级高于</code>v-for</li></ul><h3 id="_2-computed和methods中方法的区别" tabindex="-1"><a class="header-anchor" href="#_2-computed和methods中方法的区别" aria-hidden="true">#</a> 2，computed和methods中方法的区别？</h3><h3 id="_3-computed和watch适合分别在什么时候使用" tabindex="-1"><a class="header-anchor" href="#_3-computed和watch适合分别在什么时候使用" aria-hidden="true">#</a> 3，computed和watch适合分别在什么时候使用？</h3><h3 id="_4-vue的声明周期有哪些" tabindex="-1"><a class="header-anchor" href="#_4-vue的声明周期有哪些" aria-hidden="true">#</a> 4，vue的声明周期有哪些？</h3><h3 id="_5-页面渲染完哪些钩子函数会被执行" tabindex="-1"><a class="header-anchor" href="#_5-页面渲染完哪些钩子函数会被执行" aria-hidden="true">#</a> 5，页面渲染完哪些钩子函数会被执行？</h3><h3 id="_6-请描述一下keep-alive的使用场景" tabindex="-1"><a class="header-anchor" href="#_6-请描述一下keep-alive的使用场景" aria-hidden="true">#</a> 6，请描述一下keep-alive的使用场景？</h3><h3 id="_7-路由传参的方式" tabindex="-1"><a class="header-anchor" href="#_7-路由传参的方式" aria-hidden="true">#</a> 7，路由传参的方式？</h3><h3 id="_8-如何实现路由懒加载" tabindex="-1"><a class="header-anchor" href="#_8-如何实现路由懒加载" aria-hidden="true">#</a> 8，如何实现路由懒加载？</h3><h3 id="_9-vue的路由钩子函数有哪些" tabindex="-1"><a class="header-anchor" href="#_9-vue的路由钩子函数有哪些" aria-hidden="true">#</a> 9，vue的路由钩子函数有哪些？</h3><h3 id="_10-你有使用过vue的自定义指令吗-举个项目中的示例" tabindex="-1"><a class="header-anchor" href="#_10-你有使用过vue的自定义指令吗-举个项目中的示例" aria-hidden="true">#</a> 10，你有使用过vue的自定义指令吗？举个项目中的示例</h3><h3 id="_11-自定义指令里面都有哪些方法" tabindex="-1"><a class="header-anchor" href="#_11-自定义指令里面都有哪些方法" aria-hidden="true">#</a> 11，自定义指令里面都有哪些方法？</h3><h3 id="_12-怎么使用vue的过滤器-过滤器只能在插值表达式中使用吗" tabindex="-1"><a class="header-anchor" href="#_12-怎么使用vue的过滤器-过滤器只能在插值表达式中使用吗" aria-hidden="true">#</a> 12，怎么使用vue的过滤器？过滤器只能在插值表达式中使用吗？</h3><h3 id="_13-v-model的原理是什么" tabindex="-1"><a class="header-anchor" href="#_13-v-model的原理是什么" aria-hidden="true">#</a> 13，v-model的原理是什么？</h3><h3 id="_14-vue的数据更新和视图更新是同步还是异步的" tabindex="-1"><a class="header-anchor" href="#_14-vue的数据更新和视图更新是同步还是异步的" aria-hidden="true">#</a> 14，vue的数据更新和视图更新是同步还是异步的？</h3><h3 id="_15-为什么更新了数据却不能操作dom-如何解决" tabindex="-1"><a class="header-anchor" href="#_15-为什么更新了数据却不能操作dom-如何解决" aria-hidden="true">#</a> 15，为什么更新了数据却不能操作dom？如何解决？</h3><h3 id="_16-简单介绍一下-nexttick" tabindex="-1"><a class="header-anchor" href="#_16-简单介绍一下-nexttick" aria-hidden="true">#</a> 16，简单介绍一下$nextTick</h3><h3 id="_17-数据更新和视图刷新哪个是同步哪个是异步" tabindex="-1"><a class="header-anchor" href="#_17-数据更新和视图刷新哪个是同步哪个是异步" aria-hidden="true">#</a> 17，数据更新和视图刷新哪个是同步哪个是异步？</h3><h3 id="_18-如何解决数据更新视图更新不同步的问题" tabindex="-1"><a class="header-anchor" href="#_18-如何解决数据更新视图更新不同步的问题" aria-hidden="true">#</a> 18，如何解决数据更新视图更新不同步的问题？</h3><h3 id="_19-v-for后面为什么要加-key" tabindex="-1"><a class="header-anchor" href="#_19-v-for后面为什么要加-key" aria-hidden="true">#</a> 19，v-for后面为什么要加:key？</h3><h3 id="_20-你知道dom-diff算法吗" tabindex="-1"><a class="header-anchor" href="#_20-你知道dom-diff算法吗" aria-hidden="true">#</a> 20，你知道dom diff算法吗？</h3><h3 id="_21-vue中组件通信的方式有哪些" tabindex="-1"><a class="header-anchor" href="#_21-vue中组件通信的方式有哪些" aria-hidden="true">#</a> 21，vue中组件通信的方式有哪些？</h3><h3 id="_22-什么是插槽" tabindex="-1"><a class="header-anchor" href="#_22-什么是插槽" aria-hidden="true">#</a> 22，什么是插槽？</h3><h3 id="_23-什么是具名插槽" tabindex="-1"><a class="header-anchor" href="#_23-什么是具名插槽" aria-hidden="true">#</a> 23，什么是具名插槽？</h3><h3 id="_24-什么是作用域插槽" tabindex="-1"><a class="header-anchor" href="#_24-什么是作用域插槽" aria-hidden="true">#</a> 24，什么是作用域插槽？</h3><h3 id="_25-什么是具名作用域插槽" tabindex="-1"><a class="header-anchor" href="#_25-什么是具名作用域插槽" aria-hidden="true">#</a> 25，什么是具名作用域插槽？</h3><h3 id="_26-简单介绍一下mvvm" tabindex="-1"><a class="header-anchor" href="#_26-简单介绍一下mvvm" aria-hidden="true">#</a> 26，简单介绍一下mvvm</h3><h3 id="_27" tabindex="-1"><a class="header-anchor" href="#_27" aria-hidden="true">#</a> 27，</h3><h2 id="四-小程序" tabindex="-1"><a class="header-anchor" href="#四-小程序" aria-hidden="true">#</a> 四，小程序</h2><h3 id="_1-说说你对小程序双线程模型架构的理解-面试" tabindex="-1"><a class="header-anchor" href="#_1-说说你对小程序双线程模型架构的理解-面试" aria-hidden="true">#</a> 1，说说你对小程序双线程模型架构的理解?(面试)</h3><ul><li>小程序的宿主环境是：微信客户端 <ul><li>宿主环境可以执行小程序的各种文件</li></ul></li><li>当小程序运行在 WebView 环境下时，会有什么问题呢？ <ul><li>JS 逻辑、DOM 树创建、CSS 解析、样式计算、Layout、Paint (Composite) 都发生在同一线程中</li><li>在 WebView 上执行过多的 JS 逻辑可能阻塞渲染，导致界面卡顿</li></ul></li><li>小程序考虑到性能与安全的问题，采用了「双线程模型」的架构 <ul><li>WXML模块和WXSS样式运行于 渲染层，渲染层使用WebView线程渲染 <ul><li>当一个程序有多个页面时，会使用多个WebView的线程</li></ul></li><li>JS脚本（app.js/home.js等）运行于 逻辑层，逻辑层使用 JsCore 运行 JS脚本 <ul><li>这两个线程都会经由微信客户端（Native）进行中转并交互</li></ul></li></ul></li></ul><h3 id="_2-小程序有哪些配置文件-分别用来进行什么配置" tabindex="-1"><a class="header-anchor" href="#_2-小程序有哪些配置文件-分别用来进行什么配置" aria-hidden="true">#</a> 2，小程序有哪些配置文件，分别用来进行什么配置？</h3><ul><li>sitemap.json <ul><li>微信会爬取你的页面内容, 当用户在自己的微信中搜索时可以搜索到你开发的小程序</li></ul></li><li>project.private.config.json：一些配置信息 <ul><li>比如：项目名字，是否开启热重载, 是否开启地址检查，当前版本库的版本号</li><li>这个文件中设置的内容会覆盖掉project.config.json文件中的相同设置</li><li>与project.config.json配置不同时会改变这个文件中的配置</li></ul></li><li>project.config.json：一些基础配置 <ul><li>比如项目名称、appid</li><li>这个文件一般不会发生变化</li></ul></li><li>app.json：全局配置 <ul><li>pages: 页面路径列表 <ul><li>用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息</li><li>小程序中所有的页面都是必须在pages中进行注册</li></ul></li><li>window: 全局的默认窗口展示 <ul><li>用户指定窗口如何展示, 其中还包含了很多其他的属性</li></ul></li><li>tabBar: 底部tab栏的展示</li></ul></li><li>page.json：页面的单独配置 <ul><li>每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置</li><li>页面中配置项在当前页面会覆盖 app.json 的 window 中相同的配置项</li></ul></li></ul><h3 id="_3-注册app实例的函数-以及注册该实例时-通常可能进行哪些操作" tabindex="-1"><a class="header-anchor" href="#_3-注册app实例的函数-以及注册该实例时-通常可能进行哪些操作" aria-hidden="true">#</a> 3， 注册App实例的函数，以及注册该实例时，通常可能进行哪些操作？</h3><ul><li><p>判断小程序的进入场景</p><ul><li>在生命周期函数中有一个参数options options中的<code>scene</code>记录着从什么场景进入的小程序</li><li>场景列表地址 https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html</li></ul></li><li><p>监听生命周期函数</p><ul><li>在对应的生命周期函数中执行刚开始的业务逻辑 比如登录操作或者初始化时请求全局的网络数据</li><li>App()实例只有一个 所以可以创建一个globalData的对象 存放全局的共享数据</li></ul></li></ul><h3 id="_4-注册page实例的函数-以及注册该实例时-通常可能进行哪些操作" tabindex="-1"><a class="header-anchor" href="#_4-注册page实例的函数-以及注册该实例时-通常可能进行哪些操作" aria-hidden="true">#</a> 4， 注册Page实例的函数，以及注册该实例时，通常可能进行哪些操作？</h3><ol><li>在生命周期函数中发送网络请求</li><li>初始化数据 方便页面展示</li><li>监听wxml中的事件</li><li>进行页面滚动 下拉加载 上拉刷新的事件监听</li></ol><h3 id="_5-什么是rpx-rpx如何进行的屏幕适配" tabindex="-1"><a class="header-anchor" href="#_5-什么是rpx-rpx如何进行的屏幕适配" aria-hidden="true">#</a> 5，什么是rpx？rpx如何进行的屏幕适配？</h3><p>rpx: responsive pixel : 可以根据屏幕宽度进行自适应 规定屏幕宽度为750rpx</p><ul><li>建议开发中将 iPhone6 作为视觉稿的标准 <ul><li>iPhone6 屏幕宽度为375px 750物理像素 所以 750rpx = 375px = 750物理像素</li><li>1rpx = 0.5px</li><li>因此如果想定义一个100px宽度的view 则需要设置width为 200rpx</li></ul></li></ul><h3 id="_6-wx-if和hidden属性有什么区别-开发中如何选择" tabindex="-1"><a class="header-anchor" href="#_6-wx-if和hidden属性有什么区别-开发中如何选择" aria-hidden="true">#</a> 6，wx:if和hidden属性有什么区别？开发中如何选择？</h3><p>wx:if是 组件是否渲染</p><p>hidden指的是hidden属性是否添加</p><p>开发中选择:</p><ul><li>如果操作很频繁 则使用hidden</li><li>如果不频繁 则使用 wx:if</li></ul><h3 id="_7-wx-for为什么需要绑定key-绑定key的方式有哪些" tabindex="-1"><a class="header-anchor" href="#_7-wx-for为什么需要绑定key-绑定key的方式有哪些" aria-hidden="true">#</a> 7，wx:for为什么需要绑定key？绑定key的方式有哪些？</h3><p>为什么要绑定key:</p><ul><li>当我们希望处于同一层的VNode 进行插入 删除 新增 节点时 可以更好的进行节点的复用 就需要key属性来判断</li></ul><p>绑定key的方式有哪些:</p><ul><li>字符串: 表示 for循环array中item的某个属性(property) 该property是列表中的唯一的字符串或数字</li><li>保留关键字 *this 表示item本身 此时item本身是唯一的字符串或数字</li></ul><h3 id="_8-wxs的作用是什么-如何使用" tabindex="-1"><a class="header-anchor" href="#_8-wxs的作用是什么-如何使用" aria-hidden="true">#</a> 8， WXS的作用是什么？如何使用？</h3><p>作用:</p><ul><li>小程序的一套脚本语言 和JavaScript基本一致</li><li>为了在wxml中调用函数来处理对应的数据</li></ul><p>如何使用:</p><ul><li>写在 wxs标签中</li><li>写在 .wxs结尾的文件中 以cjs的方式导出 以cjs的方式在wxml文件中引入 进行使用</li></ul><p>WXS的作用 :</p><p>实现使用函数来处理WXML中的数据(类似于Vue中的过滤器)</p><p>如何使用WXS :</p><p>方式一 :写在 &lt; wxs &gt;标签中, &lt; wxs &gt; xxxx &lt; /wxs &gt;</p><p>方式二 : 独立文件，通过src引入, &lt; wxs src=&quot;xxx路径&quot; /&gt;</p><h3 id="_9-事件传递参数的方法有哪些-如何传递参数" tabindex="-1"><a class="header-anchor" href="#_9-事件传递参数的方法有哪些-如何传递参数" aria-hidden="true">#</a> 9， 事件传递参数的方法有哪些？如何传递参数？</h3><p>事件传递参数 :</p><p>小程序中常用传递参数的方式是通过 data- 属性来实现，可以在逻辑代码中通过 &quot;el.currentTarget.dataset.属性名称&quot; 获取</p><h3 id="_10-target和currenttarget的区别" tabindex="-1"><a class="header-anchor" href="#_10-target和currenttarget的区别" aria-hidden="true">#</a> 10，target和currentTarget的区别？</h3><p>target和currentTarget的区别 :</p><p><code> ·</code> target指触发事件的元素</p><p><code> ·</code> currentTarget指的是处理事件的元素，两者作用在同一个元素上无差别，小程序中常用currentTarget</p><h3 id="_11-组件中的样式有哪些关键的细节-自己总结" tabindex="-1"><a class="header-anchor" href="#_11-组件中的样式有哪些关键的细节-自己总结" aria-hidden="true">#</a> 11，组件中的样式有哪些关键的细节？（自己总结）</h3><h3 id="_12-页面和组件如何进行数据传递-都包括哪些传递方式" tabindex="-1"><a class="header-anchor" href="#_12-页面和组件如何进行数据传递-都包括哪些传递方式" aria-hidden="true">#</a> 12，页面和组件如何进行数据传递？都包括哪些传递方式？</h3><p>页面和组件如何进行数据传递 :</p><p><code> ·</code> 向组件传递数据可以通过 properties 属性，支持String、Number、Boolean、Object、Array、null等类型</p><p><code> ·</code> 向组件传递样式可以通过定义externalClasses属性来实现</p><p><code> ·</code> 组件向外传递事件可以在组件内部通过this.triggerEvent将事件派发，页面可以通过bind绑定</p><h3 id="_13-小程序中组件的插槽如何使用-如何给插槽传递默认值" tabindex="-1"><a class="header-anchor" href="#_13-小程序中组件的插槽如何使用-如何给插槽传递默认值" aria-hidden="true">#</a> 13，小程序中组件的插槽如何使用？如何给插槽传递默认值？</h3><p>小程序中使用插槽 :</p>`,342),c=n('<p>给插槽传递默认值 :</p><p>小程序中不支持给插槽设置默认值，如果非要设置，可以通过兄弟选择器来实现 :</p><ul><li>给需要传递的默认值元素上添加一个类，设置 display : none，默认不显示</li><li>之后在有预留插槽位置的元素设置伪类 :empty ，当里面没有内容时，再通过兄弟选择器找到默认值元素上的类，将display改为block</li></ul><h3 id="_14-注册组件实例时-都有哪些选项-自己总结" tabindex="-1"><a class="header-anchor" href="#_14-注册组件实例时-都有哪些选项-自己总结" aria-hidden="true">#</a> 14，注册组件实例时，都有哪些选项？（自己总结）</h3><p>注册组件实例时，可以通过组件的生命周期函数触发一些特殊事件，例如 :</p><p>created #在组件实例刚刚被创建时执行</p><p>attached #在组件实例进入页面节点树时执行</p><p>ready #在组件在视图层布局完成后执行</p><p>moved #在组件实例被移动到节点树另一个位置时执行</p><p>detached #在组件实例被从页面节点树移除时执行</p><p>error # 组件方法抛出错误时执行</p><h3 id="_15-小程序中如何进行页面跳转-在跳转过程中如何进行数据的传递" tabindex="-1"><a class="header-anchor" href="#_15-小程序中如何进行页面跳转-在跳转过程中如何进行数据的传递" aria-hidden="true">#</a> 15，小程序中如何进行页面跳转？在跳转过程中如何进行数据的传递？</h3><p>小程序中实现页面跳转有两种方式 :</p><p>方式一 ：通过navigator组件(用的较少，不推荐)</p><p>方式二 : 通过wx的API进行页面跳转，常用 ：</p><p>wx.navigateTo() #保留当前页面，跳转到应用内的某个页面</p><p>wx.navigateBack() #关闭当前页面，返回上一页面或者多级页面</p><p>页面跳转数据传递 :</p><p><code> ·</code> 首页传递数据至详情页 (使用URL中的query字段)：</p><ul><li>url : &quot;/pages/classify/index?name=wzl&amp;age=22&quot;</li></ul><p><code> ·</code> 详情页传递数据至首页(在详情页内部拿到首页实例，并修改数据) ：</p><ul><li>const pages = getCurrentPages() //获取实例方法</li><li>const prevPage = pages[pages.length - 2] //具体实例</li><li>prevPage.setData({info: &quot;my name is wzl&quot;}) //修改数据</li></ul><h3 id="_16-总结小程序的登录流程-并且自己进行整理" tabindex="-1"><a class="header-anchor" href="#_16-总结小程序的登录流程-并且自己进行整理" aria-hidden="true">#</a> 16，总结小程序的登录流程，并且自己进行整理</h3><p>小程序登录流程 :</p><p>1.通过wx.login()获取code</p><p>2.将这个code发送给后端，后端会返回一个token，这个token将作为你身份的唯一标识</p><p>3.将token通过wx.setStorageSync()保存在本地存储</p><p>4.用户下次进入页面时，会先通过wx.getStorageSync() 方法判断token是否有值，如果有值，则可以请求其它数据，如果没有值，则进行登录操作</p><h3 id="_17-整理小程序常见的系统api-多阅读官方文档" tabindex="-1"><a class="header-anchor" href="#_17-整理小程序常见的系统api-多阅读官方文档" aria-hidden="true">#</a> 17，整理小程序常见的系统API，多阅读官方文档</h3><p>小程序常见系统API ：</p><p><code> ·</code> 展示弹窗API : showToast、showModal、showLoading、showActionSheet</p><p><code> ·</code> 分享功能 ：通过onShareAppMessage()实现</p><p><code> ·</code> 获取设备信息 : 通过wx.getSystemInfo()实现</p><p><code> ·</code> 获取用户位置信息 : 通过wx.getLocation()获取</p><p><code> ·</code> 本地数据存储 (常用两个)：</p><ul><li>同步存储数据 : wx.setStorageSync()</li><li>同步获取数据 : wx.getStorageSync()</li></ul><h2 id="五-综合面试" tabindex="-1"><a class="header-anchor" href="#五-综合面试" aria-hidden="true">#</a> 五，综合面试</h2><h3 id="_1-项目优化的方案有哪些" tabindex="-1"><a class="header-anchor" href="#_1-项目优化的方案有哪些" aria-hidden="true">#</a> 1，项目优化的方案有哪些？</h3><h3 id="_2-什么是跨域-如何解决跨域的问题" tabindex="-1"><a class="header-anchor" href="#_2-什么是跨域-如何解决跨域的问题" aria-hidden="true">#</a> 2，什么是跨域?如何解决跨域的问题？</h3><h3 id="_3-说说你项目中碰到的问题以及如何解决的" tabindex="-1"><a class="header-anchor" href="#_3-说说你项目中碰到的问题以及如何解决的" aria-hidden="true">#</a> 3，说说你项目中碰到的问题以及如何解决的？</h3><h3 id="_4-节流防抖是什么" tabindex="-1"><a class="header-anchor" href="#_4-节流防抖是什么" aria-hidden="true">#</a> 4，节流防抖是什么？</h3><h3 id="_5-git冲突了怎么处理" tabindex="-1"><a class="header-anchor" href="#_5-git冲突了怎么处理" aria-hidden="true">#</a> 5，git冲突了怎么处理？</h3><h3 id="_6-如果让你实现一个树形结构-你对数据的要求有哪些" tabindex="-1"><a class="header-anchor" href="#_6-如果让你实现一个树形结构-你对数据的要求有哪些" aria-hidden="true">#</a> 6，如果让你实现一个树形结构，你对数据的要求有哪些？</h3><h3 id="_7-webpack的基础配置有哪些" tabindex="-1"><a class="header-anchor" href="#_7-webpack的基础配置有哪些" aria-hidden="true">#</a> 7，Webpack的基础配置有哪些？</h3><h3 id="_8-登录模块主要实现的内容有哪些" tabindex="-1"><a class="header-anchor" href="#_8-登录模块主要实现的内容有哪些" aria-hidden="true">#</a> 8，登录模块主要实现的内容有哪些？</h3><h3 id="_9-权限模块的设计实现思路是什么样的" tabindex="-1"><a class="header-anchor" href="#_9-权限模块的设计实现思路是什么样的" aria-hidden="true">#</a> 9，权限模块的设计实现思路是什么样的？</h3><h3 id="_10-人员管理的主要做了哪些内容" tabindex="-1"><a class="header-anchor" href="#_10-人员管理的主要做了哪些内容" aria-hidden="true">#</a> 10，人员管理的主要做了哪些内容？</h3><h3 id="_11-route和-router的区别" tabindex="-1"><a class="header-anchor" href="#_11-route和-router的区别" aria-hidden="true">#</a> 11，$route和$router的区别？</h3><h3 id="_12-闭包的使用场景有哪些" tabindex="-1"><a class="header-anchor" href="#_12-闭包的使用场景有哪些" aria-hidden="true">#</a> 12，闭包的使用场景有哪些？</h3><h3 id="_13-简单介绍一下promise" tabindex="-1"><a class="header-anchor" href="#_13-简单介绍一下promise" aria-hidden="true">#</a> 13，简单介绍一下promise</h3><h3 id="_14-浏览器如何渲染html的" tabindex="-1"><a class="header-anchor" href="#_14-浏览器如何渲染html的" aria-hidden="true">#</a> 14，浏览器如何渲染html的？</h3><h3 id="_15-从输入一个地址到看到页面都发生了什么" tabindex="-1"><a class="header-anchor" href="#_15-从输入一个地址到看到页面都发生了什么" aria-hidden="true">#</a> 15，从输入一个地址到看到页面都发生了什么？</h3><h3 id="_16-你项目里面比较难得技术点有哪些" tabindex="-1"><a class="header-anchor" href="#_16-你项目里面比较难得技术点有哪些" aria-hidden="true">#</a> 16，你项目里面比较难得技术点有哪些？</h3><h3 id="_17-你项目中封装了哪些组件" tabindex="-1"><a class="header-anchor" href="#_17-你项目中封装了哪些组件" aria-hidden="true">#</a> 17，你项目中封装了哪些组件？</h3><h3 id="_18-你们的开发流程是什么样的" tabindex="-1"><a class="header-anchor" href="#_18-你们的开发流程是什么样的" aria-hidden="true">#</a> 18，你们的开发流程是什么样的？</h3><h3 id="_19-你们的开发流程是什么样的" tabindex="-1"><a class="header-anchor" href="#_19-你们的开发流程是什么样的" aria-hidden="true">#</a> 19，你们的开发流程是什么样的？</h3>',56);function u(s,d){return l(),i("div",null,[r,t("p",null,[a("在组件中想要使用插槽的地方通过"),p(s.$slots,"default"),a("预留位置，在组件外部可以在预留插槽中插入文字、图片或者是进度条")]),c])}const k=e(o,[["render",u],["__file","50.html.vue"]]);export{k as default};
