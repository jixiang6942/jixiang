import{_ as e,o as a,c as i,a as s}from"./app-382cdfb3.js";const t="/jixiang/assets/image-20241009223018483-1c3ecc9a.png",p="/jixiang/assets/image-20241009223037806-e5dd0261.png",r="/jixiang/assets/image-20241009223105523-cffa7178.png",n="/jixiang/assets/image-20240805201925411-090df6ae.png",c="/jixiang/assets/image-20241009232004511-52d169ae.png",g="/jixiang/assets/image-20241009232053067-e4440812.png",o="/jixiang/assets/image-20241009232118175-32b7886a.png",m="/jixiang/assets/image-20241009232217059-b29f5c84.png",l="/jixiang/assets/image-20241009232304929-b2e5ee3f.png",d="/jixiang/assets/image-20241010081849188-9dc98b90.png",h="/jixiang/assets/image-20241010090233266-bbe16133.png",_="/jixiang/assets/image-20241010091758345-371af204.png",u="/jixiang/assets/image-20241010091945150-8fe98889.png",f="/jixiang/assets/image-20241010081924627-4c4c8079.png",x="/jixiang/assets/image-20241010101049355-a2836434.png",b="/jixiang/assets/image-20241010101225338-a66cc510.png",j="/jixiang/assets/image-20241010103146303-cb5c60dc.png",k="/jixiang/assets/image-20241010104420492-830f1893.png",M="/jixiang/assets/image-20241010104516759-d01b6255.png",H="/jixiang/assets/image-20241010113150219-d70b33a3.png",C="/jixiang/assets/image-20241010131141985-70e25639.png",S="/jixiang/assets/image-20241010153354061-299c58b9.png",E="/jixiang/assets/image-20241010154734363-bbfd4ede.png",y="/jixiang/assets/image-20241010155954922-d1fd893c.png",R="/jixiang/assets/image-20241010160035412-7f3d575d.png",D="/jixiang/assets/image-20241010131209742-1a4ec0de.png",A="/jixiang/assets/image-20241010164226412-6b79da86.png",v="/jixiang/assets/image-20241010131239616-294ba98e.png",O="/jixiang/assets/image-20241011132213528-089f3b58.png",T="/jixiang/assets/image-20241011134604731-ff8ca69d.png",L="/jixiang/assets/image-20241011144634482-6753dded.png",P="/jixiang/assets/image-20241011145656194-381be0ab.png",I="/jixiang/assets/image-20241010131304250-6787faed.png",V="/jixiang/assets/image-20241010232304866-8eb1b821.png",J="/jixiang/assets/image-20241010233321244-d6d5433e.png",N="/jixiang/assets/image-20241010234402338-ffbe19f9.png",z="/jixiang/assets/image-20241010235212341-69bf298f.png",B="/jixiang/assets/image-20241011002041562-90cb13c5.png",U="/jixiang/assets/image-20241011002647617-974efca0.png",w="/jixiang/assets/image-20241011074729063-1df9fb26.png",W="/jixiang/assets/image-20241011075428002-4e515714.png",q="/jixiang/assets/image-20241010131326813-94957308.png",F="/jixiang/assets/image-20241011082313460-59e86945.png",G="/jixiang/assets/image-20241011113358222-cdfe8eef.png",K="/jixiang/assets/image-20241011114616172-f82c9dae.png",Q="/jixiang/assets/image-20241011185837282-18c54786.png",X="/jixiang/assets/image-20241011190517603-12fe9313.png",Y="/jixiang/assets/image-20241011195214569-16796a60.png",Z="/jixiang/assets/image-20241011203715014-de3f77ed.png",$="/jixiang/assets/image-20241011205017507-49aa3b44.png",ee="/jixiang/assets/image-20241011205654674-a58d7c5d.png",ae="/jixiang/assets/image-20241011205934251-7d029c6d.png",ie="/jixiang/assets/image-20241011213001484-34396469.png",se="/jixiang/assets/image-20241011214701486-7e4b5dee.png",te="/jixiang/assets/image-20241011215751346-3286a5dc.png",pe="/jixiang/assets/image-20241011215839708-9166394c.png",re="/jixiang/assets/image-20241011222244950-6edff7f1.png",ne="/jixiang/assets/image-20241011222342733-1046b55f.png",ce="/jixiang/assets/image-20241011222407322-77fded20.png",ge="/jixiang/assets/image-20241011224724373-785445c8.png",oe="/jixiang/assets/image-20241011225038435-9dae203a.png",me="/jixiang/assets/image-20241011225302209-3167cfd5.png",le="/jixiang/assets/image-20241011225411917-d88f8219.png",de="/jixiang/assets/image-20241011230631431-e9377299.png",he="/jixiang/assets/image-20241011233130761-7bc392f5.png",_e="/jixiang/assets/image-20241011233418273-76ac991f.png",ue="/jixiang/assets/image-20241011233514738-a7594347.png",fe="/jixiang/assets/image-20241012082236144-4b9df31e.png",xe="/jixiang/assets/image-20241012135806853-5290573a.png",be="/jixiang/assets/image-20241012140135594-91df2153.png",je="/jixiang/assets/image-20241012140258705-3dfb70cb.png",ke="/jixiang/assets/image-20241012142622114-6e6d3ff3.png",Me="/jixiang/assets/image-20241012143057118-064ac84c.png",He="/jixiang/assets/image-20241012144404244-f9df0371.png",Ce="/jixiang/assets/image-20241012144614358-ff819151.png",Se="/jixiang/assets/image-20241012152902111-a81255b8.png",Ee="/jixiang/assets/image-20241012154136465-d3c964e6.png",ye="/jixiang/assets/image-20241012213229821-a36359f2.png",Re="/jixiang/assets/image-20241012215134778-3589ab36.png",De="/jixiang/assets/image-20241012221922473-bcc5a412.png",Ae="/jixiang/assets/image-20241012225246815-c2526dfd.png",ve="/jixiang/assets/image-20241012225314420-b4d340d3.png",Oe="/jixiang/assets/image-20241012225334395-27b8c7e0.png",Te="/jixiang/assets/image-20241013110037617-6c9c5bfd.png",Le="/jixiang/assets/image-20241013141222712-5529a4d0.png",Pe="/jixiang/assets/image-20241013222142923-f13a8edc.png",Ie="/jixiang/assets/image-20241013223120985-858af24a.png",Ve="/jixiang/assets/image-20241013230526395-5a048874.png",Je="/jixiang/assets/image-20241013235223941-37818a2f.png",Ne="/jixiang/assets/image-20241014001030398-e49a3e96.png",ze="/jixiang/assets/image-20241014001130867-ab90de05.png",Be="/jixiang/assets/image-20241014081033513-53aa83a8.png",Ue={},we=s('<h1 id="react-hook解析" tabindex="-1"><a class="header-anchor" href="#react-hook解析" aria-hidden="true">#</a> React Hook解析</h1><h2 id="一-认识和体验hooks" tabindex="-1"><a class="header-anchor" href="#一-认识和体验hooks" aria-hidden="true">#</a> 一，认识和体验Hooks</h2><p><img src="'+t+'" alt="image-20241009223018483"></p><p><img src="'+p+'" alt="image-20241009223037806"></p><p><img src="'+r+'" alt="image-20241009223105523"></p><p><img src="'+n+'" alt="image-20241009223127743"></p><p><img src="'+c+'" alt="image-20241009232004511"></p><p><img src="'+g+'" alt="image-20241009232053067"></p><p><img src="'+o+'" alt="image-20241009232118175"></p><h2 id="二-state-effect" tabindex="-1"><a class="header-anchor" href="#二-state-effect" aria-hidden="true">#</a> 二，State/Effect</h2><h3 id="_1-usestate" tabindex="-1"><a class="header-anchor" href="#_1-usestate" aria-hidden="true">#</a> 1，useState</h3><p><img src="'+m+'" alt="image-20241009232217059"></p><p><img src="'+l+'" alt="image-20241009232304929"></p><h3 id="_2-useeffect" tabindex="-1"><a class="header-anchor" href="#_2-useeffect" aria-hidden="true">#</a> 2，useEffect</h3><h4 id="_2-1-基本使用" tabindex="-1"><a class="header-anchor" href="#_2-1-基本使用" aria-hidden="true">#</a> 2.1，基本使用</h4><p><img src="'+d+'" alt="image-20241010081849188"></p><p>需求：修改状态counter，网站的title也会随之变化。</p><p>类组件实现，代码如下：</p><p><img src="'+h+'" alt="image-20241010090233266"></p><p>函数式组件实现，代码如下：</p><p><img src="'+_+'" alt="image-20241010091758345"></p><p><img src="'+u+'" alt="image-20241010091945150"></p><h4 id="_2-2-清除effect" tabindex="-1"><a class="header-anchor" href="#_2-2-清除effect" aria-hidden="true">#</a> 2.2，清除Effect</h4><p><img src="'+f+'" alt="image-20241010081924627"></p><p><img src="'+x+'" alt="image-20241010101049355"></p><h4 id="_2-3-多个effect" tabindex="-1"><a class="header-anchor" href="#_2-3-多个effect" aria-hidden="true">#</a> 2.3，多个Effect</h4><p><img src="'+b+'" alt="image-20241010101225338"></p><ul><li>使用Hook的其中一个目的就是解决class中生命周期经常将很多的逻辑放在一起的问题： <ul><li>比如网络请求、事件监听、手动修改DOM，这些往往都会放在componentDidMount中；</li></ul></li><li>使用Effect Hook，我们可以将它们分离到不同的useEffect中。</li><li>Hook 允许我们按照代码的用途分离它们， 而不是像生命周期函数那样： <ul><li>React 将按照 effect 声明的顺序依次调用组件中的每一个 effect；</li></ul></li></ul><p>在一个useEffect回调函数中执行多个副作用，会书写很多代码，不利于代码的阅读性。如下：</p><p><img src="'+j+'" alt="image-20241010103146303"></p><p>对于多个副作用，我们可以使用多个useEffect，多个useEffect按照书写顺序挨个执行。操作如下：</p><p><img src="'+k+'" alt="image-20241010104420492"></p><h4 id="_2-4-effect性能优化" tabindex="-1"><a class="header-anchor" href="#_2-4-effect性能优化" aria-hidden="true">#</a> 2.4，Effect性能优化</h4><p><img src="'+M+'" alt="image-20241010104516759"></p><ul><li>默认情况下，useEffect的回调函数会在每次渲染时都重新执行，但是这会导致两个问题： <ul><li>某些代码我们只是希望执行一次即可，类似于componentDidMount和componentWillUnmount中完成的事情；（比如网 络请求、订阅和取消订阅）；</li><li>另外，多次执行也会导致一定的性能问题；</li></ul></li><li>我们如何决定useEffect在什么时候应该执行和什么时候不应该执行呢？ <ul><li>useEffect实际上有两个参数：</li><li>参数一：执行的回调函数；</li><li>参数二：该useEffect在哪些state发生变化时，才重新执行；（受谁的影响）</li></ul></li></ul><p><img src="'+H+'" alt="image-20241010113150219"></p><h2 id="三、context-reducer" tabindex="-1"><a class="header-anchor" href="#三、context-reducer" aria-hidden="true">#</a> 三、Context/Reducer</h2><h3 id="_1-usecontext" tabindex="-1"><a class="header-anchor" href="#_1-usecontext" aria-hidden="true">#</a> 1，useContext</h3><p><img src="'+C+'" alt="image-20241010131141985"></p><p>在之前的开发中，我们要在组件中使用共享的Context有两种方式：</p><ul><li>类组件可以通过 类名.contextType = MyContext方式，在类中获取context；</li><li>多个Context或者在函数式组件中通过 MyContext.Consumer 方式共享context；</li></ul><p>但是多个Context共享时的方式会存在大量的嵌套：</p><ul><li>Context Hook允许我们通过Hook来直接获取某个Context的值；</li></ul><p>注意事项：</p><ul><li>当组件上层最近的 更新时，该 Hook 会触发重新渲染，并使用最新传递给 MyContext provider 的 context value 值。</li></ul><p>第一步：在context/index.js文件夹中创建两个Context，操作如下：</p><p><img src="'+S+'" alt="image-20241010153354061"></p><p>第二步：在入口文件index.js中，引入这两个context，并使用Provider组件传递数据。操作如下：</p><p><img src="'+E+'" alt="image-20241010154734363"></p><p>第三步：在App组件中通过useContext获取Provider组件提供的数据。操作如下：</p><p><img src="'+y+'" alt="image-20241010155954922"></p><p>第四步：浏览器中查看效果，操作如下：</p><p><img src="'+R+'" alt="image-20241010160035412"></p><h3 id="_2-usereducer" tabindex="-1"><a class="header-anchor" href="#_2-usereducer" aria-hidden="true">#</a> 2，useReducer</h3><p><img src="'+D+'" alt="image-20241010131209742"></p><p>很多人看到useReducer的第一反应应该是redux的某个替代品，其实并不是。</p><p>useReducer仅仅是useState的一种替代方案：</p><ul><li>在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分；</li><li>或者这次修改的state需要依赖之前的state时，也可以使用；</li></ul><p>数据是不会共享的，它们只是使用了相同的counterReducer的函数而已。</p><p>所以，useReducer只是useState的一种替代品，并不能替代Redux。</p><p><img src="'+A+'" alt="image-20241010164226412"></p><h2 id="四-callback-memo" tabindex="-1"><a class="header-anchor" href="#四-callback-memo" aria-hidden="true">#</a> 四，Callback/Memo</h2><h3 id="_1-usecallback" tabindex="-1"><a class="header-anchor" href="#_1-usecallback" aria-hidden="true">#</a> 1，useCallback</h3><p><img src="'+v+'" alt="image-20241010131239616"></p><p>useCallback实际的目的是为了进行性能的优化。</p><p>如何进行性能的优化呢？</p><ul><li>useCallback会返回一个函数的 memoized（记忆的） 值；</li><li>在依赖不变的情况下，多次定义的时候，返回的值是相同的；</li></ul><p>案例：</p><ul><li>案例一：使用useCallback和不使用useCallback定义一个函数是否会带来性能的优化；</li><li>案例二：使用useCallback和不使用useCallback定义一个函数传递给子组件是否会带来性能的优化；</li></ul><p>通常使用useCallback的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存；</p><h4 id="_1-1-现象一" tabindex="-1"><a class="header-anchor" href="#_1-1-现象一" aria-hidden="true">#</a> 1.1，现象一</h4><p>现象一：当组件更新时，组件内部定义的函数会被再次定义，操作如下：</p><p><img src="'+O+'" alt="image-20241011132213528"></p><h4 id="_1-2-现象二" tabindex="-1"><a class="header-anchor" href="#_1-2-现象二" aria-hidden="true">#</a> 1.2，现象二</h4><p>现象二：App组件重新渲染时，使用useCallback并不能解决函数多次定义的问题。操作如下:</p><p><img src="'+T+'" alt="image-20241011134604731"></p><h4 id="_1-3-usecallback的性能优化" tabindex="-1"><a class="header-anchor" href="#_1-3-usecallback的性能优化" aria-hidden="true">#</a> 1.3 useCallback的性能优化</h4><p>存在的问题：修改了App组件的状态message，App组件会重新渲染。</p><p>此时变量increment引用的是新函数，并且通过自定义属性传递给子组件。此时因为子组件的props发生了改变，子组件会重新渲染。如果子组件中使用了很多其他组件，会造成性能浪费。操作如下：</p><p><img src="'+L+'" alt="image-20241011144634482"></p><p>使用useCallback进行性能优化，操作如下：</p><p><img src="'+P+'" alt="image-20241011145656194"></p><p>useCallback使用总结如下：</p><h3 id="_2-usememo" tabindex="-1"><a class="header-anchor" href="#_2-usememo" aria-hidden="true">#</a> 2，useMemo</h3><p><img src="'+I+'" alt="image-20241010131304250"></p><p>useMemo实际的目的也是为了进行性能的优化。</p><p>如何进行性能的优化呢？</p><ul><li>useMemo返回的也是一个 memoized（记忆的） 值；</li><li>在依赖不变的情况下，多次定义的时候，返回的值是相同的；</li></ul><p>案例：</p><ul><li>案例一：进行大量的计算操作，是否有必须要每次渲染时都重新计算；</li><li>案例二：对子组件传递相同内容的对象时，使用useMemo进行性能的优化</li></ul><h4 id="_2-1-案例一-计数器" tabindex="-1"><a class="header-anchor" href="#_2-1-案例一-计数器" aria-hidden="true">#</a> 2.1，案例一：计数器</h4><p>第一步：有一个计算1到50的和的函数，在App组件中被使用。App组件在被重新渲染时，该函数还是会被重新调用。这样做是不合理的，因为该函数并没有依赖App组件中的状态，因此并不需要重新执行。操作如下：</p><p><img src="'+V+'" alt="image-20241010232304866"></p><p>第二步：使用useMemo对calcNumTotal函数进行优化，操作如下：</p><p><img src="'+J+'" alt="image-20241010233321244"></p><p>第三步：useMemo和useCallback的对比，操作如下：</p><p><img src="'+N+'" alt="image-20241010234402338"></p><p>第四步：calcNumTotal函数的实参依赖App组件的状态count，并向callMemo的依赖数组中传入count。操作如下：</p><p><img src="'+z+'" alt="image-20241010235212341"></p><h4 id="_2-2-案例二-给子组件传递对象" tabindex="-1"><a class="header-anchor" href="#_2-2-案例二-给子组件传递对象" aria-hidden="true">#</a> 2.2，案例二：给子组件传递对象</h4><p>第一步：如果我们将一个返回基本数据类型传的函数调用递给子组件，那么父组件在重新进行渲染时，该函数会被重新执行。操作如下：</p><p><img src="'+B+'" alt="image-20241011002041562"></p><p>第二步：使用useMemo对该函数的返回值进行优化，再传递给子组件。操作如下：</p><p><img src="'+U+'" alt="image-20241011002647617"></p><p>第三步：给子组件传递一个对象类型的数据，当我们点击按钮修改count，子组件也会重新渲染。操作如下：</p><p><img src="'+w+'" alt="image-20241011074729063"></p><p>第四步：使用useMemo通过返回值对返回的对象进行优化，操作如下：</p><p><img src="'+W+'" alt="image-20241011075428002"></p><h2 id="五-ref-layouteffect" tabindex="-1"><a class="header-anchor" href="#五-ref-layouteffect" aria-hidden="true">#</a> 五，Ref/LayoutEffect</h2><h3 id="_1-useref" tabindex="-1"><a class="header-anchor" href="#_1-useref" aria-hidden="true">#</a> 1，useRef</h3><p><img src="'+q+'" alt="image-20241010131326813"></p><p>useRef返回一个ref对象，返回的ref对象再组件的整个生命周期保持不变。</p><p>最常用的ref是两种用法：</p><ul><li>用法一：引入DOM（或者组件，但是需要是class组件）元素；</li><li>用法二：保存一个数据，这个对象在整个生命周期中可以保存不变；</li></ul><p>案例：</p><ul><li>案例一：引用DOM</li><li>案例二：使用ref保存上一次的某一个值</li></ul><h4 id="_1-1-使用useref获取dom元素" tabindex="-1"><a class="header-anchor" href="#_1-1-使用useref获取dom元素" aria-hidden="true">#</a> 1.1，使用useRef获取DOM元素</h4><p>第一步：使用useRef获取input元素，点击按钮该input元素获取焦点。操作如下：</p><p><img src="'+F+'" alt="image-20241011082313460"></p><h4 id="_1-2-使用ref绑定值" tabindex="-1"><a class="header-anchor" href="#_1-2-使用ref绑定值" aria-hidden="true">#</a> 1.2，使用ref绑定值</h4><p>第二步：useRef绑定值和解决闭包陷阱，操作如下：</p><p><img src="'+G+'" alt="image-20241011113358222"></p><p><img src="'+K+'" alt="image-20241011114616172"></p><p>第三步：useRef创建出来的对象在组件的整个生命周期中都不会改变，因此我们可以将状态挂载到该对象身上，从而解决闭包陷阱。操作如下：</p><p><img src="'+Q+'" alt="image-20241011185837282"></p><p><img src="'+X+'" alt="image-20241011190517603"></p><h3 id="_2-useimperativehandle" tabindex="-1"><a class="header-anchor" href="#_2-useimperativehandle" aria-hidden="true">#</a> 2，useImperativeHandle</h3><p><img src="'+Y+'" alt="image-20241011195214569"></p><p>第一步：通过我们之前学习过的useRef和forwardRef，我们可以在父组件中获取到子组件中某个DOM元素。因此我们可以对这个子组件中的DOM元素做任意操作。如下：</p><p><img src="'+Z+'" alt="image-20241011203715014"></p><p>第二步：我们可以使用useImperativeHandle，来限制父组件操作子组件中DOM元素的权限。操作如下：</p><p><img src="'+$+'" alt="image-20241011205017507"></p><p>第三步：如果我我们希望点击按钮获取焦点的同时还可以清空input框中输入的内容，我们可以在useImperativeHandle的回调函数中在返回一个setValue方法。操作如下：</p><p><img src="'+ee+'" alt="image-20241011205654674"></p><p>这个钩子函数在一些第三方库中可能会使用，因为不希望将操作DOM元素的所有权限暴露给用户。</p><h3 id="_3-uselayouteffect" tabindex="-1"><a class="header-anchor" href="#_3-uselayouteffect" aria-hidden="true">#</a> 3，useLayoutEffect</h3><p><img src="'+ae+'" alt="image-20241011205934251"></p><p>useLayoutEffect看起来和useEffect非常的相似，事实上他们也只有一点区别而已：</p><ul><li>useEffect会在渲染的内容更新到DOM上后执行，不会阻塞DOM的更新；</li><li>useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新；</li></ul><h4 id="_3-1-执行顺序" tabindex="-1"><a class="header-anchor" href="#_3-1-执行顺序" aria-hidden="true">#</a> 3.1，执行顺序</h4><p>展示useEffect和useLayoutEffect的执行顺序，操作如下：</p><p><img src="'+ie+'" alt="image-20241011213001484"></p><h4 id="_3-2-切换数字-useeffect" tabindex="-1"><a class="header-anchor" href="#_3-2-切换数字-useeffect" aria-hidden="true">#</a> 3.2，切换数字-useEffect</h4><p><img src="'+se+'" alt="image-20241011214701486"></p><h4 id="_3-3-切换数字-uselayouteffec" tabindex="-1"><a class="header-anchor" href="#_3-3-切换数字-uselayouteffec" aria-hidden="true">#</a> 3.3 切换数字-useLayoutEffec</h4><p><img src="'+te+'" alt="image-20241011215751346"></p><h2 id="六-自定义hooks使用" tabindex="-1"><a class="header-anchor" href="#六-自定义hooks使用" aria-hidden="true">#</a> 六，自定义Hooks使用</h2><p><img src="'+pe+'" alt="image-20241011215839708"></p><h3 id="_1-基本使用" tabindex="-1"><a class="header-anchor" href="#_1-基本使用" aria-hidden="true">#</a> 1，基本使用</h3><p>自定义Hook本质上只是一种函数代码逻辑的抽取，严格意义上来说，它本身并不算React的特性。</p><p>需求：所有的组件在创建和销毁时都进行打印</p><ul><li>组件被创建：打印 组件被创建了；</li><li>组件被销毁：打印 组件被销毁了；</li></ul><p><img src="'+re+'" alt="image-20241011222244950"></p><h3 id="_2-案例练习" tabindex="-1"><a class="header-anchor" href="#_2-案例练习" aria-hidden="true">#</a> 2，案例练习</h3><p><img src="'+ne+'" alt="image-20241011222342733"></p><p><img src="'+ce+'" alt="image-20241011222407322"></p><h4 id="_2-1-context共享" tabindex="-1"><a class="header-anchor" href="#_2-1-context共享" aria-hidden="true">#</a> 2.1，context共享</h4><p>封装一个返回用户信息和token的context的hook。</p><p>第一步：封装一个useUserToken的hook，并在Hooks/index.js文件中统一导出。操作如下：</p><p><img src="'+ge+'" alt="image-20241011224724373"></p><p>第二步：创建两个context，并在入口文件中通过Provider组件共享数据。操作如下：</p><p><img src="'+oe+'" alt="image-20241011225038435"></p><p>第三步：在Home组件和About组件中引入自定义hook并使用返回的数据。操作如下：</p><p><img src="'+me+'" alt="image-20241011225302209"></p><p>第四步：浏览器查看效果如下：</p><p><img src="'+le+'" alt="image-20241011225411917"></p><h4 id="_2-2-获取窗口滚动位置" tabindex="-1"><a class="header-anchor" href="#_2-2-获取窗口滚动位置" aria-hidden="true">#</a> 2.2，获取窗口滚动位置</h4><p>第一步：在Home组件内实现获取页面滚动位置，操作如下：</p><p><img src="'+de+'" alt="image-20241011230631431"></p><p>第二步：封装一个获取滚动位置的hook(useScrollPosition)，并在hook/index.js文件中统一导出。操作如下：</p><p><img src="'+he+'" alt="image-20241011233130761"></p><p>第三步：在Home组件和About组件中引用该自定义hook，并使用其返回的数据。操作如下：</p><p><img src="'+_e+'" alt="image-20241011233418273"></p><p>第四步：打开浏览器滚动页面查看效果。操作如下：</p><p><img src="'+ue+'" alt="image-20241011233514738"></p><h4 id="_2-3-storage数据存储" tabindex="-1"><a class="header-anchor" href="#_2-3-storage数据存储" aria-hidden="true">#</a> 2.3，storage数据存储</h4><p>需求：从localStorage中获取初始值并赋值给一个状态，在该状态发生变化时，又通过localStorage修改存储的该值。</p><p>第一步：在组件内完成：将localStorage中的数据赋值给一个状态，在该状态发生改变时，又修改localStorage中存储的数据。操作如下：</p><p><img src="'+fe+'" alt="image-20241012082236144"></p><p>第二步：在开发中可能会有多个状态与本地存储中的状态同步，并且其他组件中也可能会使用。因此我们将其封装为一个自定义hook。操作如下：</p><p><img src="'+xe+'" alt="image-20241012135806853"></p><p>第三步：在App组件引入该自定义hook，并使用其返回的值和方法。操作如下：</p><p><img src="'+be+'" alt="image-20241012140135594"></p><p>第四步：打开浏览器查看效果，操作如下：</p><p><img src="'+je+'" alt="image-20241012140258705"></p><h2 id="七-redux-hooks" tabindex="-1"><a class="header-anchor" href="#七-redux-hooks" aria-hidden="true">#</a> 七，redux hooks</h2><p><img src="'+ke+'" alt="image-20241012142622114"></p><p>第一步：安装@reduxjs/toolkit react-redux，操作如下：</p><p><img src="'+Me+'" alt="image-20241012143057118"></p><p>第二步：在store/modules/counter.js文件中创建counter片段，并导出。操作如下：</p><p><img src="'+He+'" alt="image-20241012144404244"></p><p>第三步：在入口文件中，使用react-redux提供的Provider共享store。操作如下：</p><p><img src="'+Ce+'" alt="image-20241012144614358"></p><h3 id="_1-useselector" tabindex="-1"><a class="header-anchor" href="#_1-useselector" aria-hidden="true">#</a> 1，useSelector</h3><p>useSelector的作用是将state映射到组件中：</p><ul><li>参数一：将state映射到需要的数据中；</li><li>参数二：可以进行比较来决定是否组件重新渲染；（后续讲解）</li></ul><p>第四步：在App组件中回顾我们之前在类组件中使用connect高阶函数的做法。操作如下：</p><p><img src="'+Se+'" alt="image-20241012152902111"></p><p>第五步：使用react-redux提供的hook—useSelector，就可以方便的在组件内使用redux中store的数据。操作如下：</p><p><img src="'+Ee+'" alt="image-20241012154136465"></p><h3 id="_2-usedispatch" tabindex="-1"><a class="header-anchor" href="#_2-usedispatch" aria-hidden="true">#</a> 2，useDispatch</h3><p>第六步：使用hook-useDispatch返回的dispatch函数，我们可以使用它直接派发action，来修改store中的数据。操作如下：</p><p><img src="'+ye+'" alt="image-20241012213229821"></p><h3 id="_3-useselector性能优化" tabindex="-1"><a class="header-anchor" href="#_3-useselector性能优化" aria-hidden="true">#</a> 3，useSelector性能优化</h3><p>现象：App组件使用了store中的状态count，Home组件使用了store中的状态message。在App组件中修改count，会导致Home组件重新渲染，这是不合理的，因为Home组件使用了memo进行了包裹并且其中没有使用状态count。操作如下：</p><p><img src="'+Re+'" alt="image-20241012215134778"></p><p>因此我们需要在使用useSelector时，传入第二个参数，保证只进行浅层比较。操作如下：</p><p><img src="'+De+'" alt="image-20241012221922473"></p><h2 id="八-其他hooks" tabindex="-1"><a class="header-anchor" href="#八-其他hooks" aria-hidden="true">#</a> 八，其他Hooks</h2><h3 id="_1-服务端渲染" tabindex="-1"><a class="header-anchor" href="#_1-服务端渲染" aria-hidden="true">#</a> 1，服务端渲染</h3><p><img src="'+Ae+'" alt="image-20241012225246815"></p><p>什么是SPA应用？</p><ol><li>先下载index.html页面(几乎没有任何html元素，只包含一个根元素)。</li><li>再下载bundle.js，</li><li>执行bundle.js代码，创建出完整的页面结构。</li><li>浏览器再渲染出完整的页面。</li></ol><p>什么是服务端渲染？</p><ul><li>页面在服务器端已经生成了完整的HTML页面结构，不需要浏览器通过JS代码，创建页面页面结构。</li></ul><p>SPA向对于服务端渲染有什么缺点？</p><ol><li>不利于SEO，因为百度的搜索引擎内部爬虫会爬取网站的index.html，将爬取到的内容收录到数据库中。 <ol><li>但是因为SPA页面的index.html中，除了meta标签外，只有一个div#root元素，没有可爬取的内容。</li><li>因为服务端渲染是将整个index.html文件在服务器中渲染完成后，再以字符串的形式传递给客户端。因此可被爬取的内容会非常多。</li></ol></li><li>首屏加载速度慢 <ol><li>对于SPA页面，浏览器需要先下载index.html，再下载bundle.js并执行它生成完整的页面结构，浏览器最终完成渲染。因此第一次渲染会非常慢。</li><li>因为服务端在服务器内渲染好了，因此浏览器可以直接展示。</li></ol></li></ol><h3 id="_2-ssr同构应用" tabindex="-1"><a class="header-anchor" href="#_2-ssr同构应用" aria-hidden="true">#</a> 2，SSR同构应用</h3><p><img src="'+ve+'" alt="image-20241012225314420"></p><p>什么是同构应用？</p><p>答：一套代码既可以在服务端运行又可以在浏览器端运行。</p><p>为什么需要同构应用？在node中渲染出来的HTML结构直接让浏览器渲染不就得了？为什么还需要在浏览器中再运行一遍？</p><p>答：因为服务端渲染有个缺点，服务端渲染出来的的HTML结构本质是一堆字符串。浏览器下载index.html并将这个HTML结构渲染成页面。因为没有下载并执行JS代码，因此该网站缺乏交互性。例如按钮的点击和其他页面的切换。因此还需要将交互的东西注入到该网站中，也就是需要运行的js代码再执行一遍，重新再渲染一次。所以说这个过程称为hydrate。</p><h3 id="_3-hydration" tabindex="-1"><a class="header-anchor" href="#_3-hydration" aria-hidden="true">#</a> 3，Hydration</h3><p><img src="'+Oe+'" alt="image-20241012225334395"></p><p>那么什么是Hydration？</p><p>答：同构应用的一个步骤。为了是SSR渲染出来的网站具有交互性，因此还需要注入对应的交互，加载对应的JS代码并执行，让浏览器再渲染一遍这个网站。</p><h3 id="_4-useid的作用" tabindex="-1"><a class="header-anchor" href="#_4-useid的作用" aria-hidden="true">#</a> 4，useId的作用</h3><p><img src="'+Te+'" alt="image-20241013110037617"></p><p>useId 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。</p><p><img src="'+Le+'" alt="image-20241013141222712"></p><h3 id="_5-usetransition" tabindex="-1"><a class="header-anchor" href="#_5-usetransition" aria-hidden="true">#</a> 5，useTransition</h3><p>官方解释：返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。</p><ul><li>事实上官方的说法，还是让人云里雾里，不知所云。</li></ul><p>useTransition到底是干嘛的呢？它其实在告诉react对于某部分任务的更新优先级较低，可以稍后进行更新。</p><p>第一步：安装@faker-js/faker，可以用它来生成随机数据。操作如下：</p><p><img src="'+Pe+'" alt="image-20241013222142923"></p><p>第二步：使用faker生成随机name，操作如下：</p><p><img src="'+Ie+'" alt="image-20241013223120985"></p><p>第三步：搭建案例基本结构，在输入框中输入字符串，会将包含字符串的name过滤出来并渲染。操作如下：</p><p><img src="'+Ve+'" alt="image-20241013230526395"></p><p>第三步：渲染一万个随机name，在输入框输入删除内容，会发现点击了删除按钮，输入框中的内容并没有发生变化，造成一种卡顿的现象，这是为什么？删掉n的更新和渲染一万条数据的更新同时进行，因此造成卡顿现象。</p><p><img src="'+Je+'" alt="image-20241013235223941"></p><p>第四步：使用Hook-useTransition降低任务的优先级，操作如下：</p><p><img src="'+Ne+'" alt="image-20241014001030398"></p><h3 id="_6-usedeferredvalue" tabindex="-1"><a class="header-anchor" href="#_6-usedeferredvalue" aria-hidden="true">#</a> 6，useDeferredValue</h3><p><img src="'+ze+'" alt="image-20241014001130867"></p><p>官方解释：useDeferredValue 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。</p><p>在明白了useTransition之后，我们就会发现useDeferredValue的作用是一样的效果，可以让我们的更新延迟。</p><p><img src="'+Be+'" alt="image-20241014081033513"></p>',250),We=[we];function qe(Fe,Ge){return a(),i("div",null,We)}const Qe=e(Ue,[["render",qe],["__file","29.html.vue"]]);export{Qe as default};
