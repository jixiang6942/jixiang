import{_ as a,o as i,c as e,a as s}from"./app-fbcf72b1.js";const t="/jixiang/assets/image-20240120094415994-d5d69193.png",p="/jixiang/assets/image-20240120095158022-192f2938.png",r="/jixiang/assets/image-20240120095820501-34c9a2e9.png",n="/jixiang/assets/image-20240120100151950-911b2cc0.png",g="/jixiang/assets/image-20240120100440605-0bed4702.png",m="/jixiang/assets/image-20240120100753258-9bc09d87.png",c="/jixiang/assets/image-20240120101039937-969e48ac.png",o="/jixiang/assets/image-20240120101316798-08d86a2d.png",d="/jixiang/assets/image-20240120101656135-044e474c.png",h="/jixiang/assets/image-20240120102433817-853bb692.png",l="/jixiang/assets/image-20240120103807157-ac2f4afc.png",_="/jixiang/assets/image-20240120103055142-ea5df139.png",x="/jixiang/assets/image-20240120103349509-4908cd4e.png",b="/jixiang/assets/image-20240120110016751-01a9aed1.png",f="/jixiang/assets/image-20240120104927779-9e129d45.png",j="/jixiang/assets/image-20240120110045281-2fedad51.png",u="/jixiang/assets/image-20240120110137978-758b94f7.png",y="/jixiang/assets/image-20240120110439791-a2b75745.png",S="/jixiang/assets/image-20240120154344186-f29be222.png",k="/jixiang/assets/image-20240120154842519-95d3a34f.png",w="/jixiang/assets/image-20240120164000712-a8f86151.png",E="/jixiang/assets/image-20240120165608575-8b9b1bd1.png",O="/jixiang/assets/image-20240120164647668-5300ad00.png",P="/jixiang/assets/image-20240120165404227-653477d3.png",A="/jixiang/assets/image-20240120165751986-08d959bd.png",v="/jixiang/assets/image-20240120170259164-f242136a.png",C="/jixiang/assets/image-20240120173803548-3e299e13.png",B="/jixiang/assets/image-20240120173834503-26144f18.png",W="/jixiang/assets/image-20240120174035058-16b0f224.png",R="/jixiang/assets/image-20240120175422431-5e3a81ee.png",M="/jixiang/assets/image-20240120180029987-a183ee54.png",G="/jixiang/assets/image-20240120181146882-ce65bad3.png",D="/jixiang/assets/image-20240120185024898-fd935403.png",z="/jixiang/assets/image-20240120185250812-2baccb78.png",N="/jixiang/assets/image-20240120185855828-2150ef5d.png",F="/jixiang/assets/image-20240120190058716-6d984fd9.png",I="/jixiang/assets/image-20240120190737624-d96561cf.png",J="/jixiang/assets/image-20240120192217710-b0b3d31e.png",T="/jixiang/assets/image-20240121074501928-30e1ef4b.png",K="/jixiang/assets/image-20240121075335802-88156de4.png",V="/jixiang/assets/image-20240121075622487-780272f3.png",q="/jixiang/assets/image-20240121080543823-ac988ca5.png",H="/jixiang/assets/image-20240121081236289-8e1e0801.png",L="/jixiang/assets/image-20240121090546904-0c32b222.png",Q="/jixiang/assets/02_浅拷贝-原始类型-cf52f29a.png",U="/jixiang/assets/image-20240121091449746-e3b1d789.png",X="/jixiang/assets/03_浅拷贝-复杂类型-ca2eda9d.png",Y="/jixiang/assets/image-20240121100631118-0d2100ca.png",Z="/jixiang/assets/image-20240121101351766-d7064e5f.png",$="/jixiang/assets/image-20240121101932191-84a5e62b.png",aa="/jixiang/assets/image-20240121103424247-c155d62a.png",ia="/jixiang/assets/image-20240121105123796-ae6c03ce.png",ea="/jixiang/assets/image-20240121110328537-8e79932c.png",sa="/jixiang/assets/image-20240121110514112-37b4f0c1.png",ta="/jixiang/assets/image-20240121112105608-8c7e5555.png",pa="/jixiang/assets/image-20240121112209010-e7163460.png",ra="/jixiang/assets/image-20240121123647781-4320e64c.png",na="/jixiang/assets/image-20240121143843555-bbd7c30d.png",ga="/jixiang/assets/image-20240121144742389-8bc7e9d5.png",ma="/jixiang/assets/image-20240121144814811-822d3a7f.png",ca="/jixiang/assets/image-20240121153102789-3b52eb24.png",oa="/jixiang/assets/image-20240121153648642-6968aa1b.png",da="/jixiang/assets/image-20240121154502379-24e638fb.png",ha="/jixiang/assets/image-20240121162017103-7a30e78a.png",la="/jixiang/assets/image-20240121162333379-60c19d01.png",_a="/jixiang/assets/image-20240121162752075-0c637c48.png",xa="/jixiang/assets/image-20240121154542792-ec9870c9.png",ba="/jixiang/assets/image-20240121164522034-267d1761.png",fa="/jixiang/assets/image-20240121165447972-c46447cf.png",ja="/jixiang/assets/image-20240121154616573-a4b0dbef.png",ua="/jixiang/assets/image-20240121170434943-328d69eb.png",ya="/jixiang/assets/image-20240121154638500-a3bd2386.png",Sa="/jixiang/assets/image-20240121172207307-f0ff5651.png",ka="/jixiang/assets/image-20240121172304688-c56dee8d.png",wa="/jixiang/assets/image-20240121172357536-c350f2b3.png",Ea="/jixiang/assets/image-20240121174256638-dd7c80e8.png",Oa="/jixiang/assets/image-20240121174354176-c41a8651.png",Pa="/jixiang/assets/image-20240121174523862-a2b43487.png",Aa="/jixiang/assets/image-20240121180132609-4d5e0395.png",va="/jixiang/assets/image-20240121180258757-dd3c4c35.png",Ca="/jixiang/assets/image-20240121180937069-50391d56.png",Ba="/jixiang/assets/image-20240121182534244-0d97c742.png",Wa="/jixiang/assets/image-20240121182857072-094a47e7.png",Ra="/jixiang/assets/image-20240121183053044-c7073f4c.png",Ma="/jixiang/assets/image-20240121180318540-a728a80b.png",Ga="/jixiang/assets/image-20240121183503668-b59f7546.png",Da="/jixiang/assets/image-20240121180340032-80f7fe67.png",za="/jixiang/assets/image-20240121183927418-7e277f51.png",Na="/jixiang/assets/image-20240121184335195-2fcc5429.png",Fa="/jixiang/assets/image-20240121184719124-b2e16352.png",Ia="/jixiang/assets/image-20240121185024667-c972ca0f.png",Ja="/jixiang/assets/image-20240121192213249-3555c3f3.png",Ta="/jixiang/assets/image-20240121192509909-42f87e31.png",Ka="/jixiang/assets/image-20240121192618126-6be0ffbf.png",Va="/jixiang/assets/image-20240121193147538-920b2e00.png",qa="/jixiang/assets/image-20240121193124017-93ef42d0.png",Ha="/jixiang/assets/image-20240121193341776-be5ce12b.png",La="/jixiang/assets/image-20240121194212742-b561045a.png",Qa="/jixiang/assets/image-20240121194402581-4c3a40d4.png",Ua="/jixiang/assets/image-20240122105310683-0468ea28.png",Xa="/jixiang/assets/image-20240122104622709-8d2cbbfe.png",Ya="/jixiang/assets/image-20240122104835878-8b75d1c3.png",Za="/jixiang/assets/image-20240122105038705-585d93ed.png",$a="/jixiang/assets/image-20240122105326753-499dd92e.png",a2="/jixiang/assets/image-20240122110026706-f1836794.png",i2="/jixiang/assets/image-20240122110623741-15a54900.png",e2="/jixiang/assets/image-20240122111228221-159404fb.png",s2="/jixiang/assets/image-20240122111943488-fbdf5aab.png",t2="/jixiang/assets/image-20240122112437302-12aa18db.png",p2="/jixiang/assets/image-20240122113021110-09889748.png",r2="/jixiang/assets/image-20240122113325902-b8bb6a21.png",n2="/jixiang/assets/image-20240122113500859-68f83d2c.png",g2="/jixiang/assets/image-20240122113653095-427007ce.png",m2="/jixiang/assets/image-20240122113844264-26763f39.png",c2="/jixiang/assets/image-20240122114316531-6f98e145.png",o2="/jixiang/assets/image-20240122114945552-d9dcdfdb.png",d2="/jixiang/assets/image-20240122115626084-0dc2c33f.png",h2="/jixiang/assets/image-20240122115729820-6cbfe8d9.png",l2="/jixiang/assets/image-20240122115900499-e7b3e8ab.png",_2="/jixiang/assets/image-20240122122057896-7b092718.png",x2="/jixiang/assets/image-20240122122443151-e538a3a3.png",b2="/jixiang/assets/image-20240122122744561-caf9ef2b.png",f2="/jixiang/assets/image-20240122123026934-3319d1fe.png",j2="/jixiang/assets/image-20240122123328143-15b08997.png",u2="/jixiang/assets/image-20240122124205290-1b1de220.png",y2="/jixiang/assets/image-20240122185841911-f307559f.png",S2="/jixiang/assets/image-20240122193335106-5292ba77.png",k2="/jixiang/assets/image-20240122193928992-f4128802.png",w2="/jixiang/assets/image-20240122195137983-b7b1ed3f.png",E2="/jixiang/assets/image-20240122193949187-39883e08.png",O2="/jixiang/assets/image-20240122200101499-f6da925e.png",P2="/jixiang/assets/image-20240122200511223-f1f0bf42.png",A2="/jixiang/assets/image-20240122200628246-8aa3eb70.png",v2="/jixiang/assets/image-20240122202102000-96946d50.png",C2="/jixiang/assets/image-20240122203115364-dab72199.png",B2="/jixiang/assets/image-20240122203542330-2ff0594c.png",W2="/jixiang/assets/image-20240122203636788-0a580108.png",R2="/jixiang/assets/image-20240122220303138-7dd27fd6.png",M2="/jixiang/assets/image-20240122203747203-864f08cf.png",G2="/jixiang/assets/image-20240122203814616-a8b77c31.png",D2="/jixiang/assets/image-20240122221814354-8679c10e.png",z2="/jixiang/assets/image-20240122203827705-3b4d14cb.png",N2="/jixiang/assets/image-20240122225144696-624bb145.png",F2="/jixiang/assets/image-20240122225014551-07ef6224.png",I2="/jixiang/assets/image-20240122225515697-3263f273.png",J2="/jixiang/assets/image-20240123080919289-acf13811.png",T2="/jixiang/assets/image-20240123093251108-853c6706.png",K2="/jixiang/assets/image-20240123095506517-4bd24dbe.png",V2="/jixiang/assets/image-20240123095558085-b21f02cf.png",q2="/jixiang/assets/image-20240123095635441-f2da8678.png",H2="/jixiang/assets/image-20240123095719023-33144686.png",L2="/jixiang/assets/image-20240123100056550-035addc7.png",Q2="/jixiang/assets/image-20240124080841305-295aed40.png",U2="/jixiang/assets/image-20240124081430393-24f354df.png",X2="/jixiang/assets/image-20240124082535954-b04fb153.png",Y2="/jixiang/assets/image-20240124082929695-bff3bd9d.png",Z2="/jixiang/assets/image-20240124083321626-1cb2ef6a.png",$2="/jixiang/assets/image-20240124092220725-45b204db.png",ai="/jixiang/assets/image-20240124092324074-df8045ef.png",ii="/jixiang/assets/image-20240124092639867-763f7458.png",ei={},si=s('<h1 id="es6-es13" tabindex="-1"><a class="header-anchor" href="#es6-es13" aria-hidden="true">#</a> ES6~ES13</h1><h2 id="一-新特性一" tabindex="-1"><a class="header-anchor" href="#一-新特性一" aria-hidden="true">#</a> 一，新特性一</h2><h3 id="_1-解构" tabindex="-1"><a class="header-anchor" href="#_1-解构" aria-hidden="true">#</a> 1. 解构</h3><p><img src="'+t+'" alt="image-20240120094415994"></p><h4 id="a-数组解构" tabindex="-1"><a class="header-anchor" href="#a-数组解构" aria-hidden="true">#</a> A）数组解构</h4><p>通过索引的方式一个个获取数组元素，会很麻烦，所以我们使用数组解构，如下：</p><p><img src="'+p+'" alt="image-20240120095158022"></p><p>数组解构有严格的顺序，如果我们想跳过某些元素，可以使用逗号代替，如下：</p><p><img src="'+r+'" alt="image-20240120095820501"></p><p>在数组解构时，我们还可以将多个元素放入到一个新数组中，如下：</p><p><img src="'+n+'" alt="image-20240120100151950"></p><p>解构时如果某个元素是undef，我们还可以给他赋默认值，如下：</p><p><img src="'+g+'" alt="image-20240120100440605"></p><h4 id="b-对象解构" tabindex="-1"><a class="header-anchor" href="#b-对象解构" aria-hidden="true">#</a> B）对象解构</h4><p>可以通过对象解构直接获取到属性值，而不需要点语法挨个获取，如下：</p><p><img src="'+m+'" alt="image-20240120100753258"></p><p>我们在解构对象时，还可以对变量重命名，如下：</p><p><img src="'+c+'" alt="image-20240120101039937"></p><p>我们在对象解构时，还可以赋默认值，如下：</p><p><img src="'+o+'" alt="image-20240120101316798"></p><p>解构时，我们还可以将多个属性，放入到一个新对象中，如下：</p><p><img src="'+d+'" alt="image-20240120101656135"></p><h3 id="_3-let、const的使用" tabindex="-1"><a class="header-anchor" href="#_3-let、const的使用" aria-hidden="true">#</a> 3. let、const的使用</h3><p>共同点：</p><ul><li>不能重复声明，暂时性死区</li><li>产生块级作用域。</li><li>没有作用域提升</li></ul><h4 id="a-基本使用" tabindex="-1"><a class="header-anchor" href="#a-基本使用" aria-hidden="true">#</a> A）基本使用</h4><p><img src="'+h+'" alt="image-20240120102433817"></p><p>注意：let和const都不能重复声明变量，如下：</p><p><img src="'+l+'" alt="image-20240120103807157"></p><p>const关键字定义的变量不能修改，如下：</p><p><img src="'+_+'" alt="image-20240120103055142"></p><p><img src="'+x+'" alt="image-20240120103349509"></p><h4 id="b-let和const的作用域提升" tabindex="-1"><a class="header-anchor" href="#b-let和const的作用域提升" aria-hidden="true">#</a> B）let和const的作用域提升</h4><p><img src="'+b+'" alt="image-20240120110016751"></p><p>let和const也都没有作用域提升(虽然已经被提前创建，但是不能访问)，如下：</p><p><img src="'+f+'" alt="image-20240120104927779"></p><h4 id="c-暂时性死区" tabindex="-1"><a class="header-anchor" href="#c-暂时性死区" aria-hidden="true">#</a> C）暂时性死区</h4><p><img src="'+j+'" alt="image-20240120110045281"></p><p>暂时性死区和定义的位置没有关系，和代码执行的顺序有关系，如下：</p><p><img src="'+u+'" alt="image-20240120110137978"></p><p>形成暂时性死去后，在该区域内容内，也不能访问外部的变量，如下：</p><p><img src="'+y+'" alt="image-20240120110439791"></p><h4 id="d-不会添加到window" tabindex="-1"><a class="header-anchor" href="#d-不会添加到window" aria-hidden="true">#</a> D）不会添加到window</h4><p><img src="'+S+'" alt="image-20240120154344186"></p><p>var定义的变量是会默认加到window上的，而let和const是不会，如下：</p><p><img src="'+k+'" alt="image-20240120154842519"></p><h4 id="e-let和const会产生块级作用域" tabindex="-1"><a class="header-anchor" href="#e-let和const会产生块级作用域" aria-hidden="true">#</a> E）let和const会产生块级作用域</h4><p><img src="'+w+'" alt="image-20240120164000712"></p><p><img src="'+E+'" alt="image-20240120165608575"></p><p>在ES6之前，是没有块级作用域的，如下：</p><p><img src="'+O+'" alt="image-20240120164647668"></p><p>在ES6中新增了块级作用域，并且通过let、const、function、class声明的标识符是具备块级作用域的限制的，如下：</p><p><img src="'+P+'" alt="image-20240120165404227"></p><p>值得注意的是，虽然function声明的函数像var那样在代码块外访问，但是不会有作用域提升，如下：</p><p><img src="'+A+'" alt="image-20240120165751986"></p><h4 id="f-var、let、const的选择" tabindex="-1"><a class="header-anchor" href="#f-var、let、const的选择" aria-hidden="true">#</a> F）var、let、const的选择</h4><p><img src="'+v+'" alt="image-20240120170259164"></p><h3 id="_4-模板字符串" tabindex="-1"><a class="header-anchor" href="#_4-模板字符串" aria-hidden="true">#</a> 4. 模板字符串</h3><h4 id="a-基本使用-1" tabindex="-1"><a class="header-anchor" href="#a-基本使用-1" aria-hidden="true">#</a> A）基本使用</h4><p><img src="'+C+'" alt="image-20240120173803548"></p><p>ES6允许我们使用字符串模板来嵌入JS的变量或者表达式来进行拼接，如下：</p><p><img src="'+B+'" alt="image-20240120173834503"></p><h4 id="b-标签模板字符串" tabindex="-1"><a class="header-anchor" href="#b-标签模板字符串" aria-hidden="true">#</a> B）标签模板字符串</h4><p><img src="'+W+'" alt="image-20240120174035058"></p><p><img src="'+R+'" alt="image-20240120175422431"></p><h4 id="c-应用场景" tabindex="-1"><a class="header-anchor" href="#c-应用场景" aria-hidden="true">#</a> C）应用场景</h4><p><img src="'+M+'" alt="image-20240120180029987"></p><h3 id="_5-es6函数增强的用法" tabindex="-1"><a class="header-anchor" href="#_5-es6函数增强的用法" aria-hidden="true">#</a> 5. ES6函数增强的用法</h3><h4 id="a-默认参数" tabindex="-1"><a class="header-anchor" href="#a-默认参数" aria-hidden="true">#</a> A）默认参数</h4><p>使用之前的方式定义默认值会不严谨，比如，我们可能会传入0、空字符串，false。如下：</p><p><img src="'+G+'" alt="image-20240120181146882"></p><p>可以通过三元运算符使我们的默认值更严谨，如下：</p><p><img src="'+D+'" alt="image-20240120185024898"></p><p>我们还可以使用ES新增??语法，判断是否为undefined或null，如下：</p><p><img src="'+z+'" alt="image-20240120185250812"></p><p>我们可以使用ES6默认值写法，如下：</p><p><img src="'+N+'" alt="image-20240120185855828"></p><h4 id="b-默认参数注意事项" tabindex="-1"><a class="header-anchor" href="#b-默认参数注意事项" aria-hidden="true">#</a> B）默认参数注意事项</h4><ul><li>默认参数放到最后。</li><li>默认参数后面的参数不会计算在length之内。</li><li>默认参数和剩余参数同时存在时，剩余参数放到最后。</li></ul><p><img src="'+F+'" alt="image-20240120190058716"></p><p><img src="'+I+'" alt="image-20240120190737624"></p><p>函数参数的默认值还可以和对象解构结合使用，如下：</p><p><img src="'+J+'" alt="image-20240120192217710"></p><h4 id="c-箭头函数没有原型" tabindex="-1"><a class="header-anchor" href="#c-箭头函数没有原型" aria-hidden="true">#</a> C）箭头函数没有原型</h4><p><img src="'+T+'" alt="image-20240121074501928"></p><p>箭头函数没有显式原型，如下：</p><p><img src="'+K+'" alt="image-20240121075335802"></p><h3 id="_6-展开运算符的使用" tabindex="-1"><a class="header-anchor" href="#_6-展开运算符的使用" aria-hidden="true">#</a> 6. 展开运算符的使用</h3><p><img src="'+V+'" alt="image-20240121075622487"></p><p>展开运算符可以在语法层面将数组和字符串展开，如下：</p><p><img src="'+q+'" alt="image-20240121080543823"></p><p>在ES9中，当我们构建对象字面量时，也可以使用展开运算符，如下：</p><p><img src="'+H+'" alt="image-20240121081236289"></p><p>值得注意的是，展开运算符是一种浅拷贝。简单数据类型的浅拷贝，如下：</p><p><img src="'+L+'" alt="image-20240121090546904"></p><p>我们可以画出简单数据类型浅拷贝的内存关系图，如下：</p><p><img src="'+Q+'" alt="02_浅拷贝-原始类型"></p><p>接下来我们看看复杂数据类型的浅拷贝，如下：</p><p><img src="'+U+'" alt="image-20240121091449746"></p><p>画出复杂数据类型的浅拷贝内存图，如下：</p><p><img src="'+X+'" alt="03_浅拷贝-复杂类型"></p><p>我们可以利用JSON实现深拷贝，如下：</p><p><img src="'+Y+'" alt="image-20240121100631118"></p><h3 id="_7-进制和长数字" tabindex="-1"><a class="header-anchor" href="#_7-进制和长数字" aria-hidden="true">#</a> 7. 进制和长数字</h3><p><img src="'+Z+'" alt="image-20240121101351766"></p><p><img src="'+$+'" alt="image-20240121101932191"></p><h3 id="_7-symbol类型用法" tabindex="-1"><a class="header-anchor" href="#_7-symbol类型用法" aria-hidden="true">#</a> 7. Symbol类型用法</h3><p><img src="'+aa+'" alt="image-20240121103424247"></p><h4 id="a-基本使用-2" tabindex="-1"><a class="header-anchor" href="#a-基本使用-2" aria-hidden="true">#</a> A）基本使用</h4><p>在ES6之前，对象的属性名都是字符串形式，那么很容易造成属性名的冲突。添加一个新的属性和值，很容易 造成冲突，从而覆盖掉它内部的某个属性。</p><p><img src="'+ia+'" alt="image-20240121105123796"></p><p>值得注意的是，Object.defineProperty不能获取到symbol对应的key，而是使用getOwnPropertySymbols，如下：</p><p><img src="'+ea+'" alt="image-20240121110328537"></p><p>另外我们还可以在调用Symbol函数时，传入description，用于对该symbol的描述。</p><h4 id="b-相同值的symbol" tabindex="-1"><a class="header-anchor" href="#b-相同值的symbol" aria-hidden="true">#</a> B）相同值的Symbol</h4><p><img src="'+sa+'" alt="image-20240121110514112"></p><p>我们可以使用Symbol.for方法来获取多个相同值得Symbol，如下：</p><p><img src="'+ta+'" alt="image-20240121112105608"></p><p>我们还可以通过Symbol.key，来获取symbo.for方法传入的key，如下：</p><p><img src="'+pa+'" alt="image-20240121112209010"></p><h3 id="_8-数据结构-set集合" tabindex="-1"><a class="header-anchor" href="#_8-数据结构-set集合" aria-hidden="true">#</a> 8. 数据结构-Set集合</h3><p>Set:</p><ul><li>存储元素不能重复。</li></ul><p>WeakSet：</p><ul><li>只能存储对象，并且是弱引用，随时被GC回收。</li><li>不能遍历，因为有可能造成对象不能被正常销毁。</li></ul><p><img src="'+ra+'" alt="image-20240121123647781"></p><h4 id="a-set基本使用" tabindex="-1"><a class="header-anchor" href="#a-set基本使用" aria-hidden="true">#</a> A）set基本使用</h4><p>Set是一个新增的数据结构，可以用来保存数据，类似于数组，但是和数组的区别是元素不能重复。如下：</p><p><img src="'+na+'" alt="image-20240121143843555"></p><p>应用场景，数组去重，如下：</p><p><img src="'+ga+'" alt="image-20240121144742389"></p><h4 id="b-set的常见方法" tabindex="-1"><a class="header-anchor" href="#b-set的常见方法" aria-hidden="true">#</a> B）set的常见方法</h4><p><img src="'+ma+'" alt="image-20240121144814811"></p><h4 id="c-weakset使用" tabindex="-1"><a class="header-anchor" href="#c-weakset使用" aria-hidden="true">#</a> C）weakSet使用</h4><p>WeakSet和Set的区别：</p><ul><li>WeakSet是能存储对象类型，不能存放基本数据类型。</li><li>WeakSet对元素的引用是弱引用，如果没有其他引用对WeakSet中的对象进行引用，GC会对其回收。</li></ul><p>WeakSet中存储的对象，没有别的对象对其进行引用时，GC会对其回收。</p><p><img src="'+ca+'" alt="image-20240121153102789"></p><h4 id="d-weakset的应用" tabindex="-1"><a class="header-anchor" href="#d-weakset的应用" aria-hidden="true">#</a> D）weakSet的应用</h4><p><img src="'+oa+'" alt="image-20240121153648642"></p><h3 id="_9-数据结构-map映射" tabindex="-1"><a class="header-anchor" href="#_9-数据结构-map映射" aria-hidden="true">#</a> 9. 数据结构-Map映射</h3><p>Map和WeakMap的区别：</p><ul><li>WeakMap的key只能是对象，不接受其他类型作为key。</li><li>WeakyMap的key对象的引用是弱引用，如果没有其他引用 引用这个对象，那么GC可以回收该对象。</li></ul><h4 id="a-map的基本使用" tabindex="-1"><a class="header-anchor" href="#a-map的基本使用" aria-hidden="true">#</a> A）Map的基本使用</h4><p><img src="'+da+'" alt="image-20240121154502379"></p><p>我们在使用对象作为另一个对象的key时，其实最终也会转成字符串，如下：</p><p><img src="'+ha+'" alt="image-20240121162017103"></p><p>对象类型的局限性：不可以使用复杂类型作为key，多个对象作为key时，还会覆盖，如下：</p><p><img src="'+la+'" alt="image-20240121162333379"></p><p><img src="'+_a+'" alt="image-20240121162752075"></p><h4 id="b-map的常见方法" tabindex="-1"><a class="header-anchor" href="#b-map的常见方法" aria-hidden="true">#</a> B）Map的常见方法</h4><p><img src="'+xa+'" alt="image-20240121154542792"></p><p>使用map方法进行操作，如下：</p><p><img src="'+ba+'" alt="image-20240121164522034"></p><p>需要注意的是，调用forEach拿到的item是值，而使用for...of得到的是键值对组成的数组，如下：</p><p><img src="'+fa+'" alt="image-20240121165447972"></p><h4 id="c-weakmap的基本使用" tabindex="-1"><a class="header-anchor" href="#c-weakmap的基本使用" aria-hidden="true">#</a> C）weakMap的基本使用</h4><p><img src="'+ja+'" alt="image-20240121154616573"></p><p>当WeakMap的key没有强引用指向它们时，会被GC回收。如下：</p><p><img src="'+ua+'" alt="image-20240121170434943"></p><h4 id="d-weakmap的应用" tabindex="-1"><a class="header-anchor" href="#d-weakmap的应用" aria-hidden="true">#</a> D）WeakMap的应用</h4><p><img src="'+ya+'" alt="image-20240121154638500"></p><h2 id="二-新特性二" tabindex="-1"><a class="header-anchor" href="#二-新特性二" aria-hidden="true">#</a> 二，新特性二</h2><h3 id="_1-es7新增特性解析" tabindex="-1"><a class="header-anchor" href="#_1-es7新增特性解析" aria-hidden="true">#</a> 1. ES7新增特性解析</h3><h4 id="a-array-includes" tabindex="-1"><a class="header-anchor" href="#a-array-includes" aria-hidden="true">#</a> A）Array Includes</h4><p><img src="'+Sa+'" alt="image-20240121172207307"></p><h4 id="b-object-values" tabindex="-1"><a class="header-anchor" href="#b-object-values" aria-hidden="true">#</a> B）Object values</h4><p><img src="'+ka+'" alt="image-20240121172304688"></p><h4 id="c-object-entries" tabindex="-1"><a class="header-anchor" href="#c-object-entries" aria-hidden="true">#</a> C）Object entries</h4><p><img src="'+wa+'" alt="image-20240121172357536"></p><h4 id="d-string-padding" tabindex="-1"><a class="header-anchor" href="#d-string-padding" aria-hidden="true">#</a> D）String Padding</h4><p><img src="'+Ea+'" alt="image-20240121174256638"></p><p>当某个字符串不满足某个位数时，我们可以使用padStart或padEnd，如下：</p><p><img src="'+Oa+'" alt="image-20240121174354176"></p><p>在实际开发中，我们可能对银行卡号或身份证号，只展示某几位，如下：</p><p><img src="'+Pa+'" alt="image-20240121174523862"></p><h3 id="_2-es9新增特性解析" tabindex="-1"><a class="header-anchor" href="#_2-es9新增特性解析" aria-hidden="true">#</a> 2. ES9新增特性解析</h3><p><img src="'+Aa+'" alt="image-20240121180132609"></p><h3 id="_3-es10新增特性解析" tabindex="-1"><a class="header-anchor" href="#_3-es10新增特性解析" aria-hidden="true">#</a> 3. ES10新增特性解析</h3><h4 id="a-flat和flatmap" tabindex="-1"><a class="header-anchor" href="#a-flat和flatmap" aria-hidden="true">#</a> A）flat和flatMap</h4><p><img src="'+va+'" alt="image-20240121180258757"></p><p>使用flat可以将数组按照指定深度，打平，如下：</p><p><img src="'+Ca+'" alt="image-20240121180937069"></p><p>需求：数组中的每一项，切割后，将每一项，放入一个新的数组中。</p><p>方式一：使用for循环的做法，如下：</p><p><img src="'+Ba+'" alt="image-20240121182534244"></p><p>方式二：先使用map，再使用flat，如下：</p><p><img src="'+Wa+'" alt="image-20240121182857072"></p><p>方式三：使用flatMap，如下：</p><p><img src="'+Ra+'" alt="image-20240121183053044"></p><h4 id="b-object-fromentries" tabindex="-1"><a class="header-anchor" href="#b-object-fromentries" aria-hidden="true">#</a> B）Object fromEntries</h4><p><img src="'+Ma+'" alt="image-20240121180318540"></p><p>使用Object.fromEntries可以将entrie转换成对象，如下：’</p><p><img src="'+Ga+'" alt="image-20240121183503668"></p><h4 id="c-trimstart和trimend" tabindex="-1"><a class="header-anchor" href="#c-trimstart和trimend" aria-hidden="true">#</a> C）trimStart和trimEnd</h4><p><img src="'+Da+'" alt="image-20240121180340032"></p><p>我们可以使用trim去除字符串两端空格，使用trimStart去除字符串开头空格，trimEnd去除尾部空格，如下：</p><p><img src="'+za+'" alt="image-20240121183927418"></p><h3 id="_4-es11新增特性解析" tabindex="-1"><a class="header-anchor" href="#_4-es11新增特性解析" aria-hidden="true">#</a> 4. ES11新增特性解析</h3><h4 id="a-bigint" tabindex="-1"><a class="header-anchor" href="#a-bigint" aria-hidden="true">#</a> A）BigInt</h4><p><img src="'+Na+'" alt="image-20240121184335195"></p><p>超过最大整数范围，再进行计算，会产生错误，如下:</p><p><img src="'+Fa+'" alt="image-20240121184719124"></p><p>我们确实想表示大数字，并且计算，可以在末尾加上n，如下：</p><p><img src="'+Ia+'" alt="image-20240121185024667"></p><h4 id="b-nullish-coalescing-operator-空值合并运算符" tabindex="-1"><a class="header-anchor" href="#b-nullish-coalescing-operator-空值合并运算符" aria-hidden="true">#</a> B）Nullish Coalescing Operator(空值合并运算符)</h4><p>当我们一个值为undefined或null时，给他赋值一个默认值，逻辑或||是做不到的，如下：</p><p><img src="'+Ja+'" alt="image-20240121192213249"></p><p>我们可以使用空值合并运算符??，当??前面的值为undefined或null时，返回??后面的值，如下：</p><p><img src="'+Ta+'" alt="image-20240121192509909"></p><p><img src="'+Ka+'" alt="image-20240121192618126"></p><h4 id="c-optional-chaining-可选链" tabindex="-1"><a class="header-anchor" href="#c-optional-chaining-可选链" aria-hidden="true">#</a> C）Optional Chaining(可选链)</h4><p><img src="'+Va+'" alt="image-20240121193147538"></p><p>如果某个属性或方法不存在，我们却使用它，会报错，如下：</p><p><img src="'+qa+'" alt="image-20240121193124017"></p><p>因此为了防止报错，影响后续代码执行，我们可以使用条件判断，再去调用方法，如下：</p><p><img src="'+Ha+'" alt="image-20240121193341776"></p><p>但是在ES11中新增了可选链，可以简化代码，如下：</p><p><img src="'+La+'" alt="image-20240121194212742"></p><h4 id="d-golbalthis" tabindex="-1"><a class="header-anchor" href="#d-golbalthis" aria-hidden="true">#</a> D）GolbalThis</h4><p><img src="'+Qa+'" alt="image-20240121194402581"></p><h3 id="_5-es12新增特性解析" tabindex="-1"><a class="header-anchor" href="#_5-es12新增特性解析" aria-hidden="true">#</a> 5. ES12新增特性解析</h3><h4 id="a-finalizationregistry" tabindex="-1"><a class="header-anchor" href="#a-finalizationregistry" aria-hidden="true">#</a> A）FinalizationRegistry</h4><p><img src="'+Ua+'" alt="image-20240122105310683"></p><p>FinalizationRegistry 对象可以让你在对象被垃圾回收时请求一个回调，如下：</p><p><img src="'+Xa+'" alt="image-20240122104622709"></p><p>我们可以监听多个对象被GC回收，如下：</p><p><img src="'+Ya+'" alt="image-20240122104835878"></p><p>但是我们如何区分哪个对象被回收呢，我们可以向register中传递第二个参数，如下：</p><p><img src="'+Za+'" alt="image-20240122105038705"></p><h4 id="b-weakrefs" tabindex="-1"><a class="header-anchor" href="#b-weakrefs" aria-hidden="true">#</a> B）WeakRefs</h4><p><img src="'+$a+'" alt="image-20240122105326753"></p><p>只要有一个强引用指向该对象，那么该对象就不会被GC回收，如下：</p><p><img src="'+a2+'" alt="image-20240122110026706"></p><p>那么我们就可以使用WeakRef包括该对象，再赋值给其他变量，如下：</p><p><img src="'+i2+'" alt="image-20240122110623741"></p><p>我们如何获取WeakRef包装后的对象呢，要使用对象.deref，如下：</p><p><img src="'+e2+'" alt="image-20240122111228221"></p><h4 id="c-逻辑复制运算符" tabindex="-1"><a class="header-anchor" href="#c-逻辑复制运算符" aria-hidden="true">#</a> C）逻辑复制运算符</h4><p><img src="'+s2+'" alt="image-20240122111943488"></p><p>逻辑赋值运算符类似于之前用过的+=，如下：</p><p><img src="'+t2+'" alt="image-20240122112437302"></p><h4 id="d-replaceall" tabindex="-1"><a class="header-anchor" href="#d-replaceall" aria-hidden="true">#</a> D）replaceAll</h4><p><img src="'+p2+'" alt="image-20240122113021110"></p><p>当我们想替换一个字符串中的某些字符时，会想到使用replace，但是该方法只会替换满足条件的第一个字符，如下：</p><p><img src="'+r2+'" alt="image-20240122113325902"></p><p>因此我们可以使用replaceAll方法，如下：</p><p><img src="'+n2+'" alt="image-20240122113500859"></p><h3 id="_6-es13新增特性解析" tabindex="-1"><a class="header-anchor" href="#_6-es13新增特性解析" aria-hidden="true">#</a> 6. ES13新增特性解析</h3><h4 id="a-method-at" tabindex="-1"><a class="header-anchor" href="#a-method-at" aria-hidden="true">#</a> A）method.at()</h4><p><img src="'+g2+'" alt="image-20240122113653095"></p><h4 id="b-object-hasown-obj-propkey" tabindex="-1"><a class="header-anchor" href="#b-object-hasown-obj-propkey" aria-hidden="true">#</a> B）Object.hasOwn(obj, propKey)</h4><p><img src="'+m2+'" alt="image-20240122113844264"></p><p>我们之前通过一个方法hasOwnProperty，来判断某个属性或者方法属于该对象本身还是原型对象，如下：</p><p><img src="'+c2+'" alt="image-20240122114316531"></p><p>官方推荐使用Object.hasOwn方法来替代obj.hasOwnProperty方法，因为有可能在obj中hasOwnProperty方法被人重写。如下：</p><p><img src="'+o2+'" alt="image-20240122114945552"></p><p>如果我们通过Object.create(null)创建一个原型为null的对象。再去调用hasOwnProperty来判断某个属性是否存在，会报错，如下：</p><p><img src="'+d2+'" alt="image-20240122115626084"></p><p>因此这时候我们就可以使用Object.hasOwn方法，如下：</p><p><img src="'+h2+'" alt="image-20240122115729820"></p><h4 id="c-new-members-of-classes" tabindex="-1"><a class="header-anchor" href="#c-new-members-of-classes" aria-hidden="true">#</a> C）New members of classes</h4><p><img src="'+l2+'" alt="image-20240122115900499"></p><p>我们可以在类中通过public instance fields，给实例化出来的每个对象，添加该属性，如下：</p><p><img src="'+_2+'" alt="image-20240122122057896"></p><p>在以前，我们想定义一个私有的实例属性，需要在变量前面添加下划线，但是外界还是可以访问到，如下：</p><p><img src="'+x2+'" alt="image-20240122122443151"></p><p>在ES13中，我们可以以#开头来定义一个真正的私有属性，我们在外界访问会报错。如下：</p><p><img src="'+b2+'" alt="image-20240122122744561"></p><p>我们还可以使用static来定义一个公共类属性，如下：</p><p><img src="'+f2+'" alt="image-20240122123026934"></p><p>我们可以同时使用static和#来定义一个私有类属性，在外界访问会报错，如下：</p><p><img src="'+j2+'" alt="image-20240122123328143"></p><p>ES13中还可在类中书写静态代码块，来做一些初始化操作，并且静态代码块在class被加载时就会执行，如下：</p><p><img src="'+u2+'" alt="image-20240122124205290"></p><h2 id="三、proxy和reflect" tabindex="-1"><a class="header-anchor" href="#三、proxy和reflect" aria-hidden="true">#</a> 三、Proxy和Reflect</h2><h3 id="_1-监听对象的操作" tabindex="-1"><a class="header-anchor" href="#_1-监听对象的操作" aria-hidden="true">#</a> 1. 监听对象的操作</h3><p><img src="'+y2+'" alt="image-20240122185841911"></p><p>个需求：有一个对象，我们希望监听这个对象中的属性被设置或获取的过程。我们可以通过之前的属性描述符中的存储属性描述符来做到，如下：</p><p><img src="'+S2+'" alt="image-20240122193335106"></p><p>但是这样做有什么缺点呢？首先，Object.defineProperty设计的初衷，不是为了去监听截止一个对象中 所有的属性的。其次，如果我们想监听更加丰富的操作，比如新增属性、删除属性，那么 Object.defineProperty是无能为力的。</p><h3 id="_2-proxy类基本使用" tabindex="-1"><a class="header-anchor" href="#_2-proxy类基本使用" aria-hidden="true">#</a> 2. Proxy类基本使用</h3><p>ES6中，如果我们希望监听一个对象的相关操作，那么我们可以先创建一个代理对象(Proxy对象)。之后对该对象的所有操作，都通过代理对象来完成，代理对象可以监听我们想要对原对象进行哪些操作。</p><p><img src="'+k2+'" alt="image-20240122193928992"></p><p><img src="'+w2+'" alt="image-20240122195137983"></p><h3 id="_3-proxy常见捕获器" tabindex="-1"><a class="header-anchor" href="#_3-proxy常见捕获器" aria-hidden="true">#</a> 3. Proxy常见捕获器</h3><p><img src="'+E2+'" alt="image-20240122193949187"></p><h4 id="a-set和get捕获器" tabindex="-1"><a class="header-anchor" href="#a-set和get捕获器" aria-hidden="true">#</a> A）set和get捕获器</h4><p>如果我们想要侦听某些具体的操作，那么就可以在handler中添加对应的捕捉器(Trap)， set和get分别对应的是函数类型。如下：</p><p><img src="'+O2+'" alt="image-20240122200101499"></p><p>相比于Object.defineProperty，当我们添加一个新属性时，也会监听到。如下：</p><p><img src="'+P2+'" alt="image-20240122200511223"></p><h4 id="b-其他捕获器" tabindex="-1"><a class="header-anchor" href="#b-其他捕获器" aria-hidden="true">#</a> B）其他捕获器</h4><p><img src="'+A2+'" alt="image-20240122200628246"></p><p>我们还可以监听对象属性的删除和判断，如下：</p><p><img src="'+v2+'" alt="image-20240122202102000"></p><p>我们还可以监听函数对象的new和apply操作。如下：</p><p><img src="'+C2+'" alt="image-20240122203115364"></p><p><img src="'+B2+'" alt="image-20240122203542330"></p><h3 id="_4-reflect介绍和作用" tabindex="-1"><a class="header-anchor" href="#_4-reflect介绍和作用" aria-hidden="true">#</a> 4. Reflect介绍和作用</h3><p>为什么会出现Relect呢？</p><ul><li>将这些API放到Object身上并不合适，因为Object是一个构造函数。</li></ul><p><img src="'+W2+'" alt="image-20240122203636788"></p><p>当我们使用delete删除对象属性时，我们并不知道是否删除成功。但是我们使用Reflect.deleteProperty就可以知道。如下：</p><p><img src="'+R2+'" alt="image-20240122220303138"></p><h3 id="_5-reflect的基本使用" tabindex="-1"><a class="header-anchor" href="#_5-reflect的基本使用" aria-hidden="true">#</a> 5. Reflect的基本使用</h3><p><img src="'+M2+'" alt="image-20240122203747203"></p><p><img src="'+G2+'" alt="image-20240122203814616"></p><p>在vue3源码中，在操作proxy对象时，同时使用Reflect对象，如下：</p><p><img src="'+D2+'" alt="image-20240122221814354"></p><h3 id="_6-reflect的receiver" tabindex="-1"><a class="header-anchor" href="#_6-reflect的receiver" aria-hidden="true">#</a> 6. Reflect的receiver</h3><p><img src="'+z2+'" alt="image-20240122203827705"></p><p><img src="'+N2+'" alt="image-20240122225144696"></p><p><img src="'+F2+'" alt="image-20240122225014551"></p><p>我们还可以使用Reflect.construct方法，执行构造函数A的代码，但是创建的类型是B，如下：</p><p><img src="'+I2+'" alt="image-20240122225515697"></p><h2 id="四-promise使用详解" tabindex="-1"><a class="header-anchor" href="#四-promise使用详解" aria-hidden="true">#</a> 四，Promise使用详解</h2><h3 id="_1-异步代码的困境" tabindex="-1"><a class="header-anchor" href="#_1-异步代码的困境" aria-hidden="true">#</a> 1. 异步代码的困境</h3><p><img src="'+J2+'" alt="image-20240123080919289"></p><p>我们想要获取异步代码的结果，就需要回调函数。使用了回调函数，就会造成嵌套，进而产生回调地狱，如下：</p><p><img src="'+T2+'" alt="image-20240123093251108"></p><h3 id="_2-认识promise作用" tabindex="-1"><a class="header-anchor" href="#_2-认识promise作用" aria-hidden="true">#</a> 2. 认识Promise作用</h3><p><img src="'+K2+'" alt="image-20240123095506517"></p><h3 id="_3-promise基本使用" tabindex="-1"><a class="header-anchor" href="#_3-promise基本使用" aria-hidden="true">#</a> 3. Promise基本使用</h3><p><img src="'+V2+'" alt="image-20240123095558085"></p><p><img src="'+q2+'" alt="image-20240123095635441"></p><p><img src="'+H2+'" alt="image-20240123095719023"></p><h3 id="_4-promise状态变化" tabindex="-1"><a class="header-anchor" href="#_4-promise状态变化" aria-hidden="true">#</a> 4. Promise状态变化</h3><p><img src="'+L2+'" alt="image-20240123100056550"></p><p>promise的状态只能从pending到fulfilled或pending到reject，如下：</p><p><img src="'+Q2+'" alt="image-20240124080841305"></p><h4 id="a-resolve不同值的区别" tabindex="-1"><a class="header-anchor" href="#a-resolve不同值的区别" aria-hidden="true">#</a> A）resolve不同值的区别</h4><p><img src="'+U2+'" alt="image-20240124081430393"></p><p>如果resolve的值本身是一个Promise，那么当前的Promise状态会由传入的promise来决定。如下：</p><p><img src="'+X2+'" alt="image-20240124082535954"></p><p>如果resolve的值是一个thenable对象，该对象中的then方法会被立即执行。那么当前的Promise状态会由该thenable对象来决定。如下：</p><p><img src="'+Y2+'" alt="image-20240124082929695"></p><h3 id="_5-promise实例方法" tabindex="-1"><a class="header-anchor" href="#_5-promise实例方法" aria-hidden="true">#</a> 5. Promise实例方法</h3><h4 id="a-then方法的参数" tabindex="-1"><a class="header-anchor" href="#a-then方法的参数" aria-hidden="true">#</a> A）then方法的参数</h4><p><img src="'+Z2+'" alt="image-20240124083321626"></p><p>then方法可以接收两个参数，第一个是成功回调函数，第二个是失败的回调函数，如下:</p><p><img src="'+$2+'" alt="image-20240124092220725"></p><h4 id="b-then方法的调用" tabindex="-1"><a class="header-anchor" href="#b-then方法的调用" aria-hidden="true">#</a> B）then方法的调用</h4><p><img src="'+ai+'" alt="image-20240124092324074"></p><p>同一个promise可以被多个then监听，如下：</p><p><img src="'+ii+'" alt="image-20240124092639867"></p><h3 id="_6-promise的类方法" tabindex="-1"><a class="header-anchor" href="#_6-promise的类方法" aria-hidden="true">#</a> 6. Promise的类方法</h3>',347),ti=[si];function pi(ri,ni){return i(),e("div",null,ti)}const mi=a(ei,[["render",pi],["__file","05.html.vue"]]);export{mi as default};
